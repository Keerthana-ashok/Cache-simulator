
rescue_10.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000054e  00800200  00003c74  00003d08  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003c74  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000110e  0080074e  0080074e  00004256  2**0
                  ALLOC
  3 .stab         0000366c  00000000  00000000  00004258  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000a6c  00000000  00000000  000078c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000e0  00000000  00000000  00008330  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000322a  00000000  00000000  00008410  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000535  00000000  00000000  0000b63a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000f03  00000000  00000000  0000bb6f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000c5c  00000000  00000000  0000ca74  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000995  00000000  00000000  0000d6d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000033d5  00000000  00000000  0000e065  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000100  00000000  00000000  0001143a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 b3 00 	jmp	0x166	; 0x166 <__ctors_end>
       4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
       8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
       c:	0c 94 1f 07 	jmp	0xe3e	; 0xe3e <__vector_3>
      10:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      14:	0c 94 04 04 	jmp	0x808	; 0x808 <__vector_5>
      18:	0c 94 df 03 	jmp	0x7be	; 0x7be <__vector_6>
      1c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      20:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      24:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      28:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      2c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      30:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      34:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      38:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      3c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      40:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      44:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      48:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      4c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      50:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      54:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      58:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      5c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      60:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      64:	0c 94 02 17 	jmp	0x2e04	; 0x2e04 <__vector_25>
      68:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      6c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      70:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      74:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      78:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      7c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      80:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      84:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      88:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      8c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      90:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      94:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      98:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      9c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      ac:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      bc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      cc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      dc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      e0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	lds	r29, 0x78
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	sts	0xb8, r17
      f2:	ba ab       	sts	0x5a, r27
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	sts	0x9b, r26
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	sts	0x5e, r27
     126:	aa aa       	sts	0x9a, r26
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	sts	0x41, r30
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <angle_rotate+0x6>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	17 e0       	ldi	r17, 0x07	; 7
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	e4 e7       	ldi	r30, 0x74	; 116
     17e:	fc e3       	ldi	r31, 0x3C	; 60
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	ae 34       	cpi	r26, 0x4E	; 78
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	18 e1       	ldi	r17, 0x18	; 24
     192:	ae e4       	ldi	r26, 0x4E	; 78
     194:	b7 e0       	ldi	r27, 0x07	; 7
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	ac 35       	cpi	r26, 0x5C	; 92
     19c:	b1 07       	cpc	r27, r17
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	0e 94 31 19 	call	0x3262	; 0x3262 <main>
     1a4:	0c 94 38 1e 	jmp	0x3c70	; 0x3c70 <_exit>

000001a8 <__bad_interrupt>:
     1a8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001ac <timer1_init>:
//prescale:256
// WGM: 7) PWM 10bit fast, TOP=0x03FF
// actual value: 52.25Hz 
void timer1_init(void)
{
 TCCR1B = 0x00; //stop
     1ac:	e1 e8       	ldi	r30, 0x81	; 129
     1ae:	f0 e0       	ldi	r31, 0x00	; 0
     1b0:	10 82       	st	Z, r1
 TCNT1H = 0xFC; //Counter high value to which OCR1xH value is to be compared with
     1b2:	8c ef       	ldi	r24, 0xFC	; 252
     1b4:	80 93 85 00 	sts	0x0085, r24
 TCNT1L = 0x01;	//Counter low value to which OCR1xH value is to be compared with
     1b8:	81 e0       	ldi	r24, 0x01	; 1
     1ba:	80 93 84 00 	sts	0x0084, r24
 OCR1AH = 0x03;	//Output compare Register high value for servo 1
     1be:	93 e0       	ldi	r25, 0x03	; 3
     1c0:	90 93 89 00 	sts	0x0089, r25
 OCR1AL = 0xFF;	//Output Compare Register low Value For servo 1
     1c4:	8f ef       	ldi	r24, 0xFF	; 255
     1c6:	80 93 88 00 	sts	0x0088, r24
 OCR1BH = 0x03;	//Output compare Register high value for servo 2
     1ca:	90 93 8b 00 	sts	0x008B, r25
 OCR1BL = 0xFF;	//Output Compare Register low Value For servo 2
     1ce:	80 93 8a 00 	sts	0x008A, r24
 OCR1CH = 0x03;	//Output compare Register high value for servo 3
     1d2:	90 93 8d 00 	sts	0x008D, r25
 OCR1CL = 0xFF;	//Output Compare Register low Value For servo 3
     1d6:	80 93 8c 00 	sts	0x008C, r24
 ICR1H  = 0x03;	
     1da:	90 93 87 00 	sts	0x0087, r25
 ICR1L  = 0xFF;
     1de:	80 93 86 00 	sts	0x0086, r24
 TCCR1A = 0xAB; /*{COM1A1=1, COM1A0=0; COM1B1=1, COM1B0=0; COM1C1=1 COM1C0=0}
     1e2:	8b ea       	ldi	r24, 0xAB	; 171
     1e4:	80 93 80 00 	sts	0x0080, r24
 					For Overriding normal port functionality to OCRnA outputs.
				  {WGM11=1, WGM10=1} Along With WGM12 in TCCR1B for Selecting FAST PWM Mode*/
 TCCR1C = 0x00;
     1e8:	10 92 82 00 	sts	0x0082, r1
 TCCR1B = 0x0C; //WGM12=1; CS12=1, CS11=0, CS10=0 (Prescaler=256)
     1ec:	8c e0       	ldi	r24, 0x0C	; 12
     1ee:	80 83       	st	Z, r24
}
     1f0:	08 95       	ret

000001f2 <servo_1>:
//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)  
{
 float PositionPanServo = 0;
  PositionPanServo = ((float)degrees / 1.86) + 35.0;
 OCR1AH = 0x00;
     1f2:	10 92 89 00 	sts	0x0089, r1

//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)  
{
 float PositionPanServo = 0;
  PositionPanServo = ((float)degrees / 1.86) + 35.0;
     1f6:	68 2f       	mov	r22, r24
     1f8:	70 e0       	ldi	r23, 0x00	; 0
     1fa:	80 e0       	ldi	r24, 0x00	; 0
     1fc:	90 e0       	ldi	r25, 0x00	; 0
     1fe:	0e 94 75 1b 	call	0x36ea	; 0x36ea <__floatunsisf>
     202:	2b e7       	ldi	r18, 0x7B	; 123
     204:	34 e1       	ldi	r19, 0x14	; 20
     206:	4e ee       	ldi	r20, 0xEE	; 238
     208:	5f e3       	ldi	r21, 0x3F	; 63
     20a:	0e 94 dc 1a 	call	0x35b8	; 0x35b8 <__divsf3>
     20e:	20 e0       	ldi	r18, 0x00	; 0
     210:	30 e0       	ldi	r19, 0x00	; 0
     212:	4c e0       	ldi	r20, 0x0C	; 12
     214:	52 e4       	ldi	r21, 0x42	; 66
     216:	0e 94 74 1a 	call	0x34e8	; 0x34e8 <__addsf3>
 OCR1AH = 0x00;
 OCR1AL = (unsigned char) PositionPanServo;
     21a:	0e 94 49 1b 	call	0x3692	; 0x3692 <__fixunssfsi>
     21e:	60 93 88 00 	sts	0x0088, r22
}
     222:	08 95       	ret

00000224 <color_sensor_scaling>:
//Color Sensing Scaling
void color_sensor_scaling()		//This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
{
	//Output Scaling 20% from datasheet
	//PORTD = PORTD & 0xEF;
	PORTD = PORTD | 0x10; //set S0 high
     224:	5c 9a       	sbi	0x0b, 4	; 11
	//PORTD = PORTD & 0xDF; //set S1 low
	PORTD = PORTD | 0x20; //set S1 high
     226:	5d 9a       	sbi	0x0b, 5	; 11
}
     228:	08 95       	ret

0000022a <update>:
	
	return retval;
}

void update(int an,int bn)		// Update the paths (midpoints) for visiting
{
     22a:	0f 93       	push	r16
     22c:	1f 93       	push	r17
     22e:	cf 93       	push	r28
     230:	df 93       	push	r29
     232:	ec 01       	movw	r28, r24
     234:	8b 01       	movw	r16, r22
	prv_node=an;
     236:	90 93 77 07 	sts	0x0777, r25
     23a:	80 93 76 07 	sts	0x0776, r24
	push(an);
     23e:	0e 94 4f 01 	call	0x29e	; 0x29e <push>
	crt_node=bn;
     242:	10 93 4d 07 	sts	0x074D, r17
     246:	00 93 4c 07 	sts	0x074C, r16
	path[an][bn]=path[bn][an]=1;
     24a:	4a e1       	ldi	r20, 0x1A	; 26
     24c:	50 e0       	ldi	r21, 0x00	; 0
     24e:	04 9f       	mul	r16, r20
     250:	f0 01       	movw	r30, r0
     252:	05 9f       	mul	r16, r21
     254:	f0 0d       	add	r31, r0
     256:	14 9f       	mul	r17, r20
     258:	f0 0d       	add	r31, r0
     25a:	11 24       	eor	r1, r1
     25c:	ec 0f       	add	r30, r28
     25e:	fd 1f       	adc	r31, r29
     260:	6a e7       	ldi	r22, 0x7A	; 122
     262:	77 e0       	ldi	r23, 0x07	; 7
     264:	ee 0f       	add	r30, r30
     266:	ff 1f       	adc	r31, r31
     268:	e6 0f       	add	r30, r22
     26a:	f7 1f       	adc	r31, r23
     26c:	21 e0       	ldi	r18, 0x01	; 1
     26e:	30 e0       	ldi	r19, 0x00	; 0
     270:	31 83       	std	Z+1, r19	; 0x01
     272:	20 83       	st	Z, r18
     274:	c4 9f       	mul	r28, r20
     276:	c0 01       	movw	r24, r0
     278:	c5 9f       	mul	r28, r21
     27a:	90 0d       	add	r25, r0
     27c:	d4 9f       	mul	r29, r20
     27e:	90 0d       	add	r25, r0
     280:	11 24       	eor	r1, r1
     282:	80 0f       	add	r24, r16
     284:	91 1f       	adc	r25, r17
     286:	88 0f       	add	r24, r24
     288:	99 1f       	adc	r25, r25
     28a:	68 0f       	add	r22, r24
     28c:	79 1f       	adc	r23, r25
     28e:	fb 01       	movw	r30, r22
     290:	31 83       	std	Z+1, r19	; 0x01
     292:	20 83       	st	Z, r18
}
     294:	df 91       	pop	r29
     296:	cf 91       	pop	r28
     298:	1f 91       	pop	r17
     29a:	0f 91       	pop	r16
     29c:	08 95       	ret

0000029e <push>:
	//send(50,crt_node,0);	// position flag		
}

void push(int x)
{
	sp++;
     29e:	20 91 c8 0c 	lds	r18, 0x0CC8
     2a2:	30 91 c9 0c 	lds	r19, 0x0CC9
     2a6:	2f 5f       	subi	r18, 0xFF	; 255
     2a8:	3f 4f       	sbci	r19, 0xFF	; 255
     2aa:	30 93 c9 0c 	sts	0x0CC9, r19
     2ae:	20 93 c8 0c 	sts	0x0CC8, r18
	store[sp]=x;
     2b2:	f9 01       	movw	r30, r18
     2b4:	ee 0f       	add	r30, r30
     2b6:	ff 1f       	adc	r31, r31
     2b8:	e4 5a       	subi	r30, 0xA4	; 164
     2ba:	fe 4e       	sbci	r31, 0xEE	; 238
     2bc:	91 83       	std	Z+1, r25	; 0x01
     2be:	80 83       	st	Z, r24
}
     2c0:	08 95       	ret

000002c2 <USART0_TX>:
	}		
}

void USART0_TX(int data)
{
	while(!(UCSR0A & (1<<UDRE0)))
     2c2:	e0 ec       	ldi	r30, 0xC0	; 192
     2c4:	f0 e0       	ldi	r31, 0x00	; 0
     2c6:	90 81       	ld	r25, Z
     2c8:	95 ff       	sbrs	r25, 5
     2ca:	fd cf       	rjmp	.-6      	; 0x2c6 <USART0_TX+0x4>
		;
	UDR0 = data;
     2cc:	80 93 c6 00 	sts	0x00C6, r24
}
     2d0:	08 95       	ret

000002d2 <send>:

void send(int a,int b,int c)
{
     2d2:	0f 93       	push	r16
     2d4:	1f 93       	push	r17
     2d6:	cf 93       	push	r28
     2d8:	df 93       	push	r29
     2da:	eb 01       	movw	r28, r22
     2dc:	8a 01       	movw	r16, r20
	USART0_TX(a);
     2de:	0e 94 61 01 	call	0x2c2	; 0x2c2 <USART0_TX>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     2e2:	80 e7       	ldi	r24, 0x70	; 112
     2e4:	91 e0       	ldi	r25, 0x01	; 1
     2e6:	01 97       	sbiw	r24, 0x01	; 1
     2e8:	f1 f7       	brne	.-4      	; 0x2e6 <send+0x14>
     2ea:	00 c0       	rjmp	.+0      	; 0x2ec <send+0x1a>
	_delay_us(100);
	USART0_TX(b);
     2ec:	ce 01       	movw	r24, r28
     2ee:	0e 94 61 01 	call	0x2c2	; 0x2c2 <USART0_TX>
     2f2:	a0 e7       	ldi	r26, 0x70	; 112
     2f4:	b1 e0       	ldi	r27, 0x01	; 1
     2f6:	11 97       	sbiw	r26, 0x01	; 1
     2f8:	f1 f7       	brne	.-4      	; 0x2f6 <send+0x24>
     2fa:	00 c0       	rjmp	.+0      	; 0x2fc <send+0x2a>
	_delay_us(100);
	USART0_TX(c);
     2fc:	c8 01       	movw	r24, r16
     2fe:	0e 94 61 01 	call	0x2c2	; 0x2c2 <USART0_TX>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     302:	8f ef       	ldi	r24, 0xFF	; 255
     304:	9f e7       	ldi	r25, 0x7F	; 127
     306:	a4 e0       	ldi	r26, 0x04	; 4
     308:	81 50       	subi	r24, 0x01	; 1
     30a:	90 40       	sbci	r25, 0x00	; 0
     30c:	a0 40       	sbci	r26, 0x00	; 0
     30e:	e1 f7       	brne	.-8      	; 0x308 <send+0x36>
     310:	00 c0       	rjmp	.+0      	; 0x312 <send+0x40>
     312:	00 00       	nop
	_delay_ms(100);
	if (search_complete_flag == 1)
     314:	80 91 68 07 	lds	r24, 0x0768
     318:	90 91 69 07 	lds	r25, 0x0769
     31c:	81 30       	cpi	r24, 0x01	; 1
     31e:	91 05       	cpc	r25, r1
     320:	31 f4       	brne	.+12     	; 0x32e <send+0x5c>
	{
		ACK = 1;
     322:	81 e0       	ldi	r24, 0x01	; 1
     324:	90 e0       	ldi	r25, 0x00	; 0
     326:	90 93 61 07 	sts	0x0761, r25
     32a:	80 93 60 07 	sts	0x0760, r24
	}
}
     32e:	df 91       	pop	r29
     330:	cf 91       	pop	r28
     332:	1f 91       	pop	r17
     334:	0f 91       	pop	r16
     336:	08 95       	ret

00000338 <send1>:

void send1(int a,int b)
{
     338:	cf 93       	push	r28
     33a:	df 93       	push	r29
     33c:	eb 01       	movw	r28, r22
	USART0_TX(a);
     33e:	0e 94 61 01 	call	0x2c2	; 0x2c2 <USART0_TX>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     342:	80 e7       	ldi	r24, 0x70	; 112
     344:	91 e0       	ldi	r25, 0x01	; 1
     346:	01 97       	sbiw	r24, 0x01	; 1
     348:	f1 f7       	brne	.-4      	; 0x346 <send1+0xe>
     34a:	00 c0       	rjmp	.+0      	; 0x34c <send1+0x14>
	_delay_us(100);
	USART0_TX(b);
     34c:	ce 01       	movw	r24, r28
     34e:	0e 94 61 01 	call	0x2c2	; 0x2c2 <USART0_TX>
     352:	80 e7       	ldi	r24, 0x70	; 112
     354:	91 e0       	ldi	r25, 0x01	; 1
     356:	01 97       	sbiw	r24, 0x01	; 1
     358:	f1 f7       	brne	.-4      	; 0x356 <send1+0x1e>
     35a:	00 c0       	rjmp	.+0      	; 0x35c <send1+0x24>
	_delay_us(100);
}
     35c:	df 91       	pop	r29
     35e:	cf 91       	pop	r28
     360:	08 95       	ret

00000362 <lcd_port_config>:
void lcd_line2();
void lcd_string(char*);

void lcd_port_config (void) 			//Function to configure LCD port
{
 	DDRC = DDRC | 0xF7; 		//all the LCD pin's direction set as output
     362:	87 b1       	in	r24, 0x07	; 7
     364:	87 6f       	ori	r24, 0xF7	; 247
     366:	87 b9       	out	0x07, r24	; 7
 	PORTC = PORTC & 0x80; 		// all the LCD pins are set to logic 0 except PORTC 7
     368:	88 b1       	in	r24, 0x08	; 8
     36a:	80 78       	andi	r24, 0x80	; 128
     36c:	88 b9       	out	0x08, r24	; 8
}
     36e:	08 95       	ret

00000370 <lcd_set_4bit>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     370:	86 e6       	ldi	r24, 0x66	; 102
     372:	9e e0       	ldi	r25, 0x0E	; 14
     374:	01 97       	sbiw	r24, 0x01	; 1
     376:	f1 f7       	brne	.-4      	; 0x374 <lcd_set_4bit+0x4>
     378:	00 00       	nop

void lcd_set_4bit()				//Function to Reset LCD
{
	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     37a:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     37c:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     37e:	80 e3       	ldi	r24, 0x30	; 48
     380:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     382:	42 9a       	sbi	0x08, 2	; 8
     384:	ef ef       	ldi	r30, 0xFF	; 255
     386:	f7 e4       	ldi	r31, 0x47	; 71
     388:	31 97       	sbiw	r30, 0x01	; 1
     38a:	f1 f7       	brne	.-4      	; 0x388 <lcd_set_4bit+0x18>
     38c:	00 c0       	rjmp	.+0      	; 0x38e <lcd_set_4bit+0x1e>
     38e:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     390:	42 98       	cbi	0x08, 2	; 8
     392:	e6 e6       	ldi	r30, 0x66	; 102
     394:	fe e0       	ldi	r31, 0x0E	; 14
     396:	31 97       	sbiw	r30, 0x01	; 1
     398:	f1 f7       	brne	.-4      	; 0x396 <lcd_set_4bit+0x26>
     39a:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     39c:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     39e:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     3a0:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     3a2:	42 9a       	sbi	0x08, 2	; 8
     3a4:	ef ef       	ldi	r30, 0xFF	; 255
     3a6:	f7 e4       	ldi	r31, 0x47	; 71
     3a8:	31 97       	sbiw	r30, 0x01	; 1
     3aa:	f1 f7       	brne	.-4      	; 0x3a8 <lcd_set_4bit+0x38>
     3ac:	00 c0       	rjmp	.+0      	; 0x3ae <lcd_set_4bit+0x3e>
     3ae:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     3b0:	42 98       	cbi	0x08, 2	; 8
     3b2:	e6 e6       	ldi	r30, 0x66	; 102
     3b4:	fe e0       	ldi	r31, 0x0E	; 14
     3b6:	31 97       	sbiw	r30, 0x01	; 1
     3b8:	f1 f7       	brne	.-4      	; 0x3b6 <lcd_set_4bit+0x46>
     3ba:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     3bc:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     3be:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     3c0:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     3c2:	42 9a       	sbi	0x08, 2	; 8
     3c4:	8f ef       	ldi	r24, 0xFF	; 255
     3c6:	97 e4       	ldi	r25, 0x47	; 71
     3c8:	01 97       	sbiw	r24, 0x01	; 1
     3ca:	f1 f7       	brne	.-4      	; 0x3c8 <lcd_set_4bit+0x58>
     3cc:	00 c0       	rjmp	.+0      	; 0x3ce <lcd_set_4bit+0x5e>
     3ce:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     3d0:	42 98       	cbi	0x08, 2	; 8
     3d2:	e6 e6       	ldi	r30, 0x66	; 102
     3d4:	fe e0       	ldi	r31, 0x0E	; 14
     3d6:	31 97       	sbiw	r30, 0x01	; 1
     3d8:	f1 f7       	brne	.-4      	; 0x3d6 <lcd_set_4bit+0x66>
     3da:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     3dc:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     3de:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x20;				//Sending 2 to initialise LCD 4-bit mode
     3e0:	80 e2       	ldi	r24, 0x20	; 32
     3e2:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     3e4:	42 9a       	sbi	0x08, 2	; 8
     3e6:	8f ef       	ldi	r24, 0xFF	; 255
     3e8:	97 e4       	ldi	r25, 0x47	; 71
     3ea:	01 97       	sbiw	r24, 0x01	; 1
     3ec:	f1 f7       	brne	.-4      	; 0x3ea <lcd_set_4bit+0x7a>
     3ee:	00 c0       	rjmp	.+0      	; 0x3f0 <lcd_set_4bit+0x80>
     3f0:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     3f2:	42 98       	cbi	0x08, 2	; 8

	
}
     3f4:	08 95       	ret

000003f6 <lcd_wr_command>:
void lcd_wr_command(unsigned char cmd)		//Function to Write Command on LCD
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
	lcd_port &= 0x0F;
     3f6:	98 b1       	in	r25, 0x08	; 8
     3f8:	9f 70       	andi	r25, 0x0F	; 15
     3fa:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
     3fc:	98 b1       	in	r25, 0x08	; 8

void lcd_wr_command(unsigned char cmd)		//Function to Write Command on LCD
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
     3fe:	28 2f       	mov	r18, r24
     400:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     402:	92 2b       	or	r25, r18
     404:	98 b9       	out	0x08, r25	; 8
	cbit(lcd_port,RS);
     406:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     408:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     40a:	42 9a       	sbi	0x08, 2	; 8
     40c:	ef ef       	ldi	r30, 0xFF	; 255
     40e:	f7 e4       	ldi	r31, 0x47	; 71
     410:	31 97       	sbiw	r30, 0x01	; 1
     412:	f1 f7       	brne	.-4      	; 0x410 <lcd_wr_command+0x1a>
     414:	00 c0       	rjmp	.+0      	; 0x416 <lcd_wr_command+0x20>
     416:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     418:	42 98       	cbi	0x08, 2	; 8
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
	lcd_port &= 0x0F;
     41a:	98 b1       	in	r25, 0x08	; 8
     41c:	9f 70       	andi	r25, 0x0F	; 15
     41e:	98 b9       	out	0x08, r25	; 8
	lcd_port |= cmd;
     420:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
     422:	82 95       	swap	r24
     424:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= cmd;
     426:	89 2b       	or	r24, r25
     428:	88 b9       	out	0x08, r24	; 8
	cbit(lcd_port,RS);
     42a:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     42c:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     42e:	42 9a       	sbi	0x08, 2	; 8
     430:	8f ef       	ldi	r24, 0xFF	; 255
     432:	97 e4       	ldi	r25, 0x47	; 71
     434:	01 97       	sbiw	r24, 0x01	; 1
     436:	f1 f7       	brne	.-4      	; 0x434 <lcd_wr_command+0x3e>
     438:	00 c0       	rjmp	.+0      	; 0x43a <lcd_wr_command+0x44>
     43a:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     43c:	42 98       	cbi	0x08, 2	; 8
}
     43e:	08 95       	ret

00000440 <lcd_init>:
	
}

void lcd_init()					//Function to Initialize LCD
{
	lcd_set_4bit();
     440:	0e 94 b8 01 	call	0x370	; 0x370 <lcd_set_4bit>
     444:	86 e6       	ldi	r24, 0x66	; 102
     446:	9e e0       	ldi	r25, 0x0E	; 14
     448:	01 97       	sbiw	r24, 0x01	; 1
     44a:	f1 f7       	brne	.-4      	; 0x448 <lcd_init+0x8>
     44c:	00 00       	nop
	_delay_ms(1);

	lcd_wr_command(0x28);			//LCD 4-bit mode and 2 lines.
     44e:	88 e2       	ldi	r24, 0x28	; 40
     450:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <lcd_wr_command>
	lcd_wr_command(0x01);
     454:	81 e0       	ldi	r24, 0x01	; 1
     456:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <lcd_wr_command>
	lcd_wr_command(0x06);
     45a:	86 e0       	ldi	r24, 0x06	; 6
     45c:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <lcd_wr_command>
	lcd_wr_command(0x0E);
     460:	8e e0       	ldi	r24, 0x0E	; 14
     462:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <lcd_wr_command>
	lcd_wr_command(0x80);
     466:	80 e8       	ldi	r24, 0x80	; 128
     468:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <lcd_wr_command>
		
}
     46c:	08 95       	ret

0000046e <lcd_wr_char>:
void lcd_wr_char(char letter)				//Function to Write Data on LCD
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
	lcd_port &= 0x0F;
     46e:	98 b1       	in	r25, 0x08	; 8
     470:	9f 70       	andi	r25, 0x0F	; 15
     472:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
     474:	98 b1       	in	r25, 0x08	; 8

void lcd_wr_char(char letter)				//Function to Write Data on LCD
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
     476:	28 2f       	mov	r18, r24
     478:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     47a:	92 2b       	or	r25, r18
     47c:	98 b9       	out	0x08, r25	; 8
	sbit(lcd_port,RS);
     47e:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     480:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     482:	42 9a       	sbi	0x08, 2	; 8
     484:	ef ef       	ldi	r30, 0xFF	; 255
     486:	f7 e4       	ldi	r31, 0x47	; 71
     488:	31 97       	sbiw	r30, 0x01	; 1
     48a:	f1 f7       	brne	.-4      	; 0x488 <lcd_wr_char+0x1a>
     48c:	00 c0       	rjmp	.+0      	; 0x48e <lcd_wr_char+0x20>
     48e:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     490:	42 98       	cbi	0x08, 2	; 8

	letter = letter & 0x0F;
	letter = letter<<4;
	lcd_port &= 0x0F;
     492:	98 b1       	in	r25, 0x08	; 8
     494:	9f 70       	andi	r25, 0x0F	; 15
     496:	98 b9       	out	0x08, r25	; 8
	lcd_port |= letter;
     498:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);

	letter = letter & 0x0F;
	letter = letter<<4;
     49a:	82 95       	swap	r24
     49c:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= letter;
     49e:	89 2b       	or	r24, r25
     4a0:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,RS);
     4a2:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     4a4:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     4a6:	42 9a       	sbi	0x08, 2	; 8
     4a8:	8f ef       	ldi	r24, 0xFF	; 255
     4aa:	97 e4       	ldi	r25, 0x47	; 71
     4ac:	01 97       	sbiw	r24, 0x01	; 1
     4ae:	f1 f7       	brne	.-4      	; 0x4ac <lcd_wr_char+0x3e>
     4b0:	00 c0       	rjmp	.+0      	; 0x4b2 <lcd_wr_char+0x44>
     4b2:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     4b4:	42 98       	cbi	0x08, 2	; 8
}
     4b6:	08 95       	ret

000004b8 <lcd_home>:

void lcd_home()					//Function to bring cursor at home position
{
	lcd_wr_command(0x80);
     4b8:	80 e8       	ldi	r24, 0x80	; 128
     4ba:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <lcd_wr_command>
}
     4be:	08 95       	ret

000004c0 <lcd_string>:

void lcd_string(char *str)				//Function to Print String on LCD
{
     4c0:	cf 93       	push	r28
     4c2:	df 93       	push	r29
     4c4:	ec 01       	movw	r28, r24
	while(*str != '\0')
     4c6:	88 81       	ld	r24, Y
     4c8:	88 23       	and	r24, r24
     4ca:	31 f0       	breq	.+12     	; 0x4d8 <lcd_string+0x18>
void lcd_home()					//Function to bring cursor at home position
{
	lcd_wr_command(0x80);
}

void lcd_string(char *str)				//Function to Print String on LCD
     4cc:	21 96       	adiw	r28, 0x01	; 1
{
	while(*str != '\0')
	{
		lcd_wr_char(*str);
     4ce:	0e 94 37 02 	call	0x46e	; 0x46e <lcd_wr_char>
	lcd_wr_command(0x80);
}

void lcd_string(char *str)				//Function to Print String on LCD
{
	while(*str != '\0')
     4d2:	89 91       	ld	r24, Y+
     4d4:	88 23       	and	r24, r24
     4d6:	d9 f7       	brne	.-10     	; 0x4ce <lcd_string+0xe>
	{
		lcd_wr_char(*str);
		str++;
	}
}
     4d8:	df 91       	pop	r29
     4da:	cf 91       	pop	r28
     4dc:	08 95       	ret

000004de <lcd_cursor>:

void lcd_cursor (char row, char column)			//Position the LCD cursor at "row", "column"
{
	switch (row) 
     4de:	82 30       	cpi	r24, 0x02	; 2
     4e0:	79 f0       	breq	.+30     	; 0x500 <lcd_cursor+0x22>
     4e2:	83 30       	cpi	r24, 0x03	; 3
     4e4:	18 f4       	brcc	.+6      	; 0x4ec <lcd_cursor+0xe>
     4e6:	81 30       	cpi	r24, 0x01	; 1
     4e8:	c9 f4       	brne	.+50     	; 0x51c <lcd_cursor+0x3e>
     4ea:	05 c0       	rjmp	.+10     	; 0x4f6 <lcd_cursor+0x18>
     4ec:	83 30       	cpi	r24, 0x03	; 3
     4ee:	69 f0       	breq	.+26     	; 0x50a <lcd_cursor+0x2c>
     4f0:	84 30       	cpi	r24, 0x04	; 4
     4f2:	a1 f4       	brne	.+40     	; 0x51c <lcd_cursor+0x3e>
     4f4:	0f c0       	rjmp	.+30     	; 0x514 <lcd_cursor+0x36>
	{
		case 1: lcd_wr_command (0x80 + column - 1); break;
     4f6:	86 2f       	mov	r24, r22
     4f8:	81 58       	subi	r24, 0x81	; 129
     4fa:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <lcd_wr_command>
     4fe:	08 95       	ret
		case 2: lcd_wr_command (0xc0 + column - 1); break;
     500:	86 2f       	mov	r24, r22
     502:	81 54       	subi	r24, 0x41	; 65
     504:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <lcd_wr_command>
     508:	08 95       	ret
		case 3: lcd_wr_command (0x94 + column - 1); break;
     50a:	86 2f       	mov	r24, r22
     50c:	8d 56       	subi	r24, 0x6D	; 109
     50e:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <lcd_wr_command>
     512:	08 95       	ret
		case 4: lcd_wr_command (0xd4 + column - 1); break;
     514:	86 2f       	mov	r24, r22
     516:	8d 52       	subi	r24, 0x2D	; 45
     518:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <lcd_wr_command>
     51c:	08 95       	ret

0000051e <lcd_print>:
	}
}


void lcd_print (char row, char coloumn, unsigned int value, int digits)	//Function To Print Any input value upto the desired digit on LCD
{
     51e:	0f 93       	push	r16
     520:	1f 93       	push	r17
     522:	cf 93       	push	r28
     524:	df 93       	push	r29
     526:	8a 01       	movw	r16, r20
     528:	e9 01       	movw	r28, r18
	unsigned int temp,unit,tens,hundred,thousand,million;
	unsigned char flag=0;

	if(row == 0 || coloumn == 0)
     52a:	88 23       	and	r24, r24
     52c:	11 f0       	breq	.+4      	; 0x532 <lcd_print+0x14>
     52e:	66 23       	and	r22, r22
     530:	19 f4       	brne	.+6      	; 0x538 <lcd_print+0x1a>
		lcd_home();
     532:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <lcd_home>
     536:	02 c0       	rjmp	.+4      	; 0x53c <lcd_print+0x1e>
	else
		lcd_cursor(row,coloumn);
     538:	0e 94 6f 02 	call	0x4de	; 0x4de <lcd_cursor>

	if(digits == 5 || flag == 1)
     53c:	c5 30       	cpi	r28, 0x05	; 5
     53e:	d1 05       	cpc	r29, r1
     540:	51 f4       	brne	.+20     	; 0x556 <lcd_print+0x38>
	{
		million = value / 10000 + 48;
     542:	c8 01       	movw	r24, r16
     544:	60 e1       	ldi	r22, 0x10	; 16
     546:	77 e2       	ldi	r23, 0x27	; 39
     548:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <__udivmodhi4>
		lcd_wr_char(million);
     54c:	86 2f       	mov	r24, r22
     54e:	80 5d       	subi	r24, 0xD0	; 208
     550:	0e 94 37 02 	call	0x46e	; 0x46e <lcd_wr_char>
     554:	03 c0       	rjmp	.+6      	; 0x55c <lcd_print+0x3e>
		flag=1;
	}

	if(digits == 4 || flag == 1)
     556:	c4 30       	cpi	r28, 0x04	; 4
     558:	d1 05       	cpc	r29, r1
     55a:	79 f4       	brne	.+30     	; 0x57a <lcd_print+0x5c>
	{
		temp = value / 1000;
     55c:	c8 01       	movw	r24, r16
     55e:	68 ee       	ldi	r22, 0xE8	; 232
     560:	73 e0       	ldi	r23, 0x03	; 3
     562:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <__udivmodhi4>
     566:	cb 01       	movw	r24, r22
		thousand = temp % 10 + 48;
     568:	6a e0       	ldi	r22, 0x0A	; 10
     56a:	70 e0       	ldi	r23, 0x00	; 0
     56c:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <__udivmodhi4>
		lcd_wr_char(thousand);
     570:	80 5d       	subi	r24, 0xD0	; 208
     572:	0e 94 37 02 	call	0x46e	; 0x46e <lcd_wr_char>
		flag=1;
     576:	81 e0       	ldi	r24, 0x01	; 1
     578:	01 c0       	rjmp	.+2      	; 0x57c <lcd_print+0x5e>


void lcd_print (char row, char coloumn, unsigned int value, int digits)	//Function To Print Any input value upto the desired digit on LCD
{
	unsigned int temp,unit,tens,hundred,thousand,million;
	unsigned char flag=0;
     57a:	80 e0       	ldi	r24, 0x00	; 0
		thousand = temp % 10 + 48;
		lcd_wr_char(thousand);
		flag=1;
	}
 
	if(digits == 3 || flag == 1)
     57c:	c3 30       	cpi	r28, 0x03	; 3
     57e:	d1 05       	cpc	r29, r1
     580:	11 f0       	breq	.+4      	; 0x586 <lcd_print+0x68>
     582:	81 30       	cpi	r24, 0x01	; 1
     584:	71 f4       	brne	.+28     	; 0x5a2 <lcd_print+0x84>
	{
		temp = value / 100;
     586:	c8 01       	movw	r24, r16
     588:	64 e6       	ldi	r22, 0x64	; 100
     58a:	70 e0       	ldi	r23, 0x00	; 0
     58c:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <__udivmodhi4>
     590:	cb 01       	movw	r24, r22
		hundred = temp % 10 + 48;
     592:	6a e0       	ldi	r22, 0x0A	; 10
     594:	70 e0       	ldi	r23, 0x00	; 0
     596:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <__udivmodhi4>
		lcd_wr_char(hundred);
     59a:	80 5d       	subi	r24, 0xD0	; 208
     59c:	0e 94 37 02 	call	0x46e	; 0x46e <lcd_wr_char>
		flag=1;
     5a0:	81 e0       	ldi	r24, 0x01	; 1
	}

	if(digits == 2 || flag == 1)
     5a2:	c2 30       	cpi	r28, 0x02	; 2
     5a4:	d1 05       	cpc	r29, r1
     5a6:	11 f0       	breq	.+4      	; 0x5ac <lcd_print+0x8e>
     5a8:	81 30       	cpi	r24, 0x01	; 1
     5aa:	71 f4       	brne	.+28     	; 0x5c8 <lcd_print+0xaa>
	{
		temp = value / 10;
     5ac:	2a e0       	ldi	r18, 0x0A	; 10
     5ae:	30 e0       	ldi	r19, 0x00	; 0
     5b0:	c8 01       	movw	r24, r16
     5b2:	b9 01       	movw	r22, r18
     5b4:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <__udivmodhi4>
     5b8:	cb 01       	movw	r24, r22
		tens = temp % 10 + 48;
     5ba:	b9 01       	movw	r22, r18
     5bc:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <__udivmodhi4>
		lcd_wr_char(tens);
     5c0:	80 5d       	subi	r24, 0xD0	; 208
     5c2:	0e 94 37 02 	call	0x46e	; 0x46e <lcd_wr_char>
		flag=1;
     5c6:	81 e0       	ldi	r24, 0x01	; 1
	}

	if(digits == 1 || flag == 1)
     5c8:	c1 30       	cpi	r28, 0x01	; 1
     5ca:	d1 05       	cpc	r29, r1
     5cc:	11 f0       	breq	.+4      	; 0x5d2 <lcd_print+0xb4>
     5ce:	81 30       	cpi	r24, 0x01	; 1
     5d0:	41 f4       	brne	.+16     	; 0x5e2 <lcd_print+0xc4>
	{
		unit = value % 10 + 48;
     5d2:	c8 01       	movw	r24, r16
     5d4:	6a e0       	ldi	r22, 0x0A	; 10
     5d6:	70 e0       	ldi	r23, 0x00	; 0
     5d8:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <__udivmodhi4>
		lcd_wr_char(unit);
     5dc:	80 5d       	subi	r24, 0xD0	; 208
     5de:	0e 94 37 02 	call	0x46e	; 0x46e <lcd_wr_char>
	}

	if(digits > 5)
     5e2:	c6 30       	cpi	r28, 0x06	; 6
     5e4:	d1 05       	cpc	r29, r1
     5e6:	1c f0       	brlt	.+6      	; 0x5ee <lcd_print+0xd0>
	{
		lcd_wr_char('E');
     5e8:	85 e4       	ldi	r24, 0x45	; 69
     5ea:	0e 94 37 02 	call	0x46e	; 0x46e <lcd_wr_char>
	}
	
}
     5ee:	df 91       	pop	r29
     5f0:	cf 91       	pop	r28
     5f2:	1f 91       	pop	r17
     5f4:	0f 91       	pop	r16
     5f6:	08 95       	ret

000005f8 <adc_pin_config>:
#ifndef SENSOR_H
#define SENSOR_H
#include "lcd.h"
void adc_pin_config (void)			//ADC pin configuration
{
 	DDRF = 0x00; //set PORTF direction as input
     5f8:	10 ba       	out	0x10, r1	; 16
 	PORTF = 0x00; //set PORTF pins floating
     5fa:	11 ba       	out	0x11, r1	; 17
 	DDRK = 0x00; //set PORTK direction as input
     5fc:	10 92 07 01 	sts	0x0107, r1
 	PORTK = 0x00; //set PORTK pins floating
     600:	10 92 08 01 	sts	0x0108, r1
}
     604:	08 95       	ret

00000606 <adc_init>:

void adc_init()
{
	ADCSRA = 0x00;
     606:	ea e7       	ldi	r30, 0x7A	; 122
     608:	f0 e0       	ldi	r31, 0x00	; 0
     60a:	10 82       	st	Z, r1
	ADCSRB = 0x00;		//MUX5 = 0
     60c:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = 0x20;		//Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
     610:	80 e2       	ldi	r24, 0x20	; 32
     612:	80 93 7c 00 	sts	0x007C, r24
	ACSR = 0x80;
     616:	80 e8       	ldi	r24, 0x80	; 128
     618:	80 bf       	out	0x30, r24	; 48
	ADCSRA = 0x86;		//ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
     61a:	86 e8       	ldi	r24, 0x86	; 134
     61c:	80 83       	st	Z, r24
}
     61e:	08 95       	ret

00000620 <ADC_Conversion>:

unsigned char ADC_Conversion(unsigned char Ch)		//This Function accepts the Channel Number and returns the corresponding Analog Value 
{
	unsigned char a;
	if(Ch>7)
     620:	88 30       	cpi	r24, 0x08	; 8
     622:	18 f0       	brcs	.+6      	; 0x62a <ADC_Conversion+0xa>
	{
		ADCSRB = 0x08;
     624:	98 e0       	ldi	r25, 0x08	; 8
     626:	90 93 7b 00 	sts	0x007B, r25
	}
	Ch = Ch & 0x07;  			
     62a:	87 70       	andi	r24, 0x07	; 7
	ADMUX= 0x20| Ch;	   		
     62c:	80 62       	ori	r24, 0x20	; 32
     62e:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA = ADCSRA | 0x40;		//Set start conversion bit
     632:	ea e7       	ldi	r30, 0x7A	; 122
     634:	f0 e0       	ldi	r31, 0x00	; 0
     636:	80 81       	ld	r24, Z
     638:	80 64       	ori	r24, 0x40	; 64
     63a:	80 83       	st	Z, r24
	while((ADCSRA&0x10)==0);	//Wait for ADC conversion to complete
     63c:	80 81       	ld	r24, Z
     63e:	84 ff       	sbrs	r24, 4
     640:	fd cf       	rjmp	.-6      	; 0x63c <ADC_Conversion+0x1c>
	a=ADCH;
     642:	80 91 79 00 	lds	r24, 0x0079
	ADCSRA = ADCSRA|0x10; //clear ADIF (ADC Interrupt Flag) by writing 1 to it
     646:	ea e7       	ldi	r30, 0x7A	; 122
     648:	f0 e0       	ldi	r31, 0x00	; 0
     64a:	90 81       	ld	r25, Z
     64c:	90 61       	ori	r25, 0x10	; 16
     64e:	90 83       	st	Z, r25
	ADCSRB = 0x00;
     650:	10 92 7b 00 	sts	0x007B, r1
	return a;
}
     654:	08 95       	ret

00000656 <Sharp_GP2D12_estimation>:

// This Function calculates the actual distance in millimeters(mm) from the input
// analog value of Sharp Sensor. 
unsigned int Sharp_GP2D12_estimation(unsigned char adc_reading)
{
     656:	0f 93       	push	r16
     658:	1f 93       	push	r17
	float distance;
	unsigned int distanceInt;
	distance = (int)(10.00*(2799.6*(1.00/(pow(adc_reading,1.1546)))));
     65a:	68 2f       	mov	r22, r24
     65c:	70 e0       	ldi	r23, 0x00	; 0
     65e:	80 e0       	ldi	r24, 0x00	; 0
     660:	90 e0       	ldi	r25, 0x00	; 0
     662:	0e 94 75 1b 	call	0x36ea	; 0x36ea <__floatunsisf>
     666:	2f ee       	ldi	r18, 0xEF	; 239
     668:	39 ec       	ldi	r19, 0xC9	; 201
     66a:	43 e9       	ldi	r20, 0x93	; 147
     66c:	5f e3       	ldi	r21, 0x3F	; 63
     66e:	0e 94 8a 1c 	call	0x3914	; 0x3914 <pow>
     672:	b6 2f       	mov	r27, r22
     674:	a7 2f       	mov	r26, r23
     676:	38 2f       	mov	r19, r24
     678:	29 2f       	mov	r18, r25
     67a:	60 e0       	ldi	r22, 0x00	; 0
     67c:	70 e0       	ldi	r23, 0x00	; 0
     67e:	80 e8       	ldi	r24, 0x80	; 128
     680:	9f e3       	ldi	r25, 0x3F	; 63
     682:	42 2f       	mov	r20, r18
     684:	0b 2f       	mov	r16, r27
     686:	1a 2f       	mov	r17, r26
     688:	23 2f       	mov	r18, r19
     68a:	34 2f       	mov	r19, r20
     68c:	a9 01       	movw	r20, r18
     68e:	98 01       	movw	r18, r16
     690:	0e 94 dc 1a 	call	0x35b8	; 0x35b8 <__divsf3>
     694:	2a e9       	ldi	r18, 0x9A	; 154
     696:	39 ef       	ldi	r19, 0xF9	; 249
     698:	4e e2       	ldi	r20, 0x2E	; 46
     69a:	55 e4       	ldi	r21, 0x45	; 69
     69c:	0e 94 27 1c 	call	0x384e	; 0x384e <__mulsf3>
     6a0:	20 e0       	ldi	r18, 0x00	; 0
     6a2:	30 e0       	ldi	r19, 0x00	; 0
     6a4:	40 e2       	ldi	r20, 0x20	; 32
     6a6:	51 e4       	ldi	r21, 0x41	; 65
     6a8:	0e 94 27 1c 	call	0x384e	; 0x384e <__mulsf3>
     6ac:	0e 94 44 1b 	call	0x3688	; 0x3688 <__fixsfsi>
     6b0:	88 27       	eor	r24, r24
     6b2:	77 fd       	sbrc	r23, 7
     6b4:	80 95       	com	r24
     6b6:	98 2f       	mov	r25, r24
     6b8:	0e 94 77 1b 	call	0x36ee	; 0x36ee <__floatsisf>
	distanceInt = (int)distance;
     6bc:	0e 94 44 1b 	call	0x3688	; 0x3688 <__fixsfsi>
	if(distanceInt>800)
	{
		distanceInt=800;
	}
	return distanceInt;
     6c0:	86 2f       	mov	r24, r22
     6c2:	97 2f       	mov	r25, r23
     6c4:	23 e0       	ldi	r18, 0x03	; 3
     6c6:	81 32       	cpi	r24, 0x21	; 33
     6c8:	92 07       	cpc	r25, r18
     6ca:	10 f0       	brcs	.+4      	; 0x6d0 <Sharp_GP2D12_estimation+0x7a>
     6cc:	80 e2       	ldi	r24, 0x20	; 32
     6ce:	93 e0       	ldi	r25, 0x03	; 3
}
     6d0:	1f 91       	pop	r17
     6d2:	0f 91       	pop	r16
     6d4:	08 95       	ret

000006d6 <detect_obstacle>:

int detect_obstacle(int low, int high)			// To detect obstructer present within the distance range low-high 
{
     6d6:	ef 92       	push	r14
     6d8:	ff 92       	push	r15
     6da:	0f 93       	push	r16
     6dc:	1f 93       	push	r17
     6de:	cf 93       	push	r28
     6e0:	df 93       	push	r29
     6e2:	ec 01       	movw	r28, r24
     6e4:	7b 01       	movw	r14, r22
	unsigned char sharp = ADC_Conversion(11);						//Stores the Analog value of front sharp connected to ADC channel 11 into variable "sharp"
     6e6:	8b e0       	ldi	r24, 0x0B	; 11
     6e8:	0e 94 10 03 	call	0x620	; 0x620 <ADC_Conversion>
	int value = Sharp_GP2D12_estimation(sharp);				//Stores Distance calculated in a variable "value".
     6ec:	0e 94 2b 03 	call	0x656	; 0x656 <Sharp_GP2D12_estimation>
     6f0:	48 2f       	mov	r20, r24
     6f2:	08 2f       	mov	r16, r24
     6f4:	19 2f       	mov	r17, r25
	
	lcd_print(1,1,value,3);
     6f6:	81 e0       	ldi	r24, 0x01	; 1
     6f8:	61 e0       	ldi	r22, 0x01	; 1
     6fa:	59 2f       	mov	r21, r25
     6fc:	23 e0       	ldi	r18, 0x03	; 3
     6fe:	30 e0       	ldi	r19, 0x00	; 0
     700:	0e 94 8f 02 	call	0x51e	; 0x51e <lcd_print>
	
	if(value>low && value <high)				// block detected
     704:	c0 17       	cp	r28, r16
     706:	d1 07       	cpc	r29, r17
     708:	44 f4       	brge	.+16     	; 0x71a <detect_obstacle+0x44>
		distanceInt=800;
	}
	return distanceInt;
}

int detect_obstacle(int low, int high)			// To detect obstructer present within the distance range low-high 
     70a:	81 e0       	ldi	r24, 0x01	; 1
     70c:	90 e0       	ldi	r25, 0x00	; 0
     70e:	0e 15       	cp	r16, r14
     710:	1f 05       	cpc	r17, r15
     712:	2c f0       	brlt	.+10     	; 0x71e <detect_obstacle+0x48>
     714:	80 e0       	ldi	r24, 0x00	; 0
     716:	90 e0       	ldi	r25, 0x00	; 0
     718:	02 c0       	rjmp	.+4      	; 0x71e <detect_obstacle+0x48>
	lcd_print(1,1,value,3);
	
	if(value>low && value <high)				// block detected
		return 1;
	else
		return 0;
     71a:	80 e0       	ldi	r24, 0x00	; 0
     71c:	90 e0       	ldi	r25, 0x00	; 0
}
     71e:	df 91       	pop	r29
     720:	cf 91       	pop	r28
     722:	1f 91       	pop	r17
     724:	0f 91       	pop	r16
     726:	ff 90       	pop	r15
     728:	ef 90       	pop	r14
     72a:	08 95       	ret

0000072c <motion_pin_config>:
volatile unsigned int Degrees; //to accept angle in degrees for turning
int switch_flag=0;
//Function to configure ports to enable robot's motion
void motion_pin_config (void)
{
	DDRA = DDRA | 0x0F;
     72c:	81 b1       	in	r24, 0x01	; 1
     72e:	8f 60       	ori	r24, 0x0F	; 15
     730:	81 b9       	out	0x01, r24	; 1
	PORTA = PORTA & 0xF0;
     732:	82 b1       	in	r24, 0x02	; 2
     734:	80 7f       	andi	r24, 0xF0	; 240
     736:	82 b9       	out	0x02, r24	; 2
	DDRL = DDRL | 0x18;   //Setting PL3 and PL4 pins as output for PWM generation
     738:	ea e0       	ldi	r30, 0x0A	; 10
     73a:	f1 e0       	ldi	r31, 0x01	; 1
     73c:	80 81       	ld	r24, Z
     73e:	88 61       	ori	r24, 0x18	; 24
     740:	80 83       	st	Z, r24
	PORTL = PORTL | 0x18; //PL3 and PL4 pins are for velocity control using PWM.
     742:	eb e0       	ldi	r30, 0x0B	; 11
     744:	f1 e0       	ldi	r31, 0x01	; 1
     746:	80 81       	ld	r24, Z
     748:	88 61       	ori	r24, 0x18	; 24
     74a:	80 83       	st	Z, r24
}
     74c:	08 95       	ret

0000074e <left_encoder_pin_config>:

//Function to configure INT4 (PORTE 4) pin as input for the left position encoder
void left_encoder_pin_config (void)
{
	DDRE  = DDRE & 0xEF;  //Set the direction of the PORTE 4 pin as input
     74e:	6c 98       	cbi	0x0d, 4	; 13
	PORTE = PORTE | 0x10; //Enable internal pull-up for PORTE 4 pin
     750:	74 9a       	sbi	0x0e, 4	; 14
}
     752:	08 95       	ret

00000754 <right_encoder_pin_config>:

//Function to configure INT5 (PORTE 5) pin as input for the right position encoder
void right_encoder_pin_config (void)
{
	DDRE  = DDRE & 0xDF;  //Set the direction of the PORTE 4 pin as input
     754:	6d 98       	cbi	0x0d, 5	; 13
	PORTE = PORTE | 0x20; //Enable internal pull-up for PORTE 4 pin
     756:	75 9a       	sbi	0x0e, 5	; 14
}
     758:	08 95       	ret

0000075a <left_position_encoder_interrupt_init>:

void left_position_encoder_interrupt_init (void) //Interrupt 4 enable
{
	cli();	//Clears the global interrupt
     75a:	f8 94       	cli
	EICRB = EICRB | 0x02; // INT4 is set to trigger with falling edge
     75c:	ea e6       	ldi	r30, 0x6A	; 106
     75e:	f0 e0       	ldi	r31, 0x00	; 0
     760:	80 81       	ld	r24, Z
     762:	82 60       	ori	r24, 0x02	; 2
     764:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x10; // Enable Interrupt INT4 for left position encoder
     766:	ec 9a       	sbi	0x1d, 4	; 29
	sei();   // Enables the global interrupt
     768:	78 94       	sei
}
     76a:	08 95       	ret

0000076c <right_position_encoder_interrupt_init>:

void right_position_encoder_interrupt_init (void) //Interrupt 5 enable
{
	cli(); //Clears the global interrupt
     76c:	f8 94       	cli
	EICRB = EICRB | 0x08; // INT5 is set to trigger with falling edge
     76e:	ea e6       	ldi	r30, 0x6A	; 106
     770:	f0 e0       	ldi	r31, 0x00	; 0
     772:	80 81       	ld	r24, Z
     774:	88 60       	ori	r24, 0x08	; 8
     776:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x20; // Enable Interrupt INT5 for right position encoder
     778:	ed 9a       	sbi	0x1d, 5	; 29
	sei();   // Enables the global interrupt
     77a:	78 94       	sei
}
     77c:	08 95       	ret

0000077e <timer5_init>:
// Prescale:256
// PWM 8bit fast, TOP=0x00FF
// Timer Frequency:225.000Hz
void timer5_init()
{
	TCCR5B = 0x00;	//Stop
     77e:	e1 e2       	ldi	r30, 0x21	; 33
     780:	f1 e0       	ldi	r31, 0x01	; 1
     782:	10 82       	st	Z, r1
	TCNT5H = 0xFF;	//Counter higher 8-bit value to which OCR5xH value is compared with
     784:	8f ef       	ldi	r24, 0xFF	; 255
     786:	80 93 25 01 	sts	0x0125, r24
	TCNT5L = 0x01;	//Counter lower 8-bit value to which OCR5xH value is compared with
     78a:	91 e0       	ldi	r25, 0x01	; 1
     78c:	90 93 24 01 	sts	0x0124, r25
	OCR5AH = 0x00;	//Output compare register high value for Left Motor
     790:	10 92 29 01 	sts	0x0129, r1
	OCR5AL = 0xFF;	//Output compare register low value for Left Motor
     794:	80 93 28 01 	sts	0x0128, r24
	OCR5BH = 0x00;	//Output compare register high value for Right Motor
     798:	10 92 2b 01 	sts	0x012B, r1
	OCR5BL = 0xFF;	//Output compare register low value for Right Motor
     79c:	80 93 2a 01 	sts	0x012A, r24
	OCR5CH = 0x00;	//Output compare register high value for Motor C1
     7a0:	10 92 2d 01 	sts	0x012D, r1
	OCR5CL = 0xFF;	//Output compare register low value for Motor C1
     7a4:	80 93 2c 01 	sts	0x012C, r24
	TCCR5A = 0xA9;	/*{COM5A1=1, COM5A0=0; COM5B1=1, COM5B0=0; COM5C1=1 COM5C0=0}
     7a8:	89 ea       	ldi	r24, 0xA9	; 169
     7aa:	80 93 20 01 	sts	0x0120, r24
 					  For Overriding normal port functionality to OCRnA outputs.
				  	  {WGM51=0, WGM50=1} Along With WGM52 in TCCR5B for Selecting FAST PWM 8-bit Mode*/	
	TCCR5B = 0x0B;	//WGM12=1; CS12=0, CS11=1, CS10=1 (Prescaler=64)
     7ae:	8b e0       	ldi	r24, 0x0B	; 11
     7b0:	80 83       	st	Z, r24
}
     7b2:	08 95       	ret

000007b4 <velocity>:

void velocity (unsigned char left_motor, unsigned char right_motor)	// Function for robot velocity control
{
	OCR5AL = (unsigned char)left_motor;
     7b4:	80 93 28 01 	sts	0x0128, r24
	OCR5BL = (unsigned char)right_motor;
     7b8:	60 93 2a 01 	sts	0x012A, r22
}
     7bc:	08 95       	ret

000007be <__vector_6>:

//ISR for right position encoder
ISR(INT5_vect)
{
     7be:	1f 92       	push	r1
     7c0:	0f 92       	push	r0
     7c2:	0f b6       	in	r0, 0x3f	; 63
     7c4:	0f 92       	push	r0
     7c6:	11 24       	eor	r1, r1
     7c8:	8f 93       	push	r24
     7ca:	9f 93       	push	r25
     7cc:	af 93       	push	r26
     7ce:	bf 93       	push	r27
	ShaftCountRight++;  //increment right shaft position count
     7d0:	80 91 d4 0c 	lds	r24, 0x0CD4
     7d4:	90 91 d5 0c 	lds	r25, 0x0CD5
     7d8:	a0 91 d6 0c 	lds	r26, 0x0CD6
     7dc:	b0 91 d7 0c 	lds	r27, 0x0CD7
     7e0:	01 96       	adiw	r24, 0x01	; 1
     7e2:	a1 1d       	adc	r26, r1
     7e4:	b1 1d       	adc	r27, r1
     7e6:	80 93 d4 0c 	sts	0x0CD4, r24
     7ea:	90 93 d5 0c 	sts	0x0CD5, r25
     7ee:	a0 93 d6 0c 	sts	0x0CD6, r26
     7f2:	b0 93 d7 0c 	sts	0x0CD7, r27
}
     7f6:	bf 91       	pop	r27
     7f8:	af 91       	pop	r26
     7fa:	9f 91       	pop	r25
     7fc:	8f 91       	pop	r24
     7fe:	0f 90       	pop	r0
     800:	0f be       	out	0x3f, r0	; 63
     802:	0f 90       	pop	r0
     804:	1f 90       	pop	r1
     806:	18 95       	reti

00000808 <__vector_5>:


//ISR for left position encoder
ISR(INT4_vect)
{
     808:	1f 92       	push	r1
     80a:	0f 92       	push	r0
     80c:	0f b6       	in	r0, 0x3f	; 63
     80e:	0f 92       	push	r0
     810:	11 24       	eor	r1, r1
     812:	8f 93       	push	r24
     814:	9f 93       	push	r25
     816:	af 93       	push	r26
     818:	bf 93       	push	r27
	ShaftCountLeft++;  //increment left shaft position count
     81a:	80 91 d8 0c 	lds	r24, 0x0CD8
     81e:	90 91 d9 0c 	lds	r25, 0x0CD9
     822:	a0 91 da 0c 	lds	r26, 0x0CDA
     826:	b0 91 db 0c 	lds	r27, 0x0CDB
     82a:	01 96       	adiw	r24, 0x01	; 1
     82c:	a1 1d       	adc	r26, r1
     82e:	b1 1d       	adc	r27, r1
     830:	80 93 d8 0c 	sts	0x0CD8, r24
     834:	90 93 d9 0c 	sts	0x0CD9, r25
     838:	a0 93 da 0c 	sts	0x0CDA, r26
     83c:	b0 93 db 0c 	sts	0x0CDB, r27
}
     840:	bf 91       	pop	r27
     842:	af 91       	pop	r26
     844:	9f 91       	pop	r25
     846:	8f 91       	pop	r24
     848:	0f 90       	pop	r0
     84a:	0f be       	out	0x3f, r0	; 63
     84c:	0f 90       	pop	r0
     84e:	1f 90       	pop	r1
     850:	18 95       	reti

00000852 <motion_set>:
void motion_set (unsigned char Direction)
{
	unsigned char PortARestore = 0;

	Direction &= 0x0F; 		// removing upper nibbel for the protection
	PortARestore = PORTA; 		// reading the PORTA original status
     852:	92 b1       	in	r25, 0x02	; 2
	PortARestore &= 0xF0; 		// making lower direction nibbel to 0
     854:	90 7f       	andi	r25, 0xF0	; 240
//Function used for setting motor's direction
void motion_set (unsigned char Direction)
{
	unsigned char PortARestore = 0;

	Direction &= 0x0F; 		// removing upper nibbel for the protection
     856:	8f 70       	andi	r24, 0x0F	; 15
	PortARestore = PORTA; 		// reading the PORTA original status
	PortARestore &= 0xF0; 		// making lower direction nibbel to 0
	PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
     858:	98 2b       	or	r25, r24
	PORTA = PortARestore; 		// executing the command
     85a:	92 b9       	out	0x02, r25	; 2
}
     85c:	08 95       	ret

0000085e <forward>:

void forward (void) //both wheels forward
{
	motion_set(0x06);
     85e:	86 e0       	ldi	r24, 0x06	; 6
     860:	0e 94 29 04 	call	0x852	; 0x852 <motion_set>
}
     864:	08 95       	ret

00000866 <forward_mm>:

void forward_mm (int distance) //both wheels forward
{
     866:	cf 93       	push	r28
     868:	df 93       	push	r29
     86a:	ec 01       	movw	r28, r24
	forward();
     86c:	0e 94 2f 04 	call	0x85e	; 0x85e <forward>
	linear_mm(distance);
     870:	ce 01       	movw	r24, r28
     872:	0e 94 5e 04 	call	0x8bc	; 0x8bc <linear_mm>
}
     876:	df 91       	pop	r29
     878:	cf 91       	pop	r28
     87a:	08 95       	ret

0000087c <back>:

void back (void) //both wheels forward
{
	motion_set(0x09);
     87c:	89 e0       	ldi	r24, 0x09	; 9
     87e:	0e 94 29 04 	call	0x852	; 0x852 <motion_set>
}
     882:	08 95       	ret

00000884 <left>:

void left (void) //Left wheel backward, Right wheel forward
{
	motion_set(0x05);
     884:	85 e0       	ldi	r24, 0x05	; 5
     886:	0e 94 29 04 	call	0x852	; 0x852 <motion_set>
}
     88a:	08 95       	ret

0000088c <right>:

void right (void) //Left wheel forward, Right wheel backward
{
	motion_set(0x0A);
     88c:	8a e0       	ldi	r24, 0x0A	; 10
     88e:	0e 94 29 04 	call	0x852	; 0x852 <motion_set>
}
     892:	08 95       	ret

00000894 <soft_left>:

void soft_left (void) //Left wheel stationary, Right wheel forward
{
	motion_set(0x04);
     894:	84 e0       	ldi	r24, 0x04	; 4
     896:	0e 94 29 04 	call	0x852	; 0x852 <motion_set>
}
     89a:	08 95       	ret

0000089c <soft_right>:

void soft_right (void) //Left wheel forward, Right wheel is stationary
{
	motion_set(0x02);
     89c:	82 e0       	ldi	r24, 0x02	; 2
     89e:	0e 94 29 04 	call	0x852	; 0x852 <motion_set>
}
     8a2:	08 95       	ret

000008a4 <soft_left_2>:

void soft_left_2 (void) //Left wheel backward, right wheel stationary
{
	motion_set(0x01);
     8a4:	81 e0       	ldi	r24, 0x01	; 1
     8a6:	0e 94 29 04 	call	0x852	; 0x852 <motion_set>
}
     8aa:	08 95       	ret

000008ac <soft_right_2>:

void soft_right_2 (void) //Left wheel stationary, Right wheel backward
{
	motion_set(0x08);
     8ac:	88 e0       	ldi	r24, 0x08	; 8
     8ae:	0e 94 29 04 	call	0x852	; 0x852 <motion_set>
}
     8b2:	08 95       	ret

000008b4 <stop>:

void stop (void)
{
	motion_set(0x00);
     8b4:	80 e0       	ldi	r24, 0x00	; 0
     8b6:	0e 94 29 04 	call	0x852	; 0x852 <motion_set>
}
     8ba:	08 95       	ret

000008bc <linear_mm>:
	_delay_ms(100);
}


void linear_mm (unsigned long int distance)		//Line following cowering a specified linear distance in mm
{
     8bc:	8f 92       	push	r8
     8be:	9f 92       	push	r9
     8c0:	af 92       	push	r10
     8c2:	bf 92       	push	r11
     8c4:	cf 92       	push	r12
     8c6:	df 92       	push	r13
     8c8:	ef 92       	push	r14
     8ca:	ff 92       	push	r15
     8cc:	4b 01       	movw	r8, r22
     8ce:	5c 01       	movw	r10, r24
	unsigned long int dec=distance;
	ShaftCountRight=0;
     8d0:	10 92 d4 0c 	sts	0x0CD4, r1
     8d4:	10 92 d5 0c 	sts	0x0CD5, r1
     8d8:	10 92 d6 0c 	sts	0x0CD6, r1
     8dc:	10 92 d7 0c 	sts	0x0CD7, r1

	//forward();
	while((ShaftCountRight * 5.333)<dec)
     8e0:	60 91 d4 0c 	lds	r22, 0x0CD4
     8e4:	70 91 d5 0c 	lds	r23, 0x0CD5
     8e8:	80 91 d6 0c 	lds	r24, 0x0CD6
     8ec:	90 91 d7 0c 	lds	r25, 0x0CD7
     8f0:	0e 94 75 1b 	call	0x36ea	; 0x36ea <__floatunsisf>
     8f4:	20 ef       	ldi	r18, 0xF0	; 240
     8f6:	37 ea       	ldi	r19, 0xA7	; 167
     8f8:	4a ea       	ldi	r20, 0xAA	; 170
     8fa:	50 e4       	ldi	r21, 0x40	; 64
     8fc:	0e 94 27 1c 	call	0x384e	; 0x384e <__mulsf3>
     900:	6b 01       	movw	r12, r22
     902:	7c 01       	movw	r14, r24
     904:	c5 01       	movw	r24, r10
     906:	b4 01       	movw	r22, r8
     908:	0e 94 75 1b 	call	0x36ea	; 0x36ea <__floatunsisf>
     90c:	9b 01       	movw	r18, r22
     90e:	ac 01       	movw	r20, r24
     910:	c7 01       	movw	r24, r14
     912:	b6 01       	movw	r22, r12
     914:	0e 94 d8 1a 	call	0x35b0	; 0x35b0 <__cmpsf2>
     918:	88 23       	and	r24, r24
     91a:	14 f3       	brlt	.-60     	; 0x8e0 <linear_mm+0x24>
	;
	stop();
     91c:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <stop>
     920:	8f ef       	ldi	r24, 0xFF	; 255
     922:	9f e7       	ldi	r25, 0x7F	; 127
     924:	a4 e0       	ldi	r26, 0x04	; 4
     926:	81 50       	subi	r24, 0x01	; 1
     928:	90 40       	sbci	r25, 0x00	; 0
     92a:	a0 40       	sbci	r26, 0x00	; 0
     92c:	e1 f7       	brne	.-8      	; 0x926 <linear_mm+0x6a>
     92e:	00 c0       	rjmp	.+0      	; 0x930 <linear_mm+0x74>
     930:	00 00       	nop
	_delay_ms(100);
}
     932:	ff 90       	pop	r15
     934:	ef 90       	pop	r14
     936:	df 90       	pop	r13
     938:	cf 90       	pop	r12
     93a:	bf 90       	pop	r11
     93c:	af 90       	pop	r10
     93e:	9f 90       	pop	r9
     940:	8f 90       	pop	r8
     942:	08 95       	ret

00000944 <back_mm>:
{
	motion_set(0x00);
}

void back_mm(unsigned int DistanceInMM)
{
     944:	cf 93       	push	r28
     946:	df 93       	push	r29
     948:	ec 01       	movw	r28, r24
	back();
     94a:	0e 94 3e 04 	call	0x87c	; 0x87c <back>
	linear_mm(DistanceInMM);
     94e:	ce 01       	movw	r24, r28
     950:	0e 94 5e 04 	call	0x8bc	; 0x8bc <linear_mm>
}
     954:	df 91       	pop	r29
     956:	cf 91       	pop	r28
     958:	08 95       	ret

0000095a <angle_rotate>:

//Function used for turning robot by specified degrees
void angle_rotate(unsigned int Degrees)
{
     95a:	0f 93       	push	r16
     95c:	1f 93       	push	r17
     95e:	cf 93       	push	r28
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0;

	ReqdShaftCount = (float) Degrees/ 4.090; // division by resolution to get shaft count
     960:	bc 01       	movw	r22, r24
     962:	80 e0       	ldi	r24, 0x00	; 0
     964:	90 e0       	ldi	r25, 0x00	; 0
     966:	0e 94 75 1b 	call	0x36ea	; 0x36ea <__floatunsisf>
     96a:	28 e4       	ldi	r18, 0x48	; 72
     96c:	31 ee       	ldi	r19, 0xE1	; 225
     96e:	42 e8       	ldi	r20, 0x82	; 130
     970:	50 e4       	ldi	r21, 0x40	; 64
     972:	0e 94 dc 1a 	call	0x35b8	; 0x35b8 <__divsf3>
	ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
     976:	0e 94 49 1b 	call	0x3692	; 0x3692 <__fixunssfsi>
     97a:	dc 01       	movw	r26, r24
     97c:	cb 01       	movw	r24, r22
     97e:	a0 e0       	ldi	r26, 0x00	; 0
     980:	b0 e0       	ldi	r27, 0x00	; 0
	ShaftCountRight = 0;
     982:	10 92 d4 0c 	sts	0x0CD4, r1
     986:	10 92 d5 0c 	sts	0x0CD5, r1
     98a:	10 92 d6 0c 	sts	0x0CD6, r1
     98e:	10 92 d7 0c 	sts	0x0CD7, r1
	ShaftCountLeft = 0;
     992:	10 92 d8 0c 	sts	0x0CD8, r1
     996:	10 92 d9 0c 	sts	0x0CD9, r1
     99a:	10 92 da 0c 	sts	0x0CDA, r1
     99e:	10 92 db 0c 	sts	0x0CDB, r1

	while (1)
	{
		if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
     9a2:	f1 e0       	ldi	r31, 0x01	; 1
     9a4:	c0 e0       	ldi	r28, 0x00	; 0
     9a6:	40 91 d4 0c 	lds	r20, 0x0CD4
     9aa:	50 91 d5 0c 	lds	r21, 0x0CD5
     9ae:	60 91 d6 0c 	lds	r22, 0x0CD6
     9b2:	70 91 d7 0c 	lds	r23, 0x0CD7
     9b6:	00 91 d8 0c 	lds	r16, 0x0CD8
     9ba:	10 91 d9 0c 	lds	r17, 0x0CD9
     9be:	20 91 da 0c 	lds	r18, 0x0CDA
     9c2:	30 91 db 0c 	lds	r19, 0x0CDB
     9c6:	ef 2f       	mov	r30, r31
     9c8:	48 17       	cp	r20, r24
     9ca:	59 07       	cpc	r21, r25
     9cc:	6a 07       	cpc	r22, r26
     9ce:	7b 07       	cpc	r23, r27
     9d0:	08 f4       	brcc	.+2      	; 0x9d4 <angle_rotate+0x7a>
     9d2:	ec 2f       	mov	r30, r28
     9d4:	ee 23       	and	r30, r30
     9d6:	49 f4       	brne	.+18     	; 0x9ea <angle_rotate+0x90>
     9d8:	4f 2f       	mov	r20, r31
     9da:	08 17       	cp	r16, r24
     9dc:	19 07       	cpc	r17, r25
     9de:	2a 07       	cpc	r18, r26
     9e0:	3b 07       	cpc	r19, r27
     9e2:	08 f4       	brcc	.+2      	; 0x9e6 <angle_rotate+0x8c>
     9e4:	4c 2f       	mov	r20, r28
     9e6:	44 23       	and	r20, r20
     9e8:	f1 f2       	breq	.-68     	; 0x9a6 <angle_rotate+0x4c>
		break;
		
	}
	stop(); //Stop robot
     9ea:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <stop>
}
     9ee:	cf 91       	pop	r28
     9f0:	1f 91       	pop	r17
     9f2:	0f 91       	pop	r16
     9f4:	08 95       	ret

000009f6 <left_degrees>:

//Function used for moving robot forward by specified distance


void left_degrees(unsigned int Degrees)
{
     9f6:	cf 93       	push	r28
     9f8:	df 93       	push	r29
     9fa:	ec 01       	movw	r28, r24
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	velocity(255,255);
     9fc:	8f ef       	ldi	r24, 0xFF	; 255
     9fe:	6f ef       	ldi	r22, 0xFF	; 255
     a00:	0e 94 da 03 	call	0x7b4	; 0x7b4 <velocity>
	left(); //Turn left
     a04:	0e 94 42 04 	call	0x884	; 0x884 <left>
	angle_rotate(Degrees);
     a08:	ce 01       	movw	r24, r28
     a0a:	0e 94 ad 04 	call	0x95a	; 0x95a <angle_rotate>
}
     a0e:	df 91       	pop	r29
     a10:	cf 91       	pop	r28
     a12:	08 95       	ret

00000a14 <right_degrees>:

void right_degrees(unsigned int Degrees)
{
     a14:	cf 93       	push	r28
     a16:	df 93       	push	r29
     a18:	ec 01       	movw	r28, r24
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	velocity(255,255);
     a1a:	8f ef       	ldi	r24, 0xFF	; 255
     a1c:	6f ef       	ldi	r22, 0xFF	; 255
     a1e:	0e 94 da 03 	call	0x7b4	; 0x7b4 <velocity>
	right(); //Turn right
     a22:	0e 94 46 04 	call	0x88c	; 0x88c <right>
	angle_rotate(Degrees);
     a26:	ce 01       	movw	r24, r28
     a28:	0e 94 ad 04 	call	0x95a	; 0x95a <angle_rotate>
}
     a2c:	df 91       	pop	r29
     a2e:	cf 91       	pop	r28
     a30:	08 95       	ret

00000a32 <soft_left_degrees>:

void soft_left_degrees(unsigned int Degrees)
{
     a32:	cf 93       	push	r28
     a34:	df 93       	push	r29
     a36:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_left(); //Turn soft left
     a38:	0e 94 4a 04 	call	0x894	; 0x894 <soft_left>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
     a3c:	ce 01       	movw	r24, r28
     a3e:	88 0f       	add	r24, r24
     a40:	99 1f       	adc	r25, r25
     a42:	0e 94 ad 04 	call	0x95a	; 0x95a <angle_rotate>
}
     a46:	df 91       	pop	r29
     a48:	cf 91       	pop	r28
     a4a:	08 95       	ret

00000a4c <soft_right_degrees>:

void soft_right_degrees(unsigned int Degrees)
{
     a4c:	cf 93       	push	r28
     a4e:	df 93       	push	r29
     a50:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_right();  //Turn soft right
     a52:	0e 94 4e 04 	call	0x89c	; 0x89c <soft_right>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
     a56:	ce 01       	movw	r24, r28
     a58:	88 0f       	add	r24, r24
     a5a:	99 1f       	adc	r25, r25
     a5c:	0e 94 ad 04 	call	0x95a	; 0x95a <angle_rotate>
}
     a60:	df 91       	pop	r29
     a62:	cf 91       	pop	r28
     a64:	08 95       	ret

00000a66 <soft_left_2_degrees>:

void soft_left_2_degrees(unsigned int Degrees)
{
     a66:	cf 93       	push	r28
     a68:	df 93       	push	r29
     a6a:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_left_2(); //Turn reverse soft left
     a6c:	0e 94 52 04 	call	0x8a4	; 0x8a4 <soft_left_2>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
     a70:	ce 01       	movw	r24, r28
     a72:	88 0f       	add	r24, r24
     a74:	99 1f       	adc	r25, r25
     a76:	0e 94 ad 04 	call	0x95a	; 0x95a <angle_rotate>
}
     a7a:	df 91       	pop	r29
     a7c:	cf 91       	pop	r28
     a7e:	08 95       	ret

00000a80 <soft_right_2_degrees>:

void soft_right_2_degrees(unsigned int Degrees)
{
     a80:	cf 93       	push	r28
     a82:	df 93       	push	r29
     a84:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_right_2();  //Turn reverse soft right
     a86:	0e 94 56 04 	call	0x8ac	; 0x8ac <soft_right_2>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
     a8a:	ce 01       	movw	r24, r28
     a8c:	88 0f       	add	r24, r24
     a8e:	99 1f       	adc	r25, r25
     a90:	0e 94 ad 04 	call	0x95a	; 0x95a <angle_rotate>
}
     a94:	df 91       	pop	r29
     a96:	cf 91       	pop	r28
     a98:	08 95       	ret

00000a9a <path_mm>:

void path_mm (unsigned long int distance)		//Line following cowering a specified linear distance in mm
{
     a9a:	8f 92       	push	r8
     a9c:	9f 92       	push	r9
     a9e:	af 92       	push	r10
     aa0:	bf 92       	push	r11
     aa2:	cf 92       	push	r12
     aa4:	df 92       	push	r13
     aa6:	ef 92       	push	r14
     aa8:	ff 92       	push	r15
     aaa:	cf 93       	push	r28
     aac:	df 93       	push	r29
     aae:	4b 01       	movw	r8, r22
     ab0:	5c 01       	movw	r10, r24
	unsigned char Left_white_line,Center_white_line,Right_white_line;
	unsigned long int dec=distance;
	ShaftCountRight=0;
     ab2:	10 92 d4 0c 	sts	0x0CD4, r1
     ab6:	10 92 d5 0c 	sts	0x0CD5, r1
     aba:	10 92 d6 0c 	sts	0x0CD6, r1
     abe:	10 92 d7 0c 	sts	0x0CD7, r1

	forward();
     ac2:	0e 94 2f 04 	call	0x85e	; 0x85e <forward>
	while((ShaftCountRight * 5.333)<dec)
     ac6:	25 c0       	rjmp	.+74     	; 0xb12 <path_mm+0x78>
	{
		Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
     ac8:	83 e0       	ldi	r24, 0x03	; 3
     aca:	0e 94 10 03 	call	0x620	; 0x620 <ADC_Conversion>
     ace:	d8 2f       	mov	r29, r24
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
     ad0:	82 e0       	ldi	r24, 0x02	; 2
     ad2:	0e 94 10 03 	call	0x620	; 0x620 <ADC_Conversion>
     ad6:	c8 2f       	mov	r28, r24
		Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor
     ad8:	81 e0       	ldi	r24, 0x01	; 1
     ada:	0e 94 10 03 	call	0x620	; 0x620 <ADC_Conversion>
		
		if(Center_white_line > 12 )
     ade:	cd 30       	cpi	r28, 0x0D	; 13
     ae0:	38 f0       	brcs	.+14     	; 0xaf0 <path_mm+0x56>
		{
			forward();
     ae2:	0e 94 2f 04 	call	0x85e	; 0x85e <forward>
			velocity(255,255);
     ae6:	8f ef       	ldi	r24, 0xFF	; 255
     ae8:	6f ef       	ldi	r22, 0xFF	; 255
     aea:	0e 94 da 03 	call	0x7b4	; 0x7b4 <velocity>
     aee:	11 c0       	rjmp	.+34     	; 0xb12 <path_mm+0x78>
		}
		else if(Left_white_line > 12)
     af0:	dd 30       	cpi	r29, 0x0D	; 13
     af2:	38 f0       	brcs	.+14     	; 0xb02 <path_mm+0x68>
		{
			forward();
     af4:	0e 94 2f 04 	call	0x85e	; 0x85e <forward>
			velocity(100,255);
     af8:	84 e6       	ldi	r24, 0x64	; 100
     afa:	6f ef       	ldi	r22, 0xFF	; 255
     afc:	0e 94 da 03 	call	0x7b4	; 0x7b4 <velocity>
     b00:	08 c0       	rjmp	.+16     	; 0xb12 <path_mm+0x78>
		}
		else if(Right_white_line > 12)
     b02:	8d 30       	cpi	r24, 0x0D	; 13
     b04:	30 f0       	brcs	.+12     	; 0xb12 <path_mm+0x78>
		{
			forward();
     b06:	0e 94 2f 04 	call	0x85e	; 0x85e <forward>
			velocity(255,100);
     b0a:	8f ef       	ldi	r24, 0xFF	; 255
     b0c:	64 e6       	ldi	r22, 0x64	; 100
     b0e:	0e 94 da 03 	call	0x7b4	; 0x7b4 <velocity>
	unsigned char Left_white_line,Center_white_line,Right_white_line;
	unsigned long int dec=distance;
	ShaftCountRight=0;

	forward();
	while((ShaftCountRight * 5.333)<dec)
     b12:	60 91 d4 0c 	lds	r22, 0x0CD4
     b16:	70 91 d5 0c 	lds	r23, 0x0CD5
     b1a:	80 91 d6 0c 	lds	r24, 0x0CD6
     b1e:	90 91 d7 0c 	lds	r25, 0x0CD7
     b22:	0e 94 75 1b 	call	0x36ea	; 0x36ea <__floatunsisf>
     b26:	20 ef       	ldi	r18, 0xF0	; 240
     b28:	37 ea       	ldi	r19, 0xA7	; 167
     b2a:	4a ea       	ldi	r20, 0xAA	; 170
     b2c:	50 e4       	ldi	r21, 0x40	; 64
     b2e:	0e 94 27 1c 	call	0x384e	; 0x384e <__mulsf3>
     b32:	6b 01       	movw	r12, r22
     b34:	7c 01       	movw	r14, r24
     b36:	c5 01       	movw	r24, r10
     b38:	b4 01       	movw	r22, r8
     b3a:	0e 94 75 1b 	call	0x36ea	; 0x36ea <__floatunsisf>
     b3e:	9b 01       	movw	r18, r22
     b40:	ac 01       	movw	r20, r24
     b42:	c7 01       	movw	r24, r14
     b44:	b6 01       	movw	r22, r12
     b46:	0e 94 d8 1a 	call	0x35b0	; 0x35b0 <__cmpsf2>
     b4a:	88 23       	and	r24, r24
     b4c:	0c f4       	brge	.+2      	; 0xb50 <path_mm+0xb6>
     b4e:	bc cf       	rjmp	.-136    	; 0xac8 <path_mm+0x2e>
			forward();
			velocity(255,100);
		}
		
	}
	stop();
     b50:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <stop>
     b54:	8f ef       	ldi	r24, 0xFF	; 255
     b56:	9f e7       	ldi	r25, 0x7F	; 127
     b58:	a4 e0       	ldi	r26, 0x04	; 4
     b5a:	81 50       	subi	r24, 0x01	; 1
     b5c:	90 40       	sbci	r25, 0x00	; 0
     b5e:	a0 40       	sbci	r26, 0x00	; 0
     b60:	e1 f7       	brne	.-8      	; 0xb5a <path_mm+0xc0>
     b62:	00 c0       	rjmp	.+0      	; 0xb64 <path_mm+0xca>
     b64:	00 00       	nop
	_delay_ms(100);
}
     b66:	df 91       	pop	r29
     b68:	cf 91       	pop	r28
     b6a:	ff 90       	pop	r15
     b6c:	ef 90       	pop	r14
     b6e:	df 90       	pop	r13
     b70:	cf 90       	pop	r12
     b72:	bf 90       	pop	r11
     b74:	af 90       	pop	r10
     b76:	9f 90       	pop	r9
     b78:	8f 90       	pop	r8
     b7a:	08 95       	ret

00000b7c <path_node>:
	_delay_ms(100);
}


void path_node (int n)			//Line following cowering a specified number of nodes
{
     b7c:	ef 92       	push	r14
     b7e:	ff 92       	push	r15
     b80:	1f 93       	push	r17
     b82:	cf 93       	push	r28
     b84:	df 93       	push	r29
     b86:	7c 01       	movw	r14, r24
	unsigned char Left_white_line,Center_white_line,Right_white_line,count = 0;
	
	forward();
     b88:	0e 94 2f 04 	call	0x85e	; 0x85e <forward>
	velocity(255,255);
     b8c:	8f ef       	ldi	r24, 0xFF	; 255
     b8e:	6f ef       	ldi	r22, 0xFF	; 255
     b90:	0e 94 da 03 	call	0x7b4	; 0x7b4 <velocity>
}


void path_node (int n)			//Line following cowering a specified number of nodes
{
	unsigned char Left_white_line,Center_white_line,Right_white_line,count = 0;
     b94:	d0 e0       	ldi	r29, 0x00	; 0
	
	forward();
	velocity(255,255);

	while(count < n)
     b96:	37 c0       	rjmp	.+110    	; 0xc06 <path_node+0x8a>
	{
		Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
     b98:	83 e0       	ldi	r24, 0x03	; 3
     b9a:	0e 94 10 03 	call	0x620	; 0x620 <ADC_Conversion>
     b9e:	18 2f       	mov	r17, r24
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
     ba0:	82 e0       	ldi	r24, 0x02	; 2
     ba2:	0e 94 10 03 	call	0x620	; 0x620 <ADC_Conversion>
     ba6:	c8 2f       	mov	r28, r24
		Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor
     ba8:	81 e0       	ldi	r24, 0x01	; 1
     baa:	0e 94 10 03 	call	0x620	; 0x620 <ADC_Conversion>
		
		if(((Center_white_line>12 && Left_white_line>12) ||(Center_white_line>12 && Right_white_line>12)))// Node Detection
     bae:	cd 30       	cpi	r28, 0x0D	; 13
     bb0:	c8 f0       	brcs	.+50     	; 0xbe4 <path_node+0x68>
     bb2:	1d 30       	cpi	r17, 0x0D	; 13
     bb4:	10 f4       	brcc	.+4      	; 0xbba <path_node+0x3e>
     bb6:	8d 30       	cpi	r24, 0x0D	; 13
     bb8:	70 f0       	brcs	.+28     	; 0xbd6 <path_node+0x5a>
		{
			
			count++;
     bba:	df 5f       	subi	r29, 0xFF	; 255
			path_mm(90);
     bbc:	6a e5       	ldi	r22, 0x5A	; 90
     bbe:	70 e0       	ldi	r23, 0x00	; 0
     bc0:	80 e0       	ldi	r24, 0x00	; 0
     bc2:	90 e0       	ldi	r25, 0x00	; 0
     bc4:	0e 94 4d 05 	call	0xa9a	; 0xa9a <path_mm>
			forward();
     bc8:	0e 94 2f 04 	call	0x85e	; 0x85e <forward>
			velocity(255,255);
     bcc:	8f ef       	ldi	r24, 0xFF	; 255
     bce:	6f ef       	ldi	r22, 0xFF	; 255
     bd0:	0e 94 da 03 	call	0x7b4	; 0x7b4 <velocity>
     bd4:	18 c0       	rjmp	.+48     	; 0xc06 <path_node+0x8a>
		}
		else
		{
			if(Center_white_line > 12 )
			{
				velocity(255,255);
     bd6:	8f ef       	ldi	r24, 0xFF	; 255
     bd8:	6f ef       	ldi	r22, 0xFF	; 255
     bda:	0e 94 da 03 	call	0x7b4	; 0x7b4 <velocity>
				forward();
     bde:	0e 94 2f 04 	call	0x85e	; 0x85e <forward>
     be2:	11 c0       	rjmp	.+34     	; 0xc06 <path_node+0x8a>
			}
			else if(Left_white_line > 12)
     be4:	1d 30       	cpi	r17, 0x0D	; 13
     be6:	38 f0       	brcs	.+14     	; 0xbf6 <path_node+0x7a>
			{
				velocity(100,255);
     be8:	84 e6       	ldi	r24, 0x64	; 100
     bea:	6f ef       	ldi	r22, 0xFF	; 255
     bec:	0e 94 da 03 	call	0x7b4	; 0x7b4 <velocity>
				forward();
     bf0:	0e 94 2f 04 	call	0x85e	; 0x85e <forward>
     bf4:	08 c0       	rjmp	.+16     	; 0xc06 <path_node+0x8a>
			}
			else if(Right_white_line > 12)
     bf6:	8d 30       	cpi	r24, 0x0D	; 13
     bf8:	30 f0       	brcs	.+12     	; 0xc06 <path_node+0x8a>
			{
				velocity(255,100);
     bfa:	8f ef       	ldi	r24, 0xFF	; 255
     bfc:	64 e6       	ldi	r22, 0x64	; 100
     bfe:	0e 94 da 03 	call	0x7b4	; 0x7b4 <velocity>
				forward();
     c02:	0e 94 2f 04 	call	0x85e	; 0x85e <forward>
	unsigned char Left_white_line,Center_white_line,Right_white_line,count = 0;
	
	forward();
	velocity(255,255);

	while(count < n)
     c06:	8d 2f       	mov	r24, r29
     c08:	90 e0       	ldi	r25, 0x00	; 0
     c0a:	8e 15       	cp	r24, r14
     c0c:	9f 05       	cpc	r25, r15
     c0e:	24 f2       	brlt	.-120    	; 0xb98 <path_node+0x1c>
				forward();
			}
		}
	}
	
	stop();
     c10:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <stop>
     c14:	8f ef       	ldi	r24, 0xFF	; 255
     c16:	9f e7       	ldi	r25, 0x7F	; 127
     c18:	a4 e0       	ldi	r26, 0x04	; 4
     c1a:	81 50       	subi	r24, 0x01	; 1
     c1c:	90 40       	sbci	r25, 0x00	; 0
     c1e:	a0 40       	sbci	r26, 0x00	; 0
     c20:	e1 f7       	brne	.-8      	; 0xc1a <path_node+0x9e>
     c22:	00 c0       	rjmp	.+0      	; 0xc24 <path_node+0xa8>
     c24:	00 00       	nop
	_delay_ms(100);
}
     c26:	df 91       	pop	r29
     c28:	cf 91       	pop	r28
     c2a:	1f 91       	pop	r17
     c2c:	ff 90       	pop	r15
     c2e:	ef 90       	pop	r14
     c30:	08 95       	ret

00000c32 <rotate_right>:

void rotate_right(int Deg)		// Rotate right with finding the black line
{
     c32:	cf 93       	push	r28
     c34:	df 93       	push	r29
     c36:	ec 01       	movw	r28, r24
	velocity(250,250);
     c38:	8a ef       	ldi	r24, 0xFA	; 250
     c3a:	6a ef       	ldi	r22, 0xFA	; 250
     c3c:	0e 94 da 03 	call	0x7b4	; 0x7b4 <velocity>
	right_degrees(Deg-20);
     c40:	ce 01       	movw	r24, r28
     c42:	44 97       	sbiw	r24, 0x14	; 20
     c44:	0e 94 0a 05 	call	0xa14	; 0xa14 <right_degrees>
	
	char i=3;
	while(ADC_Conversion(2)<12)// to detect balck line
     c48:	04 c0       	rjmp	.+8      	; 0xc52 <rotate_right+0x20>
	{
		right_degrees(i); 
     c4a:	83 e0       	ldi	r24, 0x03	; 3
     c4c:	90 e0       	ldi	r25, 0x00	; 0
     c4e:	0e 94 0a 05 	call	0xa14	; 0xa14 <right_degrees>
{
	velocity(250,250);
	right_degrees(Deg-20);
	
	char i=3;
	while(ADC_Conversion(2)<12)// to detect balck line
     c52:	82 e0       	ldi	r24, 0x02	; 2
     c54:	0e 94 10 03 	call	0x620	; 0x620 <ADC_Conversion>
     c58:	8c 30       	cpi	r24, 0x0C	; 12
     c5a:	b8 f3       	brcs	.-18     	; 0xc4a <rotate_right+0x18>
	{
		right_degrees(i); 
	}
	stop();
     c5c:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <stop>
     c60:	8f ef       	ldi	r24, 0xFF	; 255
     c62:	9f e3       	ldi	r25, 0x3F	; 63
     c64:	a2 e0       	ldi	r26, 0x02	; 2
     c66:	81 50       	subi	r24, 0x01	; 1
     c68:	90 40       	sbci	r25, 0x00	; 0
     c6a:	a0 40       	sbci	r26, 0x00	; 0
     c6c:	e1 f7       	brne	.-8      	; 0xc66 <rotate_right+0x34>
     c6e:	00 c0       	rjmp	.+0      	; 0xc70 <rotate_right+0x3e>
     c70:	00 00       	nop
	_delay_ms(50);
}
     c72:	df 91       	pop	r29
     c74:	cf 91       	pop	r28
     c76:	08 95       	ret

00000c78 <rotate_left>:

void rotate_left(int Deg)		// Rotate right with finding the black line
{
     c78:	cf 93       	push	r28
     c7a:	df 93       	push	r29
     c7c:	ec 01       	movw	r28, r24
	velocity(250,250);
     c7e:	8a ef       	ldi	r24, 0xFA	; 250
     c80:	6a ef       	ldi	r22, 0xFA	; 250
     c82:	0e 94 da 03 	call	0x7b4	; 0x7b4 <velocity>
	left_degrees(Deg-20);	
     c86:	ce 01       	movw	r24, r28
     c88:	44 97       	sbiw	r24, 0x14	; 20
     c8a:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <left_degrees>
	
	char i=3;
	while(ADC_Conversion(2)<12)	// to detect balck line
     c8e:	04 c0       	rjmp	.+8      	; 0xc98 <rotate_left+0x20>
	{
		left_degrees(i);
     c90:	83 e0       	ldi	r24, 0x03	; 3
     c92:	90 e0       	ldi	r25, 0x00	; 0
     c94:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <left_degrees>
{
	velocity(250,250);
	left_degrees(Deg-20);	
	
	char i=3;
	while(ADC_Conversion(2)<12)	// to detect balck line
     c98:	82 e0       	ldi	r24, 0x02	; 2
     c9a:	0e 94 10 03 	call	0x620	; 0x620 <ADC_Conversion>
     c9e:	8c 30       	cpi	r24, 0x0C	; 12
     ca0:	b8 f3       	brcs	.-18     	; 0xc90 <rotate_left+0x18>
	{
		left_degrees(i);
	}
	stop();
     ca2:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <stop>
     ca6:	8f ef       	ldi	r24, 0xFF	; 255
     ca8:	9f e3       	ldi	r25, 0x3F	; 63
     caa:	a2 e0       	ldi	r26, 0x02	; 2
     cac:	81 50       	subi	r24, 0x01	; 1
     cae:	90 40       	sbci	r25, 0x00	; 0
     cb0:	a0 40       	sbci	r26, 0x00	; 0
     cb2:	e1 f7       	brne	.-8      	; 0xcac <rotate_left+0x34>
     cb4:	00 c0       	rjmp	.+0      	; 0xcb6 <rotate_left+0x3e>
     cb6:	00 00       	nop
	_delay_ms(50);
}
     cb8:	df 91       	pop	r29
     cba:	cf 91       	pop	r28
     cbc:	08 95       	ret

00000cbe <buzzer_pin_config>:
#ifndef BUZZER_H
#define BUZZER_H

void buzzer_pin_config (void)
{
 DDRC = DDRC | 0x08;		//Setting PORTC 3 as output
     cbe:	3b 9a       	sbi	0x07, 3	; 7
 PORTC = PORTC & 0xF7;		//Setting PORTC 3 logic low to turnoff buzzer
     cc0:	43 98       	cbi	0x08, 3	; 8
}
     cc2:	08 95       	ret

00000cc4 <buzzer_on>:

void buzzer_on (void)
{
 unsigned char port_restore = 0;
 port_restore = PINC;
     cc4:	86 b1       	in	r24, 0x06	; 6
 port_restore = port_restore | 0x08;
     cc6:	88 60       	ori	r24, 0x08	; 8
 PORTC = port_restore;
     cc8:	88 b9       	out	0x08, r24	; 8
}
     cca:	08 95       	ret

00000ccc <buzzer_off>:

void buzzer_off (void)
{
 unsigned char port_restore = 0;
 port_restore = PINC;
     ccc:	86 b1       	in	r24, 0x06	; 6
 port_restore = port_restore & 0xF7;
     cce:	87 7f       	andi	r24, 0xF7	; 247
 PORTC = port_restore;
     cd0:	88 b9       	out	0x08, r24	; 8
}
     cd2:	08 95       	ret

00000cd4 <buzzer>:

void buzzer(int sec)	// To turn on buzzer for specified number of seconds
{
     cd4:	cf 93       	push	r28
     cd6:	df 93       	push	r29
     cd8:	ec 01       	movw	r28, r24
	buzzer_on();
     cda:	0e 94 62 06 	call	0xcc4	; 0xcc4 <buzzer_on>
	for(int i=0;i<sec;i++)
     cde:	1c 16       	cp	r1, r28
     ce0:	1d 06       	cpc	r1, r29
     ce2:	7c f4       	brge	.+30     	; 0xd02 <buzzer+0x2e>
     ce4:	80 e0       	ldi	r24, 0x00	; 0
     ce6:	90 e0       	ldi	r25, 0x00	; 0
     ce8:	2f ef       	ldi	r18, 0xFF	; 255
     cea:	3f ef       	ldi	r19, 0xFF	; 255
     cec:	4c e2       	ldi	r20, 0x2C	; 44
     cee:	21 50       	subi	r18, 0x01	; 1
     cf0:	30 40       	sbci	r19, 0x00	; 0
     cf2:	40 40       	sbci	r20, 0x00	; 0
     cf4:	e1 f7       	brne	.-8      	; 0xcee <buzzer+0x1a>
     cf6:	00 c0       	rjmp	.+0      	; 0xcf8 <buzzer+0x24>
     cf8:	00 00       	nop
     cfa:	01 96       	adiw	r24, 0x01	; 1
     cfc:	8c 17       	cp	r24, r28
     cfe:	9d 07       	cpc	r25, r29
     d00:	99 f7       	brne	.-26     	; 0xce8 <buzzer+0x14>
		_delay_ms(1000);
	buzzer_off();
     d02:	0e 94 66 06 	call	0xccc	; 0xccc <buzzer_off>
	//_delay_ms(500);
}
     d06:	df 91       	pop	r29
     d08:	cf 91       	pop	r28
     d0a:	08 95       	ret

00000d0c <servo1_pin_config>:
int c_degrees=0;
int first_aid_kit_cnt=0;
//Configure PORTB 5 pin for servo motor 1 operation
void servo1_pin_config (void)
{
 DDRB  = DDRB | 0x20;  //making PORTB 5 pin output
     d0c:	25 9a       	sbi	0x04, 5	; 4
 PORTB = PORTB | 0x20; //setting PORTB 5 pin to logic 1
     d0e:	2d 9a       	sbi	0x05, 5	; 5
}
     d10:	08 95       	ret

00000d12 <servo_init>:

//Initialize the ports
void servo_init(void)
{
	servo1_pin_config(); //Configure PORTB 5 pin for servo motor 1 operation
     d12:	0e 94 86 06 	call	0xd0c	; 0xd0c <servo1_pin_config>
	timer1_init();
     d16:	0e 94 d6 00 	call	0x1ac	; 0x1ac <timer1_init>
	servo_1(0);
     d1a:	80 e0       	ldi	r24, 0x00	; 0
     d1c:	90 e0       	ldi	r25, 0x00	; 0
     d1e:	0e 94 f9 00 	call	0x1f2	; 0x1f2 <servo_1>
}
     d22:	08 95       	ret

00000d24 <servo_1_free>:
//and make them free by giving 100% duty cycle at the PWM. This function can be used to 
//reduce the power consumption of the motor if it is holding load against the gravity.

void servo_1_free (void) //makes servo 1 free rotating
{
 OCR1AH = 0x03; 
     d24:	83 e0       	ldi	r24, 0x03	; 3
     d26:	80 93 89 00 	sts	0x0089, r24
 OCR1AL = 0xFF; //Servo 1 off
     d2a:	8f ef       	ldi	r24, 0xFF	; 255
     d2c:	80 93 88 00 	sts	0x0088, r24
}
     d30:	08 95       	ret

00000d32 <servo>:

void servo(int degrees)
{
     d32:	0f 93       	push	r16
     d34:	1f 93       	push	r17
     d36:	cf 93       	push	r28
     d38:	df 93       	push	r29
     d3a:	8c 01       	movw	r16, r24
	int i;
	if(degrees > c_degrees)
     d3c:	c0 91 d0 0c 	lds	r28, 0x0CD0
     d40:	d0 91 d1 0c 	lds	r29, 0x0CD1
     d44:	c8 17       	cp	r28, r24
     d46:	d9 07       	cpc	r29, r25
     d48:	24 f0       	brlt	.+8      	; 0xd52 <servo+0x20>
			servo_1(i);
			_delay_ms(5);
			c_degrees=i;
		}
	else
		for (i = c_degrees; i > degrees; i--)
     d4a:	8c 17       	cp	r24, r28
     d4c:	9d 07       	cpc	r25, r29
     d4e:	9c f0       	brlt	.+38     	; 0xd76 <servo+0x44>
     d50:	23 c0       	rjmp	.+70     	; 0xd98 <servo+0x66>
{
	int i;
	if(degrees > c_degrees)
		for (i = c_degrees; i <degrees; i++)
		{
			servo_1(i);
     d52:	8c 2f       	mov	r24, r28
     d54:	0e 94 f9 00 	call	0x1f2	; 0x1f2 <servo_1>
     d58:	8f ef       	ldi	r24, 0xFF	; 255
     d5a:	97 e4       	ldi	r25, 0x47	; 71
     d5c:	01 97       	sbiw	r24, 0x01	; 1
     d5e:	f1 f7       	brne	.-4      	; 0xd5c <servo+0x2a>
     d60:	00 c0       	rjmp	.+0      	; 0xd62 <servo+0x30>
     d62:	00 00       	nop
			_delay_ms(5);
			c_degrees=i;
     d64:	d0 93 d1 0c 	sts	0x0CD1, r29
     d68:	c0 93 d0 0c 	sts	0x0CD0, r28

void servo(int degrees)
{
	int i;
	if(degrees > c_degrees)
		for (i = c_degrees; i <degrees; i++)
     d6c:	21 96       	adiw	r28, 0x01	; 1
     d6e:	c0 17       	cp	r28, r16
     d70:	d1 07       	cpc	r29, r17
     d72:	7c f3       	brlt	.-34     	; 0xd52 <servo+0x20>
     d74:	11 c0       	rjmp	.+34     	; 0xd98 <servo+0x66>
			c_degrees=i;
		}
	else
		for (i = c_degrees; i > degrees; i--)
		{
			servo_1(i);
     d76:	8c 2f       	mov	r24, r28
     d78:	0e 94 f9 00 	call	0x1f2	; 0x1f2 <servo_1>
     d7c:	8f ef       	ldi	r24, 0xFF	; 255
     d7e:	97 e4       	ldi	r25, 0x47	; 71
     d80:	01 97       	sbiw	r24, 0x01	; 1
     d82:	f1 f7       	brne	.-4      	; 0xd80 <servo+0x4e>
     d84:	00 c0       	rjmp	.+0      	; 0xd86 <servo+0x54>
     d86:	00 00       	nop
			_delay_ms(5);
			c_degrees=i;
     d88:	d0 93 d1 0c 	sts	0x0CD1, r29
     d8c:	c0 93 d0 0c 	sts	0x0CD0, r28
			servo_1(i);
			_delay_ms(5);
			c_degrees=i;
		}
	else
		for (i = c_degrees; i > degrees; i--)
     d90:	21 97       	sbiw	r28, 0x01	; 1
     d92:	0c 17       	cp	r16, r28
     d94:	1d 07       	cpc	r17, r29
     d96:	7c f3       	brlt	.-34     	; 0xd76 <servo+0x44>
		{
			servo_1(i);
			_delay_ms(5);
			c_degrees=i;
		}	
}
     d98:	df 91       	pop	r29
     d9a:	cf 91       	pop	r28
     d9c:	1f 91       	pop	r17
     d9e:	0f 91       	pop	r16
     da0:	08 95       	ret

00000da2 <first_aid_kit_deposit>:

void first_aid_kit_deposit()
{
	first_aid_kit_cnt++;
     da2:	80 91 ce 0c 	lds	r24, 0x0CCE
     da6:	90 91 cf 0c 	lds	r25, 0x0CCF
     daa:	01 96       	adiw	r24, 0x01	; 1
     dac:	90 93 cf 0c 	sts	0x0CCF, r25
     db0:	80 93 ce 0c 	sts	0x0CCE, r24
	switch(first_aid_kit_cnt)
     db4:	83 30       	cpi	r24, 0x03	; 3
     db6:	91 05       	cpc	r25, r1
     db8:	d9 f0       	breq	.+54     	; 0xdf0 <first_aid_kit_deposit+0x4e>
     dba:	84 30       	cpi	r24, 0x04	; 4
     dbc:	91 05       	cpc	r25, r1
     dbe:	3c f4       	brge	.+14     	; 0xdce <first_aid_kit_deposit+0x2c>
     dc0:	81 30       	cpi	r24, 0x01	; 1
     dc2:	91 05       	cpc	r25, r1
     dc4:	59 f0       	breq	.+22     	; 0xddc <first_aid_kit_deposit+0x3a>
     dc6:	82 30       	cpi	r24, 0x02	; 2
     dc8:	91 05       	cpc	r25, r1
     dca:	01 f5       	brne	.+64     	; 0xe0c <first_aid_kit_deposit+0x6a>
     dcc:	0c c0       	rjmp	.+24     	; 0xde6 <first_aid_kit_deposit+0x44>
     dce:	84 30       	cpi	r24, 0x04	; 4
     dd0:	91 05       	cpc	r25, r1
     dd2:	99 f0       	breq	.+38     	; 0xdfa <first_aid_kit_deposit+0x58>
     dd4:	85 30       	cpi	r24, 0x05	; 5
     dd6:	91 05       	cpc	r25, r1
     dd8:	c9 f4       	brne	.+50     	; 0xe0c <first_aid_kit_deposit+0x6a>
     dda:	14 c0       	rjmp	.+40     	; 0xe04 <first_aid_kit_deposit+0x62>
	{
		case 1:	servo(32);
     ddc:	80 e2       	ldi	r24, 0x20	; 32
     dde:	90 e0       	ldi	r25, 0x00	; 0
     de0:	0e 94 99 06 	call	0xd32	; 0xd32 <servo>
				break;
     de4:	13 c0       	rjmp	.+38     	; 0xe0c <first_aid_kit_deposit+0x6a>
		case 2:	servo(70);
     de6:	86 e4       	ldi	r24, 0x46	; 70
     de8:	90 e0       	ldi	r25, 0x00	; 0
     dea:	0e 94 99 06 	call	0xd32	; 0xd32 <servo>
				break;
     dee:	0e c0       	rjmp	.+28     	; 0xe0c <first_aid_kit_deposit+0x6a>
		case 3:	servo(108);
     df0:	8c e6       	ldi	r24, 0x6C	; 108
     df2:	90 e0       	ldi	r25, 0x00	; 0
     df4:	0e 94 99 06 	call	0xd32	; 0xd32 <servo>
				break;
     df8:	09 c0       	rjmp	.+18     	; 0xe0c <first_aid_kit_deposit+0x6a>
		case 4:	servo(144);
     dfa:	80 e9       	ldi	r24, 0x90	; 144
     dfc:	90 e0       	ldi	r25, 0x00	; 0
     dfe:	0e 94 99 06 	call	0xd32	; 0xd32 <servo>
				break;		
     e02:	04 c0       	rjmp	.+8      	; 0xe0c <first_aid_kit_deposit+0x6a>
		case 5:	servo(180);
     e04:	84 eb       	ldi	r24, 0xB4	; 180
     e06:	90 e0       	ldi	r25, 0x00	; 0
     e08:	0e 94 99 06 	call	0xd32	; 0xd32 <servo>
				break;
		default:break;		
	}
	servo_1_free();
     e0c:	0e 94 92 06 	call	0xd24	; 0xd24 <servo_1_free>
     e10:	8f ef       	ldi	r24, 0xFF	; 255
     e12:	9f e7       	ldi	r25, 0x7F	; 127
     e14:	a4 e0       	ldi	r26, 0x04	; 4
     e16:	81 50       	subi	r24, 0x01	; 1
     e18:	90 40       	sbci	r25, 0x00	; 0
     e1a:	a0 40       	sbci	r26, 0x00	; 0
     e1c:	e1 f7       	brne	.-8      	; 0xe16 <first_aid_kit_deposit+0x74>
     e1e:	00 c0       	rjmp	.+0      	; 0xe20 <first_aid_kit_deposit+0x7e>
     e20:	00 00       	nop
	_delay_ms(100);
}
     e22:	08 95       	ret

00000e24 <color_sensor_pin_config>:
volatile unsigned long int no_ff;     // variable to store the pulse count when no_filter function is called


void color_sensor_pin_config(void)
{
	DDRD  = DDRD | 0xFB; //set PD0 as input for color sensor output
     e24:	8a b1       	in	r24, 0x0a	; 10
     e26:	8b 6f       	ori	r24, 0xFB	; 251
     e28:	8a b9       	out	0x0a, r24	; 10
	PORTD = PORTD | 0x04;//Enable internal pull-up for PORTD 0 pin
     e2a:	5a 9a       	sbi	0x0b, 2	; 11
}
     e2c:	08 95       	ret

00000e2e <color_sensor_pin_interrupt_init>:


void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
{
	cli(); //Clears the global interrupt
     e2e:	f8 94       	cli
	EICRA = EICRA | 0x20; // INT2 is set to trigger with falling edge
     e30:	e9 e6       	ldi	r30, 0x69	; 105
     e32:	f0 e0       	ldi	r31, 0x00	; 0
     e34:	80 81       	ld	r24, Z
     e36:	80 62       	ori	r24, 0x20	; 32
     e38:	80 83       	st	Z, r24
	//EIMSK = EIMSK | 0x04; // Enable Interrupt INT2 for color sensor
	sei(); // Enables the global interrupt
     e3a:	78 94       	sei
}
     e3c:	08 95       	ret

00000e3e <__vector_3>:

//ISR for color sensor
ISR(INT2_vect)
{
     e3e:	1f 92       	push	r1
     e40:	0f 92       	push	r0
     e42:	0f b6       	in	r0, 0x3f	; 63
     e44:	0f 92       	push	r0
     e46:	11 24       	eor	r1, r1
     e48:	8f 93       	push	r24
     e4a:	9f 93       	push	r25
     e4c:	af 93       	push	r26
     e4e:	bf 93       	push	r27
	pulse++; //increment on receiving pulse from the color sensor
     e50:	80 91 ca 0c 	lds	r24, 0x0CCA
     e54:	90 91 cb 0c 	lds	r25, 0x0CCB
     e58:	a0 91 cc 0c 	lds	r26, 0x0CCC
     e5c:	b0 91 cd 0c 	lds	r27, 0x0CCD
     e60:	01 96       	adiw	r24, 0x01	; 1
     e62:	a1 1d       	adc	r26, r1
     e64:	b1 1d       	adc	r27, r1
     e66:	80 93 ca 0c 	sts	0x0CCA, r24
     e6a:	90 93 cb 0c 	sts	0x0CCB, r25
     e6e:	a0 93 cc 0c 	sts	0x0CCC, r26
     e72:	b0 93 cd 0c 	sts	0x0CCD, r27
}
     e76:	bf 91       	pop	r27
     e78:	af 91       	pop	r26
     e7a:	9f 91       	pop	r25
     e7c:	8f 91       	pop	r24
     e7e:	0f 90       	pop	r0
     e80:	0f be       	out	0x3f, r0	; 63
     e82:	0f 90       	pop	r0
     e84:	1f 90       	pop	r1
     e86:	18 95       	reti

00000e88 <colour_init>:

void colour_init(void)
{
	color_sensor_pin_config();
     e88:	0e 94 12 07 	call	0xe24	; 0xe24 <color_sensor_pin_config>
	color_sensor_pin_interrupt_init();
     e8c:	0e 94 17 07 	call	0xe2e	; 0xe2e <color_sensor_pin_interrupt_init>
	color_sensor_scaling();
     e90:	0e 94 12 01 	call	0x224	; 0x224 <color_sensor_scaling>
}
     e94:	08 95       	ret

00000e96 <filter_red>:

//Filter Selection
void filter_red(void)    //Used to select red filter
{
	//Filter Select - red filter
	PORTD = PORTD & 0xBF; //set S2 low
     e96:	5e 98       	cbi	0x0b, 6	; 11
	PORTD = PORTD & 0x7F; //set S3 low
     e98:	5f 98       	cbi	0x0b, 7	; 11
}
     e9a:	08 95       	ret

00000e9c <filter_green>:

void filter_green(void)	//Used to select green filter
{
	//Filter Select - green filter
	PORTD = PORTD | 0x40; //set S2 High
     e9c:	5e 9a       	sbi	0x0b, 6	; 11
	PORTD = PORTD | 0x80; //set S3 High
     e9e:	5f 9a       	sbi	0x0b, 7	; 11
}
     ea0:	08 95       	ret

00000ea2 <filter_blue>:

void filter_blue(void)	//Used to select blue filter
{
	//Filter Select - blue filter
	PORTD = PORTD & 0xBF; //set S2 low
     ea2:	5e 98       	cbi	0x0b, 6	; 11
	PORTD = PORTD | 0x80; //set S3 High
     ea4:	5f 9a       	sbi	0x0b, 7	; 11
}
     ea6:	08 95       	ret

00000ea8 <filter_clear>:

void filter_clear(void)	//select no filter
{
	//Filter Select - no filter
	PORTD = PORTD | 0x40; //set S2 High
     ea8:	5e 9a       	sbi	0x0b, 6	; 11
	PORTD = PORTD & 0x7F; //set S3 Low
     eaa:	5f 98       	cbi	0x0b, 7	; 11
}
     eac:	08 95       	ret

00000eae <red_read>:
}

void red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
	//Red
	filter_red(); //select red filter
     eae:	0e 94 4b 07 	call	0xe96	; 0xe96 <filter_red>
	pulse=0; //reset the count to 0
     eb2:	10 92 ca 0c 	sts	0x0CCA, r1
     eb6:	10 92 cb 0c 	sts	0x0CCB, r1
     eba:	10 92 cc 0c 	sts	0x0CCC, r1
     ebe:	10 92 cd 0c 	sts	0x0CCD, r1
     ec2:	8f ef       	ldi	r24, 0xFF	; 255
     ec4:	9f e8       	ldi	r25, 0x8F	; 143
     ec6:	01 97       	sbiw	r24, 0x01	; 1
     ec8:	f1 f7       	brne	.-4      	; 0xec6 <red_read+0x18>
     eca:	00 c0       	rjmp	.+0      	; 0xecc <red_read+0x1e>
     ecc:	00 00       	nop
	_delay_ms(10); //capture the pulses for 100 ms or 0.1 second
	red = pulse;  //store the count in variable called red
     ece:	80 91 ca 0c 	lds	r24, 0x0CCA
     ed2:	90 91 cb 0c 	lds	r25, 0x0CCB
     ed6:	a0 91 cc 0c 	lds	r26, 0x0CCC
     eda:	b0 91 cd 0c 	lds	r27, 0x0CCD
     ede:	80 93 84 17 	sts	0x1784, r24
     ee2:	90 93 85 17 	sts	0x1785, r25
     ee6:	a0 93 86 17 	sts	0x1786, r26
     eea:	b0 93 87 17 	sts	0x1787, r27
	
}
     eee:	08 95       	ret

00000ef0 <green_read>:

void green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
	//Green
	filter_green(); //select green filter
     ef0:	0e 94 4e 07 	call	0xe9c	; 0xe9c <filter_green>
	pulse=0; //reset the count to 0
     ef4:	10 92 ca 0c 	sts	0x0CCA, r1
     ef8:	10 92 cb 0c 	sts	0x0CCB, r1
     efc:	10 92 cc 0c 	sts	0x0CCC, r1
     f00:	10 92 cd 0c 	sts	0x0CCD, r1
     f04:	8f ef       	ldi	r24, 0xFF	; 255
     f06:	9f e8       	ldi	r25, 0x8F	; 143
     f08:	01 97       	sbiw	r24, 0x01	; 1
     f0a:	f1 f7       	brne	.-4      	; 0xf08 <green_read+0x18>
     f0c:	00 c0       	rjmp	.+0      	; 0xf0e <green_read+0x1e>
     f0e:	00 00       	nop
	_delay_ms(10); //capture the pulses for 100 ms or 0.1 second
	green = pulse;  //store the count in variable called green
     f10:	80 91 ca 0c 	lds	r24, 0x0CCA
     f14:	90 91 cb 0c 	lds	r25, 0x0CCB
     f18:	a0 91 cc 0c 	lds	r26, 0x0CCC
     f1c:	b0 91 cd 0c 	lds	r27, 0x0CCD
     f20:	80 93 80 17 	sts	0x1780, r24
     f24:	90 93 81 17 	sts	0x1781, r25
     f28:	a0 93 82 17 	sts	0x1782, r26
     f2c:	b0 93 83 17 	sts	0x1783, r27
	
}
     f30:	08 95       	ret

00000f32 <blue_read>:

void blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
{
	//Blue
	filter_blue(); //select blue filter
     f32:	0e 94 51 07 	call	0xea2	; 0xea2 <filter_blue>
	pulse=0; //reset the count to 0
     f36:	10 92 ca 0c 	sts	0x0CCA, r1
     f3a:	10 92 cb 0c 	sts	0x0CCB, r1
     f3e:	10 92 cc 0c 	sts	0x0CCC, r1
     f42:	10 92 cd 0c 	sts	0x0CCD, r1
     f46:	8f ef       	ldi	r24, 0xFF	; 255
     f48:	9f e8       	ldi	r25, 0x8F	; 143
     f4a:	01 97       	sbiw	r24, 0x01	; 1
     f4c:	f1 f7       	brne	.-4      	; 0xf4a <blue_read+0x18>
     f4e:	00 c0       	rjmp	.+0      	; 0xf50 <blue_read+0x1e>
     f50:	00 00       	nop
	_delay_ms(10); //capture the pulses for 100 ms or 0.1 second
	blue = pulse;  //store the count in variable called blue
     f52:	80 91 ca 0c 	lds	r24, 0x0CCA
     f56:	90 91 cb 0c 	lds	r25, 0x0CCB
     f5a:	a0 91 cc 0c 	lds	r26, 0x0CCC
     f5e:	b0 91 cd 0c 	lds	r27, 0x0CCD
     f62:	80 93 38 11 	sts	0x1138, r24
     f66:	90 93 39 11 	sts	0x1139, r25
     f6a:	a0 93 3a 11 	sts	0x113A, r26
     f6e:	b0 93 3b 11 	sts	0x113B, r27
	
}
     f72:	08 95       	ret

00000f74 <no_filter>:

void no_filter()
{
	filter_clear(); //select clear filter
     f74:	0e 94 54 07 	call	0xea8	; 0xea8 <filter_clear>
	pulse=0; //reset the count to 0
     f78:	10 92 ca 0c 	sts	0x0CCA, r1
     f7c:	10 92 cb 0c 	sts	0x0CCB, r1
     f80:	10 92 cc 0c 	sts	0x0CCC, r1
     f84:	10 92 cd 0c 	sts	0x0CCD, r1
     f88:	8f ef       	ldi	r24, 0xFF	; 255
     f8a:	9f e7       	ldi	r25, 0x7F	; 127
     f8c:	a4 e0       	ldi	r26, 0x04	; 4
     f8e:	81 50       	subi	r24, 0x01	; 1
     f90:	90 40       	sbci	r25, 0x00	; 0
     f92:	a0 40       	sbci	r26, 0x00	; 0
     f94:	e1 f7       	brne	.-8      	; 0xf8e <no_filter+0x1a>
     f96:	00 c0       	rjmp	.+0      	; 0xf98 <no_filter+0x24>
     f98:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	no_ff = (pulse);  //store the count in variable called blue
     f9a:	80 91 ca 0c 	lds	r24, 0x0CCA
     f9e:	90 91 cb 0c 	lds	r25, 0x0CCB
     fa2:	a0 91 cc 0c 	lds	r26, 0x0CCC
     fa6:	b0 91 cd 0c 	lds	r27, 0x0CCD
     faa:	80 93 3c 11 	sts	0x113C, r24
     fae:	90 93 3d 11 	sts	0x113D, r25
     fb2:	a0 93 3e 11 	sts	0x113E, r26
     fb6:	b0 93 3f 11 	sts	0x113F, r27

}
     fba:	08 95       	ret

00000fbc <get_colour>:

int get_colour(void)
{
     fbc:	0f 93       	push	r16
     fbe:	1f 93       	push	r17
	EIMSK = EIMSK | 0x04;
     fc0:	ea 9a       	sbi	0x1d, 2	; 29

    red_read(); //display the pulse count when red filter is selected
     fc2:	0e 94 57 07 	call	0xeae	; 0xeae <red_read>
     fc6:	0f ef       	ldi	r16, 0xFF	; 255
     fc8:	1f e3       	ldi	r17, 0x3F	; 63
     fca:	22 e0       	ldi	r18, 0x02	; 2
     fcc:	01 50       	subi	r16, 0x01	; 1
     fce:	10 40       	sbci	r17, 0x00	; 0
     fd0:	20 40       	sbci	r18, 0x00	; 0
     fd2:	e1 f7       	brne	.-8      	; 0xfcc <get_colour+0x10>
     fd4:	00 c0       	rjmp	.+0      	; 0xfd6 <get_colour+0x1a>
     fd6:	00 00       	nop
	_delay_ms(50);

	green_read(); //display the pulse count when green filter is selected
     fd8:	0e 94 78 07 	call	0xef0	; 0xef0 <green_read>
     fdc:	8f ef       	ldi	r24, 0xFF	; 255
     fde:	9f e3       	ldi	r25, 0x3F	; 63
     fe0:	a2 e0       	ldi	r26, 0x02	; 2
     fe2:	81 50       	subi	r24, 0x01	; 1
     fe4:	90 40       	sbci	r25, 0x00	; 0
     fe6:	a0 40       	sbci	r26, 0x00	; 0
     fe8:	e1 f7       	brne	.-8      	; 0xfe2 <get_colour+0x26>
     fea:	00 c0       	rjmp	.+0      	; 0xfec <get_colour+0x30>
     fec:	00 00       	nop
	_delay_ms(50);

	blue_read(); //display the pulse count when blue filter is selected
     fee:	0e 94 99 07 	call	0xf32	; 0xf32 <blue_read>
     ff2:	0f ef       	ldi	r16, 0xFF	; 255
     ff4:	1f e3       	ldi	r17, 0x3F	; 63
     ff6:	22 e0       	ldi	r18, 0x02	; 2
     ff8:	01 50       	subi	r16, 0x01	; 1
     ffa:	10 40       	sbci	r17, 0x00	; 0
     ffc:	20 40       	sbci	r18, 0x00	; 0
     ffe:	e1 f7       	brne	.-8      	; 0xff8 <get_colour+0x3c>
    1000:	00 c0       	rjmp	.+0      	; 0x1002 <get_colour+0x46>
    1002:	00 00       	nop
	_delay_ms(50); 

	no_filter();//display the pulse count when no filter is selected
    1004:	0e 94 ba 07 	call	0xf74	; 0xf74 <no_filter>
    1008:	8f ef       	ldi	r24, 0xFF	; 255
    100a:	9f e3       	ldi	r25, 0x3F	; 63
    100c:	a2 e0       	ldi	r26, 0x02	; 2
    100e:	81 50       	subi	r24, 0x01	; 1
    1010:	90 40       	sbci	r25, 0x00	; 0
    1012:	a0 40       	sbci	r26, 0x00	; 0
    1014:	e1 f7       	brne	.-8      	; 0x100e <get_colour+0x52>
    1016:	00 c0       	rjmp	.+0      	; 0x1018 <get_colour+0x5c>
    1018:	00 00       	nop
	_delay_ms(50);

	EIMSK = EIMSK & 0xFB;
    101a:	ea 98       	cbi	0x1d, 2	; 29
	int a=(red+blue+green)/3;
    101c:	40 91 84 17 	lds	r20, 0x1784
    1020:	50 91 85 17 	lds	r21, 0x1785
    1024:	60 91 86 17 	lds	r22, 0x1786
    1028:	70 91 87 17 	lds	r23, 0x1787
    102c:	00 91 38 11 	lds	r16, 0x1138
    1030:	10 91 39 11 	lds	r17, 0x1139
    1034:	20 91 3a 11 	lds	r18, 0x113A
    1038:	30 91 3b 11 	lds	r19, 0x113B
    103c:	80 91 80 17 	lds	r24, 0x1780
    1040:	90 91 81 17 	lds	r25, 0x1781
    1044:	a0 91 82 17 	lds	r26, 0x1782
    1048:	b0 91 83 17 	lds	r27, 0x1783
    104c:	40 0f       	add	r20, r16
    104e:	51 1f       	adc	r21, r17
    1050:	62 1f       	adc	r22, r18
    1052:	73 1f       	adc	r23, r19
    1054:	8a 01       	movw	r16, r20
    1056:	9b 01       	movw	r18, r22
    1058:	08 0f       	add	r16, r24
    105a:	19 1f       	adc	r17, r25
    105c:	2a 1f       	adc	r18, r26
    105e:	3b 1f       	adc	r19, r27
    1060:	c9 01       	movw	r24, r18
    1062:	b8 01       	movw	r22, r16
    1064:	23 e0       	ldi	r18, 0x03	; 3
    1066:	30 e0       	ldi	r19, 0x00	; 0
    1068:	40 e0       	ldi	r20, 0x00	; 0
    106a:	50 e0       	ldi	r21, 0x00	; 0
    106c:	0e 94 16 1e 	call	0x3c2c	; 0x3c2c <__udivmodsi4>
	   
	if(a<250)
    1070:	2a 3f       	cpi	r18, 0xFA	; 250
    1072:	31 05       	cpc	r19, r1
    1074:	0c f4       	brge	.+2      	; 0x1078 <get_colour+0xbc>
    1076:	57 c0       	rjmp	.+174    	; 0x1126 <get_colour+0x16a>
		return 3;
	else
	{
		if(red > blue && red > green)
    1078:	40 91 84 17 	lds	r20, 0x1784
    107c:	50 91 85 17 	lds	r21, 0x1785
    1080:	60 91 86 17 	lds	r22, 0x1786
    1084:	70 91 87 17 	lds	r23, 0x1787
    1088:	80 91 38 11 	lds	r24, 0x1138
    108c:	90 91 39 11 	lds	r25, 0x1139
    1090:	a0 91 3a 11 	lds	r26, 0x113A
    1094:	b0 91 3b 11 	lds	r27, 0x113B
    1098:	84 17       	cp	r24, r20
    109a:	95 07       	cpc	r25, r21
    109c:	a6 07       	cpc	r26, r22
    109e:	b7 07       	cpc	r27, r23
    10a0:	a8 f4       	brcc	.+42     	; 0x10cc <get_colour+0x110>
    10a2:	40 91 84 17 	lds	r20, 0x1784
    10a6:	50 91 85 17 	lds	r21, 0x1785
    10aa:	60 91 86 17 	lds	r22, 0x1786
    10ae:	70 91 87 17 	lds	r23, 0x1787
    10b2:	80 91 80 17 	lds	r24, 0x1780
    10b6:	90 91 81 17 	lds	r25, 0x1781
    10ba:	a0 91 82 17 	lds	r26, 0x1782
    10be:	b0 91 83 17 	lds	r27, 0x1783
    10c2:	84 17       	cp	r24, r20
    10c4:	95 07       	cpc	r25, r21
    10c6:	a6 07       	cpc	r26, r22
    10c8:	b7 07       	cpc	r27, r23
    10ca:	80 f1       	brcs	.+96     	; 0x112c <get_colour+0x170>
			return 0;
		else if(green > red && green > blue)
    10cc:	40 91 80 17 	lds	r20, 0x1780
    10d0:	50 91 81 17 	lds	r21, 0x1781
    10d4:	60 91 82 17 	lds	r22, 0x1782
    10d8:	70 91 83 17 	lds	r23, 0x1783
    10dc:	80 91 84 17 	lds	r24, 0x1784
    10e0:	90 91 85 17 	lds	r25, 0x1785
    10e4:	a0 91 86 17 	lds	r26, 0x1786
    10e8:	b0 91 87 17 	lds	r27, 0x1787
    10ec:	84 17       	cp	r24, r20
    10ee:	95 07       	cpc	r25, r21
    10f0:	a6 07       	cpc	r26, r22
    10f2:	b7 07       	cpc	r27, r23
    10f4:	f0 f4       	brcc	.+60     	; 0x1132 <get_colour+0x176>
    10f6:	40 91 80 17 	lds	r20, 0x1780
    10fa:	50 91 81 17 	lds	r21, 0x1781
    10fe:	60 91 82 17 	lds	r22, 0x1782
    1102:	70 91 83 17 	lds	r23, 0x1783
    1106:	80 91 38 11 	lds	r24, 0x1138
    110a:	90 91 39 11 	lds	r25, 0x1139
    110e:	a0 91 3a 11 	lds	r26, 0x113A
    1112:	b0 91 3b 11 	lds	r27, 0x113B
    1116:	84 17       	cp	r24, r20
    1118:	95 07       	cpc	r25, r21
    111a:	a6 07       	cpc	r26, r22
    111c:	b7 07       	cpc	r27, r23
    111e:	60 f0       	brcs	.+24     	; 0x1138 <get_colour+0x17c>
			return 1;		
	}
	return 3;
    1120:	83 e0       	ldi	r24, 0x03	; 3
    1122:	90 e0       	ldi	r25, 0x00	; 0
    1124:	0b c0       	rjmp	.+22     	; 0x113c <get_colour+0x180>

	EIMSK = EIMSK & 0xFB;
	int a=(red+blue+green)/3;
	   
	if(a<250)
		return 3;
    1126:	83 e0       	ldi	r24, 0x03	; 3
    1128:	90 e0       	ldi	r25, 0x00	; 0
    112a:	08 c0       	rjmp	.+16     	; 0x113c <get_colour+0x180>
	else
	{
		if(red > blue && red > green)
			return 0;
    112c:	80 e0       	ldi	r24, 0x00	; 0
    112e:	90 e0       	ldi	r25, 0x00	; 0
    1130:	05 c0       	rjmp	.+10     	; 0x113c <get_colour+0x180>
		else if(green > red && green > blue)
			return 1;		
	}
	return 3;
    1132:	83 e0       	ldi	r24, 0x03	; 3
    1134:	90 e0       	ldi	r25, 0x00	; 0
    1136:	02 c0       	rjmp	.+4      	; 0x113c <get_colour+0x180>
	else
	{
		if(red > blue && red > green)
			return 0;
		else if(green > red && green > blue)
			return 1;		
    1138:	81 e0       	ldi	r24, 0x01	; 1
    113a:	90 e0       	ldi	r25, 0x00	; 0
	}
	return 3;
}
    113c:	1f 91       	pop	r17
    113e:	0f 91       	pop	r16
    1140:	08 95       	ret

00001142 <display_colour>:
*/

void display_colour(int c)
{
	//unsigned char a;
	switch(c)
    1142:	81 30       	cpi	r24, 0x01	; 1
    1144:	91 05       	cpc	r25, r1
    1146:	51 f0       	breq	.+20     	; 0x115c <display_colour+0x1a>
    1148:	82 30       	cpi	r24, 0x02	; 2
    114a:	91 05       	cpc	r25, r1
    114c:	61 f0       	breq	.+24     	; 0x1166 <display_colour+0x24>
    114e:	00 97       	sbiw	r24, 0x00	; 0
    1150:	79 f4       	brne	.+30     	; 0x1170 <display_colour+0x2e>
	{
		case 0:	PORTD=PORTD & 0xF4;
    1152:	8b b1       	in	r24, 0x0b	; 11
    1154:	84 7f       	andi	r24, 0xF4	; 244
    1156:	8b b9       	out	0x0b, r24	; 11
				PORTD=PORTD | 0x01;break;
    1158:	58 9a       	sbi	0x0b, 0	; 11
    115a:	08 95       	ret
		
		case 1:	PORTD=PORTD & 0xF4;
    115c:	8b b1       	in	r24, 0x0b	; 11
    115e:	84 7f       	andi	r24, 0xF4	; 244
    1160:	8b b9       	out	0x0b, r24	; 11
				PORTD=PORTD | 0x02;break;
    1162:	59 9a       	sbi	0x0b, 1	; 11
    1164:	08 95       	ret
		
		case 2:
				PORTD=PORTD & 0xF4;
    1166:	8b b1       	in	r24, 0x0b	; 11
    1168:	84 7f       	andi	r24, 0xF4	; 244
    116a:	8b b9       	out	0x0b, r24	; 11
				PORTD=PORTD | 0x08;break;
    116c:	5b 9a       	sbi	0x0b, 3	; 11
    116e:	08 95       	ret
		
		default:
		case 3:
				PORTD=PORTD & 0xF4;
    1170:	8b b1       	in	r24, 0x0b	; 11
    1172:	84 7f       	andi	r24, 0xF4	; 244
    1174:	8b b9       	out	0x0b, r24	; 11
    1176:	08 95       	ret

00001178 <dijsktra>:
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0}
};

int dijsktra(int source,int target)
{
    1178:	2f 92       	push	r2
    117a:	3f 92       	push	r3
    117c:	4f 92       	push	r4
    117e:	5f 92       	push	r5
    1180:	6f 92       	push	r6
    1182:	7f 92       	push	r7
    1184:	8f 92       	push	r8
    1186:	9f 92       	push	r9
    1188:	af 92       	push	r10
    118a:	bf 92       	push	r11
    118c:	cf 92       	push	r12
    118e:	df 92       	push	r13
    1190:	ef 92       	push	r14
    1192:	ff 92       	push	r15
    1194:	0f 93       	push	r16
    1196:	1f 93       	push	r17
    1198:	cf 93       	push	r28
    119a:	df 93       	push	r29
    119c:	cd b7       	in	r28, 0x3d	; 61
    119e:	de b7       	in	r29, 0x3e	; 62
    11a0:	cc 5d       	subi	r28, 0xDC	; 220
    11a2:	d0 40       	sbci	r29, 0x00	; 0
    11a4:	0f b6       	in	r0, 0x3f	; 63
    11a6:	f8 94       	cli
    11a8:	de bf       	out	0x3e, r29	; 62
    11aa:	0f be       	out	0x3f, r0	; 63
    11ac:	cd bf       	out	0x3d, r28	; 61
    11ae:	4c 01       	movw	r8, r24
    11b0:	c7 52       	subi	r28, 0x27	; 39
    11b2:	df 4f       	sbci	r29, 0xFF	; 255
    11b4:	79 83       	std	Y+1, r23	; 0x01
    11b6:	68 83       	st	Y, r22
    11b8:	c9 5d       	subi	r28, 0xD9	; 217
    11ba:	d0 40       	sbci	r29, 0x00	; 0
  int dist[N],prev[N],selected[N]={0},i,m,min,start,d,j;
    11bc:	84 e3       	ldi	r24, 0x34	; 52
    11be:	fe 01       	movw	r30, r28
    11c0:	e7 59       	subi	r30, 0x97	; 151
    11c2:	ff 4f       	sbci	r31, 0xFF	; 255
    11c4:	df 01       	movw	r26, r30
    11c6:	1d 92       	st	X+, r1
    11c8:	8a 95       	dec	r24
    11ca:	e9 f7       	brne	.-6      	; 0x11c6 <dijsktra+0x4e>
  int path[N];
  for(i=1;i< N;i++)
    11cc:	61 e0       	ldi	r22, 0x01	; 1
    11ce:	70 e0       	ldi	r23, 0x00	; 0
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0}
};

int dijsktra(int source,int target)
    11d0:	a4 e3       	ldi	r26, 0x34	; 52
    11d2:	b0 e0       	ldi	r27, 0x00	; 0
    11d4:	09 e1       	ldi	r16, 0x19	; 25
    11d6:	10 e0       	ldi	r17, 0x00	; 0
  int dist[N],prev[N],selected[N]={0},i,m,min,start,d,j;
  int path[N];
  for(i=1;i< N;i++)
    for(j=1;j< N;j++)
      if(cost[i][j] == 0)
         cost[i][j]=IN;
    11d8:	43 e6       	ldi	r20, 0x63	; 99
    11da:	50 e0       	ldi	r21, 0x00	; 0
    11dc:	11 c0       	rjmp	.+34     	; 0x1200 <dijsktra+0x88>
{
  int dist[N],prev[N],selected[N]={0},i,m,min,start,d,j;
  int path[N];
  for(i=1;i< N;i++)
    for(j=1;j< N;j++)
      if(cost[i][j] == 0)
    11de:	80 81       	ld	r24, Z
    11e0:	91 81       	ldd	r25, Z+1	; 0x01
    11e2:	00 97       	sbiw	r24, 0x00	; 0
    11e4:	11 f4       	brne	.+4      	; 0x11ea <dijsktra+0x72>
         cost[i][j]=IN;
    11e6:	51 83       	std	Z+1, r21	; 0x01
    11e8:	40 83       	st	Z, r20
    11ea:	21 50       	subi	r18, 0x01	; 1
    11ec:	30 40       	sbci	r19, 0x00	; 0
    11ee:	32 96       	adiw	r30, 0x02	; 2
int dijsktra(int source,int target)
{
  int dist[N],prev[N],selected[N]={0},i,m,min,start,d,j;
  int path[N];
  for(i=1;i< N;i++)
    for(j=1;j< N;j++)
    11f0:	21 15       	cp	r18, r1
    11f2:	31 05       	cpc	r19, r1
    11f4:	a1 f7       	brne	.-24     	; 0x11de <dijsktra+0x66>

int dijsktra(int source,int target)
{
  int dist[N],prev[N],selected[N]={0},i,m,min,start,d,j;
  int path[N];
  for(i=1;i< N;i++)
    11f6:	6f 5f       	subi	r22, 0xFF	; 255
    11f8:	7f 4f       	sbci	r23, 0xFF	; 255
    11fa:	6a 31       	cpi	r22, 0x1A	; 26
    11fc:	71 05       	cpc	r23, r1
    11fe:	59 f0       	breq	.+22     	; 0x1216 <dijsktra+0x9e>
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0}
};

int dijsktra(int source,int target)
    1200:	6a 9f       	mul	r22, r26
    1202:	f0 01       	movw	r30, r0
    1204:	6b 9f       	mul	r22, r27
    1206:	f0 0d       	add	r31, r0
    1208:	7a 9f       	mul	r23, r26
    120a:	f0 0d       	add	r31, r0
    120c:	11 24       	eor	r1, r1
    120e:	ee 5f       	subi	r30, 0xFE	; 254
    1210:	fd 4f       	sbci	r31, 0xFD	; 253
    1212:	98 01       	movw	r18, r16
    1214:	e4 cf       	rjmp	.-56     	; 0x11de <dijsktra+0x66>
{
  int dist[N],prev[N],selected[N]={0},i,m,min,start,d,j;
  int path[N];
  for(i=1;i< N;i++)
    1216:	8e 01       	movw	r16, r28
    1218:	0d 5f       	subi	r16, 0xFD	; 253
    121a:	1f 4f       	sbci	r17, 0xFF	; 255
    121c:	be 01       	movw	r22, r28
    121e:	69 5c       	subi	r22, 0xC9	; 201
    1220:	7f 4f       	sbci	r23, 0xFF	; 255
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0}
};

int dijsktra(int source,int target)
    1222:	ce 01       	movw	r24, r28
    1224:	c5 96       	adiw	r24, 0x35	; 53
    1226:	db 01       	movw	r26, r22
    1228:	f8 01       	movw	r30, r16
      if(cost[i][j] == 0)
         cost[i][j]=IN;

  for(i=1;i< N;i++)
  {
    dist[i] = IN;
    122a:	23 e6       	ldi	r18, 0x63	; 99
    122c:	30 e0       	ldi	r19, 0x00	; 0
    prev[i] = -1;
    122e:	4f ef       	ldi	r20, 0xFF	; 255
    1230:	5f ef       	ldi	r21, 0xFF	; 255
      if(cost[i][j] == 0)
         cost[i][j]=IN;

  for(i=1;i< N;i++)
  {
    dist[i] = IN;
    1232:	21 93       	st	Z+, r18
    1234:	31 93       	st	Z+, r19
    prev[i] = -1;
    1236:	4d 93       	st	X+, r20
    1238:	5d 93       	st	X+, r21
  for(i=1;i< N;i++)
    for(j=1;j< N;j++)
      if(cost[i][j] == 0)
         cost[i][j]=IN;

  for(i=1;i< N;i++)
    123a:	e8 17       	cp	r30, r24
    123c:	f9 07       	cpc	r31, r25
    123e:	c9 f7       	brne	.-14     	; 0x1232 <dijsktra+0xba>
    dist[i] = IN;
    prev[i] = -1;
  }

  start = source;
  selected[start]=1;
    1240:	c4 01       	movw	r24, r8
    1242:	88 0f       	add	r24, r24
    1244:	99 1f       	adc	r25, r25
    1246:	e9 e6       	ldi	r30, 0x69	; 105
    1248:	f0 e0       	ldi	r31, 0x00	; 0
    124a:	ec 0f       	add	r30, r28
    124c:	fd 1f       	adc	r31, r29
    124e:	e8 0f       	add	r30, r24
    1250:	f9 1f       	adc	r31, r25
    1252:	21 e0       	ldi	r18, 0x01	; 1
    1254:	30 e0       	ldi	r19, 0x00	; 0
    1256:	31 83       	std	Z+1, r19	; 0x01
    1258:	20 83       	st	Z, r18
  dist[start] = 0;
    125a:	8c 0f       	add	r24, r28
    125c:	9d 1f       	adc	r25, r29
    125e:	fc 01       	movw	r30, r24
    1260:	12 82       	std	Z+2, r1	; 0x02
    1262:	11 82       	std	Z+1, r1	; 0x01

  while(selected[target] == 0)
    1264:	c7 52       	subi	r28, 0x27	; 39
    1266:	df 4f       	sbci	r29, 0xFF	; 255
    1268:	e8 81       	ld	r30, Y
    126a:	f9 81       	ldd	r31, Y+1	; 0x01
    126c:	c9 5d       	subi	r28, 0xD9	; 217
    126e:	d0 40       	sbci	r29, 0x00	; 0
    1270:	ee 0f       	add	r30, r30
    1272:	ff 1f       	adc	r31, r31
    1274:	29 e6       	ldi	r18, 0x69	; 105
    1276:	30 e0       	ldi	r19, 0x00	; 0
    1278:	2c 0f       	add	r18, r28
    127a:	3d 1f       	adc	r19, r29
    127c:	e2 0f       	add	r30, r18
    127e:	f3 1f       	adc	r31, r19
    1280:	80 81       	ld	r24, Z
    1282:	91 81       	ldd	r25, Z+1	; 0x01
    1284:	00 97       	sbiw	r24, 0x00	; 0
    1286:	09 f4       	brne	.+2      	; 0x128a <dijsktra+0x112>
    1288:	67 c0       	rjmp	.+206    	; 0x1358 <dijsktra+0x1e0>
    128a:	e3 c0       	rjmp	.+454    	; 0x1452 <dijsktra+0x2da>
  {
    min = IN;
    m = 0;
    for(i=1;i< N;i++)
    {
      d = dist[start] +cost[start][i];
    128c:	d7 01       	movw	r26, r14
    128e:	8d 91       	ld	r24, X+
    1290:	9d 91       	ld	r25, X+
    1292:	7d 01       	movw	r14, r26
    1294:	d5 01       	movw	r26, r10
    1296:	2d 91       	ld	r18, X+
    1298:	3c 91       	ld	r19, X
    129a:	11 97       	sbiw	r26, 0x01	; 1
    129c:	28 0f       	add	r18, r24
    129e:	39 1f       	adc	r19, r25
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0}
};

int dijsktra(int source,int target)
    12a0:	bf 01       	movw	r22, r30
    m = 0;
    for(i=1;i< N;i++)
    {
      d = dist[start] +cost[start][i];

      if(d< dist[i] && selected[i] == 0)
    12a2:	80 81       	ld	r24, Z
    12a4:	91 81       	ldd	r25, Z+1	; 0x01
    12a6:	28 17       	cp	r18, r24
    12a8:	39 07       	cpc	r19, r25
    12aa:	84 f4       	brge	.+32     	; 0x12cc <dijsktra+0x154>
    12ac:	c5 52       	subi	r28, 0x25	; 37
    12ae:	df 4f       	sbci	r29, 0xFF	; 255
    12b0:	a8 81       	ld	r26, Y
    12b2:	b9 81       	ldd	r27, Y+1	; 0x01
    12b4:	cb 5d       	subi	r28, 0xDB	; 219
    12b6:	d0 40       	sbci	r29, 0x00	; 0
    12b8:	8d 91       	ld	r24, X+
    12ba:	9c 91       	ld	r25, X
    12bc:	11 97       	sbiw	r26, 0x01	; 1
    12be:	00 97       	sbiw	r24, 0x00	; 0
    12c0:	29 f4       	brne	.+10     	; 0x12cc <dijsktra+0x154>
      {
        dist[i] = d;
    12c2:	31 83       	std	Z+1, r19	; 0x01
    12c4:	20 83       	st	Z, r18
        prev[i] = start;
    12c6:	d8 01       	movw	r26, r16
    12c8:	8d 92       	st	X+, r8
    12ca:	9c 92       	st	X, r9
      }
      if(min>dist[i] && selected[i]==0)
    12cc:	db 01       	movw	r26, r22
    12ce:	8d 91       	ld	r24, X+
    12d0:	9c 91       	ld	r25, X
    12d2:	11 97       	sbiw	r26, 0x01	; 1
    12d4:	32 96       	adiw	r30, 0x02	; 2
    12d6:	8c 15       	cp	r24, r12
    12d8:	9d 05       	cpc	r25, r13
    12da:	74 f4       	brge	.+28     	; 0x12f8 <dijsktra+0x180>
    12dc:	c5 52       	subi	r28, 0x25	; 37
    12de:	df 4f       	sbci	r29, 0xFF	; 255
    12e0:	a8 81       	ld	r26, Y
    12e2:	b9 81       	ldd	r27, Y+1	; 0x01
    12e4:	cb 5d       	subi	r28, 0xDB	; 219
    12e6:	d0 40       	sbci	r29, 0x00	; 0
    12e8:	2d 91       	ld	r18, X+
    12ea:	3c 91       	ld	r19, X
    12ec:	11 97       	sbiw	r26, 0x01	; 1
    12ee:	21 15       	cp	r18, r1
    12f0:	31 05       	cpc	r19, r1
    12f2:	11 f4       	brne	.+4      	; 0x12f8 <dijsktra+0x180>
      {
        min = dist[i];
    12f4:	6c 01       	movw	r12, r24
      if(d< dist[i] && selected[i] == 0)
      {
        dist[i] = d;
        prev[i] = start;
      }
      if(min>dist[i] && selected[i]==0)
    12f6:	3a 01       	movw	r6, r20

  while(selected[target] == 0)
  {
    min = IN;
    m = 0;
    for(i=1;i< N;i++)
    12f8:	4f 5f       	subi	r20, 0xFF	; 255
    12fa:	5f 4f       	sbci	r21, 0xFF	; 255
    12fc:	c5 52       	subi	r28, 0x25	; 37
    12fe:	df 4f       	sbci	r29, 0xFF	; 255
    1300:	28 81       	ld	r18, Y
    1302:	39 81       	ldd	r19, Y+1	; 0x01
    1304:	cb 5d       	subi	r28, 0xDB	; 219
    1306:	d0 40       	sbci	r29, 0x00	; 0
    1308:	2e 5f       	subi	r18, 0xFE	; 254
    130a:	3f 4f       	sbci	r19, 0xFF	; 255
    130c:	c5 52       	subi	r28, 0x25	; 37
    130e:	df 4f       	sbci	r29, 0xFF	; 255
    1310:	39 83       	std	Y+1, r19	; 0x01
    1312:	28 83       	st	Y, r18
    1314:	cb 5d       	subi	r28, 0xDB	; 219
    1316:	d0 40       	sbci	r29, 0x00	; 0
    1318:	0e 5f       	subi	r16, 0xFE	; 254
    131a:	1f 4f       	sbci	r17, 0xFF	; 255
    131c:	4a 31       	cpi	r20, 0x1A	; 26
    131e:	51 05       	cpc	r21, r1
    1320:	09 f0       	breq	.+2      	; 0x1324 <dijsktra+0x1ac>
    1322:	b4 cf       	rjmp	.-152    	; 0x128c <dijsktra+0x114>
        min = dist[i];
        m = i;
      }
    }
    start = m;
    selected[start] = 1;
    1324:	c3 01       	movw	r24, r6
    1326:	88 0f       	add	r24, r24
    1328:	99 1f       	adc	r25, r25
    132a:	a9 e6       	ldi	r26, 0x69	; 105
    132c:	b0 e0       	ldi	r27, 0x00	; 0
    132e:	ac 0f       	add	r26, r28
    1330:	bd 1f       	adc	r27, r29
    1332:	8a 0f       	add	r24, r26
    1334:	9b 1f       	adc	r25, r27
    1336:	fc 01       	movw	r30, r24
    1338:	51 82       	std	Z+1, r5	; 0x01
    133a:	40 82       	st	Z, r4

  start = source;
  selected[start]=1;
  dist[start] = 0;

  while(selected[target] == 0)
    133c:	cd 52       	subi	r28, 0x2D	; 45
    133e:	df 4f       	sbci	r29, 0xFF	; 255
    1340:	a8 81       	ld	r26, Y
    1342:	b9 81       	ldd	r27, Y+1	; 0x01
    1344:	c3 5d       	subi	r28, 0xD3	; 211
    1346:	d0 40       	sbci	r29, 0x00	; 0
    1348:	8d 91       	ld	r24, X+
    134a:	9c 91       	ld	r25, X
    134c:	11 97       	sbiw	r26, 0x01	; 1
    134e:	00 97       	sbiw	r24, 0x00	; 0
    1350:	09 f0       	breq	.+2      	; 0x1354 <dijsktra+0x1dc>
    1352:	7f c0       	rjmp	.+254    	; 0x1452 <dijsktra+0x2da>
      {
        min = dist[i];
        m = i;
      }
    }
    start = m;
    1354:	43 01       	movw	r8, r6
    1356:	3b c0       	rjmp	.+118    	; 0x13ce <dijsktra+0x256>
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0}
};

int dijsktra(int source,int target)
    1358:	0f 2e       	mov	r0, r31
    135a:	f4 e3       	ldi	r31, 0x34	; 52
    135c:	2f 2e       	mov	r2, r31
    135e:	33 24       	eor	r3, r3
    1360:	f0 2d       	mov	r31, r0

  start = source;
  selected[start]=1;
  dist[start] = 0;

  while(selected[target] == 0)
    1362:	e9 e6       	ldi	r30, 0x69	; 105
    1364:	f0 e0       	ldi	r31, 0x00	; 0
    1366:	ec 0f       	add	r30, r28
    1368:	fd 1f       	adc	r31, r29
    136a:	32 96       	adiw	r30, 0x02	; 2
    136c:	cf 52       	subi	r28, 0x2F	; 47
    136e:	df 4f       	sbci	r29, 0xFF	; 255
    1370:	f9 83       	std	Y+1, r31	; 0x01
    1372:	e8 83       	st	Y, r30
    1374:	c1 5d       	subi	r28, 0xD1	; 209
    1376:	d0 40       	sbci	r29, 0x00	; 0
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0}
};

int dijsktra(int source,int target)
    1378:	cb 52       	subi	r28, 0x2B	; 43
    137a:	df 4f       	sbci	r29, 0xFF	; 255
    137c:	68 83       	st	Y, r22
    137e:	c5 5d       	subi	r28, 0xD5	; 213
    1380:	d0 40       	sbci	r29, 0x00	; 0
    1382:	ca 52       	subi	r28, 0x2A	; 42
    1384:	df 4f       	sbci	r29, 0xFF	; 255
    1386:	78 83       	st	Y, r23
    1388:	c6 5d       	subi	r28, 0xD6	; 214
    138a:	d0 40       	sbci	r29, 0x00	; 0
    138c:	c9 52       	subi	r28, 0x29	; 41
    138e:	df 4f       	sbci	r29, 0xFF	; 255
    1390:	08 83       	st	Y, r16
    1392:	c7 5d       	subi	r28, 0xD7	; 215
    1394:	d0 40       	sbci	r29, 0x00	; 0
    1396:	c8 52       	subi	r28, 0x28	; 40
    1398:	df 4f       	sbci	r29, 0xFF	; 255
    139a:	18 83       	st	Y, r17
    139c:	c8 5d       	subi	r28, 0xD8	; 216
    139e:	d0 40       	sbci	r29, 0x00	; 0
    13a0:	44 24       	eor	r4, r4
    13a2:	55 24       	eor	r5, r5
    13a4:	43 94       	inc	r4

  start = source;
  selected[start]=1;
  dist[start] = 0;

  while(selected[target] == 0)
    13a6:	c7 52       	subi	r28, 0x27	; 39
    13a8:	df 4f       	sbci	r29, 0xFF	; 255
    13aa:	88 81       	ld	r24, Y
    13ac:	99 81       	ldd	r25, Y+1	; 0x01
    13ae:	c9 5d       	subi	r28, 0xD9	; 217
    13b0:	d0 40       	sbci	r29, 0x00	; 0
    13b2:	88 0f       	add	r24, r24
    13b4:	99 1f       	adc	r25, r25
    13b6:	29 e6       	ldi	r18, 0x69	; 105
    13b8:	30 e0       	ldi	r19, 0x00	; 0
    13ba:	2c 0f       	add	r18, r28
    13bc:	3d 1f       	adc	r19, r29
    13be:	28 0f       	add	r18, r24
    13c0:	39 1f       	adc	r19, r25
    13c2:	cd 52       	subi	r28, 0x2D	; 45
    13c4:	df 4f       	sbci	r29, 0xFF	; 255
    13c6:	39 83       	std	Y+1, r19	; 0x01
    13c8:	28 83       	st	Y, r18
    13ca:	c3 5d       	subi	r28, 0xD3	; 211
    13cc:	d0 40       	sbci	r29, 0x00	; 0
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0}
};

int dijsktra(int source,int target)
    13ce:	82 9c       	mul	r8, r2
    13d0:	c0 01       	movw	r24, r0
    13d2:	83 9c       	mul	r8, r3
    13d4:	90 0d       	add	r25, r0
    13d6:	92 9c       	mul	r9, r2
    13d8:	90 0d       	add	r25, r0
    13da:	11 24       	eor	r1, r1
    13dc:	0f 2e       	mov	r0, r31
    13de:	f2 e0       	ldi	r31, 0x02	; 2
    13e0:	ef 2e       	mov	r14, r31
    13e2:	f2 e0       	ldi	r31, 0x02	; 2
    13e4:	ff 2e       	mov	r15, r31
    13e6:	f0 2d       	mov	r31, r0
    13e8:	e8 0e       	add	r14, r24
    13ea:	f9 1e       	adc	r15, r25

  start = source;
  selected[start]=1;
  dist[start] = 0;

  while(selected[target] == 0)
    13ec:	cf 52       	subi	r28, 0x2F	; 47
    13ee:	df 4f       	sbci	r29, 0xFF	; 255
    13f0:	68 81       	ld	r22, Y
    13f2:	79 81       	ldd	r23, Y+1	; 0x01
    13f4:	c1 5d       	subi	r28, 0xD1	; 209
    13f6:	d0 40       	sbci	r29, 0x00	; 0
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0}
};

int dijsktra(int source,int target)
    13f8:	cb 52       	subi	r28, 0x2B	; 43
    13fa:	df 4f       	sbci	r29, 0xFF	; 255
    13fc:	08 81       	ld	r16, Y
    13fe:	c5 5d       	subi	r28, 0xD5	; 213
    1400:	d0 40       	sbci	r29, 0x00	; 0
    1402:	ca 52       	subi	r28, 0x2A	; 42
    1404:	df 4f       	sbci	r29, 0xFF	; 255
    1406:	18 81       	ld	r17, Y
    1408:	c6 5d       	subi	r28, 0xD6	; 214
    140a:	d0 40       	sbci	r29, 0x00	; 0
    140c:	c9 52       	subi	r28, 0x29	; 41
    140e:	df 4f       	sbci	r29, 0xFF	; 255
    1410:	e8 81       	ld	r30, Y
    1412:	c7 5d       	subi	r28, 0xD7	; 215
    1414:	d0 40       	sbci	r29, 0x00	; 0
    1416:	c8 52       	subi	r28, 0x28	; 40
    1418:	df 4f       	sbci	r29, 0xFF	; 255
    141a:	f8 81       	ld	r31, Y
    141c:	c8 5d       	subi	r28, 0xD8	; 216
    141e:	d0 40       	sbci	r29, 0x00	; 0
    1420:	0f 2e       	mov	r0, r31
    1422:	f3 e6       	ldi	r31, 0x63	; 99
    1424:	cf 2e       	mov	r12, r31
    1426:	dd 24       	eor	r13, r13
    1428:	f0 2d       	mov	r31, r0
    142a:	66 24       	eor	r6, r6
    142c:	77 24       	eor	r7, r7
    142e:	a2 01       	movw	r20, r4
  {
    min = IN;
    m = 0;
    for(i=1;i< N;i++)
    {
      d = dist[start] +cost[start][i];
    1430:	c4 01       	movw	r24, r8
    1432:	88 0f       	add	r24, r24
    1434:	99 1f       	adc	r25, r25
    1436:	aa 24       	eor	r10, r10
    1438:	bb 24       	eor	r11, r11
    143a:	a3 94       	inc	r10
    143c:	ac 0e       	add	r10, r28
    143e:	bd 1e       	adc	r11, r29
    1440:	a8 0e       	add	r10, r24
    1442:	b9 1e       	adc	r11, r25
    1444:	c5 52       	subi	r28, 0x25	; 37
    1446:	df 4f       	sbci	r29, 0xFF	; 255
    1448:	79 83       	std	Y+1, r23	; 0x01
    144a:	68 83       	st	Y, r22
    144c:	cb 5d       	subi	r28, 0xDB	; 219
    144e:	d0 40       	sbci	r29, 0x00	; 0
    1450:	1d cf       	rjmp	.-454    	; 0x128c <dijsktra+0x114>
    selected[start] = 1;
  }
  start = target;
  j = 0;

  while(start != -1)
    1452:	c7 52       	subi	r28, 0x27	; 39
    1454:	df 4f       	sbci	r29, 0xFF	; 255
    1456:	88 81       	ld	r24, Y
    1458:	99 81       	ldd	r25, Y+1	; 0x01
    145a:	c9 5d       	subi	r28, 0xD9	; 217
    145c:	d0 40       	sbci	r29, 0x00	; 0
    145e:	af ef       	ldi	r26, 0xFF	; 255
    1460:	8f 3f       	cpi	r24, 0xFF	; 255
    1462:	9a 07       	cpc	r25, r26
    1464:	d9 f0       	breq	.+54     	; 0x149c <dijsktra+0x324>
    1466:	fe 01       	movw	r30, r28
    1468:	e3 56       	subi	r30, 0x63	; 99
    146a:	ff 4f       	sbci	r31, 0xFF	; 255
    146c:	40 e0       	ldi	r20, 0x00	; 0
    146e:	50 e0       	ldi	r21, 0x00	; 0
  {
    path[j++] = start;
    1470:	81 93       	st	Z+, r24
    1472:	91 93       	st	Z+, r25
    1474:	4f 5f       	subi	r20, 0xFF	; 255
    1476:	5f 4f       	sbci	r21, 0xFF	; 255
    start = prev[start];
    1478:	dc 01       	movw	r26, r24
    147a:	aa 0f       	add	r26, r26
    147c:	bb 1f       	adc	r27, r27
    147e:	21 e0       	ldi	r18, 0x01	; 1
    1480:	30 e0       	ldi	r19, 0x00	; 0
    1482:	2c 0f       	add	r18, r28
    1484:	3d 1f       	adc	r19, r29
    1486:	a2 0f       	add	r26, r18
    1488:	b3 1f       	adc	r27, r19
    148a:	d4 96       	adiw	r26, 0x34	; 52
    148c:	8d 91       	ld	r24, X+
    148e:	9c 91       	ld	r25, X
    1490:	d5 97       	sbiw	r26, 0x35	; 53
    selected[start] = 1;
  }
  start = target;
  j = 0;

  while(start != -1)
    1492:	3f ef       	ldi	r19, 0xFF	; 255
    1494:	8f 3f       	cpi	r24, 0xFF	; 255
    1496:	93 07       	cpc	r25, r19
    1498:	59 f7       	brne	.-42     	; 0x1470 <dijsktra+0x2f8>
    149a:	02 c0       	rjmp	.+4      	; 0x14a0 <dijsktra+0x328>
    149c:	40 e0       	ldi	r20, 0x00	; 0
    149e:	50 e0       	ldi	r21, 0x00	; 0
  {
    path[j++] = start;
    start = prev[start];
  }

    path[j]=0;
    14a0:	fa 01       	movw	r30, r20
    14a2:	ee 0f       	add	r30, r30
    14a4:	ff 1f       	adc	r31, r31
    14a6:	8d e9       	ldi	r24, 0x9D	; 157
    14a8:	90 e0       	ldi	r25, 0x00	; 0
    14aa:	8c 0f       	add	r24, r28
    14ac:	9d 1f       	adc	r25, r29
    14ae:	e8 0f       	add	r30, r24
    14b0:	f9 1f       	adc	r31, r25
    14b2:	11 82       	std	Z+1, r1	; 0x01
    14b4:	10 82       	st	Z, r1
    14b6:	aa e8       	ldi	r26, 0x8A	; 138
    14b8:	b7 e1       	ldi	r27, 0x17	; 23
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0}
};

int dijsktra(int source,int target)
    14ba:	9d 01       	movw	r18, r26
    14bc:	cd 01       	movw	r24, r26
    14be:	c4 96       	adiw	r24, 0x34	; 52
    14c0:	fd 01       	movw	r30, r26
  }

    path[j]=0;
    int k=0;
    for(i=0;i<N;i++)
        n_node[i]=0;
    14c2:	11 92       	st	Z+, r1
    14c4:	11 92       	st	Z+, r1
    start = prev[start];
  }

    path[j]=0;
    int k=0;
    for(i=0;i<N;i++)
    14c6:	e8 17       	cp	r30, r24
    14c8:	f9 07       	cpc	r31, r25
    14ca:	d9 f7       	brne	.-10     	; 0x14c2 <dijsktra+0x34a>
        n_node[i]=0;

    for(i=j-1;i>=0;i--)
    14cc:	ca 01       	movw	r24, r20
    14ce:	01 97       	sbiw	r24, 0x01	; 1
    14d0:	92 f0       	brmi	.+36     	; 0x14f6 <dijsktra+0x37e>
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0}
};

int dijsktra(int source,int target)
    14d2:	ca 01       	movw	r24, r20
    14d4:	88 0f       	add	r24, r24
    14d6:	99 1f       	adc	r25, r25
    14d8:	ed e9       	ldi	r30, 0x9D	; 157
    14da:	f0 e0       	ldi	r31, 0x00	; 0
    14dc:	ec 0f       	add	r30, r28
    14de:	fd 1f       	adc	r31, r29
    14e0:	e8 0f       	add	r30, r24
    14e2:	f9 1f       	adc	r31, r25
    14e4:	82 0f       	add	r24, r18
    14e6:	93 1f       	adc	r25, r19
    int k=0;
    for(i=0;i<N;i++)
        n_node[i]=0;

    for(i=j-1;i>=0;i--)
        n_node[k++]=path[i];
    14e8:	32 91       	ld	r19, -Z
    14ea:	22 91       	ld	r18, -Z
    14ec:	2d 93       	st	X+, r18
    14ee:	3d 93       	st	X+, r19
    path[j]=0;
    int k=0;
    for(i=0;i<N;i++)
        n_node[i]=0;

    for(i=j-1;i>=0;i--)
    14f0:	a8 17       	cp	r26, r24
    14f2:	b9 07       	cpc	r27, r25
    14f4:	c9 f7       	brne	.-14     	; 0x14e8 <dijsktra+0x370>
        n_node[k++]=path[i];

    return j;
}
    14f6:	84 2f       	mov	r24, r20
    14f8:	95 2f       	mov	r25, r21
    14fa:	c4 52       	subi	r28, 0x24	; 36
    14fc:	df 4f       	sbci	r29, 0xFF	; 255
    14fe:	0f b6       	in	r0, 0x3f	; 63
    1500:	f8 94       	cli
    1502:	de bf       	out	0x3e, r29	; 62
    1504:	0f be       	out	0x3f, r0	; 63
    1506:	cd bf       	out	0x3d, r28	; 61
    1508:	df 91       	pop	r29
    150a:	cf 91       	pop	r28
    150c:	1f 91       	pop	r17
    150e:	0f 91       	pop	r16
    1510:	ff 90       	pop	r15
    1512:	ef 90       	pop	r14
    1514:	df 90       	pop	r13
    1516:	cf 90       	pop	r12
    1518:	bf 90       	pop	r11
    151a:	af 90       	pop	r10
    151c:	9f 90       	pop	r9
    151e:	8f 90       	pop	r8
    1520:	7f 90       	pop	r7
    1522:	6f 90       	pop	r6
    1524:	5f 90       	pop	r5
    1526:	4f 90       	pop	r4
    1528:	3f 90       	pop	r3
    152a:	2f 90       	pop	r2
    152c:	08 95       	ret

0000152e <init_survivors>:
struct plot b[17];
struct survivors s[10];

void init_survivors(void)
{
	for (int i=0;i<10;i++)
    152e:	80 e0       	ldi	r24, 0x00	; 0
    1530:	90 e0       	ldi	r25, 0x00	; 0
	{
		survivor_status[i] = 2;
    1532:	24 e2       	ldi	r18, 0x24	; 36
    1534:	32 e1       	ldi	r19, 0x12	; 18
    1536:	42 e0       	ldi	r20, 0x02	; 2
    1538:	50 e0       	ldi	r21, 0x00	; 0
    153a:	fc 01       	movw	r30, r24
    153c:	ee 0f       	add	r30, r30
    153e:	ff 1f       	adc	r31, r31
    1540:	e2 0f       	add	r30, r18
    1542:	f3 1f       	adc	r31, r19
    1544:	51 83       	std	Z+1, r21	; 0x01
    1546:	40 83       	st	Z, r20
struct plot b[17];
struct survivors s[10];

void init_survivors(void)
{
	for (int i=0;i<10;i++)
    1548:	01 96       	adiw	r24, 0x01	; 1
    154a:	8a 30       	cpi	r24, 0x0A	; 10
    154c:	91 05       	cpc	r25, r1
    154e:	a9 f7       	brne	.-22     	; 0x153a <init_survivors+0xc>
	{
		survivor_status[i] = 2;
	}
}
    1550:	08 95       	ret

00001552 <setp>:

void setp(int start,int id)		// To initialize all 4 paths in a plot
{
    1552:	dc 01       	movw	r26, r24
	b[id].st[1]=start;
    1554:	fb 01       	movw	r30, r22
    1556:	ee 0f       	add	r30, r30
    1558:	ff 1f       	adc	r31, r31
    155a:	e2 95       	swap	r30
    155c:	f2 95       	swap	r31
    155e:	f0 7f       	andi	r31, 0xF0	; 240
    1560:	fe 27       	eor	r31, r30
    1562:	e0 7f       	andi	r30, 0xF0	; 240
    1564:	fe 27       	eor	r31, r30
    1566:	e4 52       	subi	r30, 0x24	; 36
    1568:	f3 4f       	sbci	r31, 0xF3	; 243
    156a:	93 83       	std	Z+3, r25	; 0x03
    156c:	82 83       	std	Z+2, r24	; 0x02
	b[id].ed[1]=start+1;
    156e:	01 96       	adiw	r24, 0x01	; 1
    1570:	95 87       	std	Z+13, r25	; 0x0d
    1572:	84 87       	std	Z+12, r24	; 0x0c
	b[id].st[2]=start+5;
    1574:	ad 01       	movw	r20, r26
    1576:	4b 5f       	subi	r20, 0xFB	; 251
    1578:	5f 4f       	sbci	r21, 0xFF	; 255
    157a:	55 83       	std	Z+5, r21	; 0x05
    157c:	44 83       	std	Z+4, r20	; 0x04
	b[id].ed[2]=start+6;
    157e:	9d 01       	movw	r18, r26
    1580:	2a 5f       	subi	r18, 0xFA	; 250
    1582:	3f 4f       	sbci	r19, 0xFF	; 255
    1584:	37 87       	std	Z+15, r19	; 0x0f
    1586:	26 87       	std	Z+14, r18	; 0x0e
	b[id].st[3]=start;
    1588:	b7 83       	std	Z+7, r27	; 0x07
    158a:	a6 83       	std	Z+6, r26	; 0x06
	b[id].ed[3]=start+5;
    158c:	51 8b       	std	Z+17, r21	; 0x11
    158e:	40 8b       	std	Z+16, r20	; 0x10
	b[id].st[4]=start+1;
    1590:	91 87       	std	Z+9, r25	; 0x09
    1592:	80 87       	std	Z+8, r24	; 0x08
	b[id].ed[4]=start+6;
    1594:	33 8b       	std	Z+19, r19	; 0x13
    1596:	22 8b       	std	Z+18, r18	; 0x12
	b[id].adj[1]=start;
    1598:	b1 8f       	std	Z+25, r27	; 0x19
    159a:	a0 8f       	std	Z+24, r26	; 0x18
	b[id].adj[2]=start+1;
    159c:	93 8f       	std	Z+27, r25	; 0x1b
    159e:	82 8f       	std	Z+26, r24	; 0x1a
	b[id].adj[3]=start+6;
    15a0:	35 8f       	std	Z+29, r19	; 0x1d
    15a2:	24 8f       	std	Z+28, r18	; 0x1c
	b[id].adj[4]=start+5;
    15a4:	57 8f       	std	Z+31, r21	; 0x1f
    15a6:	46 8f       	std	Z+30, r20	; 0x1e
}
    15a8:	08 95       	ret

000015aa <setPlot>:

void setPlot(void)				// To initalize all plots with their respective paths
{
    15aa:	cf 93       	push	r28
    15ac:	df 93       	push	r29
    int i;
	for(i=1;i<=16;i++)
    15ae:	c1 e0       	ldi	r28, 0x01	; 1
    15b0:	d0 e0       	ldi	r29, 0x00	; 0
	{
		if(i<=4)
    15b2:	c5 30       	cpi	r28, 0x05	; 5
    15b4:	d1 05       	cpc	r29, r1
    15b6:	2c f4       	brge	.+10     	; 0x15c2 <setPlot+0x18>
		{
			setp(i,i);
    15b8:	ce 01       	movw	r24, r28
    15ba:	be 01       	movw	r22, r28
    15bc:	0e 94 a9 0a 	call	0x1552	; 0x1552 <setp>
    15c0:	1a c0       	rjmp	.+52     	; 0x15f6 <setPlot+0x4c>
		}
		else if(i<=8)
    15c2:	c9 30       	cpi	r28, 0x09	; 9
    15c4:	d1 05       	cpc	r29, r1
    15c6:	34 f4       	brge	.+12     	; 0x15d4 <setPlot+0x2a>
		{
			setp(i+1,i);
    15c8:	ce 01       	movw	r24, r28
    15ca:	01 96       	adiw	r24, 0x01	; 1
    15cc:	be 01       	movw	r22, r28
    15ce:	0e 94 a9 0a 	call	0x1552	; 0x1552 <setp>
    15d2:	11 c0       	rjmp	.+34     	; 0x15f6 <setPlot+0x4c>
		}
		else if(i<=12)
    15d4:	cd 30       	cpi	r28, 0x0D	; 13
    15d6:	d1 05       	cpc	r29, r1
    15d8:	34 f4       	brge	.+12     	; 0x15e6 <setPlot+0x3c>
		{
			setp(i+2,i);
    15da:	ce 01       	movw	r24, r28
    15dc:	02 96       	adiw	r24, 0x02	; 2
    15de:	be 01       	movw	r22, r28
    15e0:	0e 94 a9 0a 	call	0x1552	; 0x1552 <setp>
    15e4:	08 c0       	rjmp	.+16     	; 0x15f6 <setPlot+0x4c>
		}
		else if(i<=16)
    15e6:	c1 31       	cpi	r28, 0x11	; 17
    15e8:	d1 05       	cpc	r29, r1
    15ea:	2c f4       	brge	.+10     	; 0x15f6 <setPlot+0x4c>
		{
			setp(i+3,i);
    15ec:	ce 01       	movw	r24, r28
    15ee:	03 96       	adiw	r24, 0x03	; 3
    15f0:	be 01       	movw	r22, r28
    15f2:	0e 94 a9 0a 	call	0x1552	; 0x1552 <setp>
}

void setPlot(void)				// To initalize all plots with their respective paths
{
    int i;
	for(i=1;i<=16;i++)
    15f6:	21 96       	adiw	r28, 0x01	; 1
    15f8:	c1 31       	cpi	r28, 0x11	; 17
    15fa:	d1 05       	cpc	r29, r1
    15fc:	d1 f6       	brne	.-76     	; 0x15b2 <setPlot+0x8>
		else if(i<=16)
		{
			setp(i+3,i);
		}
	}
}
    15fe:	df 91       	pop	r29
    1600:	cf 91       	pop	r28
    1602:	08 95       	ret

00001604 <set_adj_Plots>:

void set_adj_Plots(void)		// To initialize adjacent plots of each node
{
    1604:	2f 92       	push	r2
    1606:	3f 92       	push	r3
    1608:	4f 92       	push	r4
    160a:	5f 92       	push	r5
    160c:	6f 92       	push	r6
    160e:	7f 92       	push	r7
    1610:	8f 92       	push	r8
    1612:	9f 92       	push	r9
    1614:	af 92       	push	r10
    1616:	bf 92       	push	r11
    1618:	cf 92       	push	r12
    161a:	df 92       	push	r13
    161c:	ef 92       	push	r14
    161e:	ff 92       	push	r15
    1620:	0f 93       	push	r16
    1622:	1f 93       	push	r17
    1624:	cf 93       	push	r28
    1626:	df 93       	push	r29
	int i;
	for(i=1;i<=25;i++)
    1628:	ee e1       	ldi	r30, 0x1E	; 30
    162a:	ff e0       	ldi	r31, 0x0F	; 15
		}
	}
}

void set_adj_Plots(void)		// To initialize adjacent plots of each node
{
    162c:	0f 2e       	mov	r0, r31
    162e:	fc ef       	ldi	r31, 0xFC	; 252
    1630:	cf 2e       	mov	r12, r31
    1632:	ff ef       	ldi	r31, 0xFF	; 255
    1634:	df 2e       	mov	r13, r31
    1636:	f0 2d       	mov	r31, r0
    1638:	0f 2e       	mov	r0, r31
    163a:	f8 ef       	ldi	r31, 0xF8	; 248
    163c:	2f 2e       	mov	r2, r31
    163e:	ff ef       	ldi	r31, 0xFF	; 255
    1640:	3f 2e       	mov	r3, r31
    1642:	f0 2d       	mov	r31, r0
    1644:	0f 2e       	mov	r0, r31
    1646:	fd ef       	ldi	r31, 0xFD	; 253
    1648:	4f 2e       	mov	r4, r31
    164a:	ff ef       	ldi	r31, 0xFF	; 255
    164c:	5f 2e       	mov	r5, r31
    164e:	f0 2d       	mov	r31, r0
    1650:	0f 2e       	mov	r0, r31
    1652:	f9 ef       	ldi	r31, 0xF9	; 249
    1654:	6f 2e       	mov	r6, r31
    1656:	ff ef       	ldi	r31, 0xFF	; 255
    1658:	7f 2e       	mov	r7, r31
    165a:	f0 2d       	mov	r31, r0
    165c:	0f 2e       	mov	r0, r31
    165e:	fe ef       	ldi	r31, 0xFE	; 254
    1660:	af 2e       	mov	r10, r31
    1662:	ff ef       	ldi	r31, 0xFF	; 255
    1664:	bf 2e       	mov	r11, r31
    1666:	f0 2d       	mov	r31, r0
    1668:	0f 2e       	mov	r0, r31
    166a:	fa ef       	ldi	r31, 0xFA	; 250
    166c:	8f 2e       	mov	r8, r31
    166e:	ff ef       	ldi	r31, 0xFF	; 255
    1670:	9f 2e       	mov	r9, r31
    1672:	f0 2d       	mov	r31, r0
    1674:	0b ef       	ldi	r16, 0xFB	; 251
    1676:	1f ef       	ldi	r17, 0xFF	; 255
    1678:	ee 24       	eor	r14, r14
    167a:	ea 94       	dec	r14
    167c:	fe 2c       	mov	r15, r14
    167e:	c0 e0       	ldi	r28, 0x00	; 0
    1680:	d0 e0       	ldi	r29, 0x00	; 0
	int i;
	for(i=1;i<=25;i++)
    1682:	21 e0       	ldi	r18, 0x01	; 1
    1684:	30 e0       	ldi	r19, 0x00	; 0
	{
		if(i<=5)
    1686:	26 30       	cpi	r18, 0x06	; 6
    1688:	31 05       	cpc	r19, r1
    168a:	ac f4       	brge	.+42     	; 0x16b6 <set_adj_Plots+0xb2>
		{
			if(i%5==1)
    168c:	c9 01       	movw	r24, r18
    168e:	65 e0       	ldi	r22, 0x05	; 5
    1690:	70 e0       	ldi	r23, 0x00	; 0
    1692:	0e 94 03 1e 	call	0x3c06	; 0x3c06 <__divmodhi4>
    1696:	81 30       	cpi	r24, 0x01	; 1
    1698:	91 05       	cpc	r25, r1
    169a:	19 f4       	brne	.+6      	; 0x16a2 <set_adj_Plots+0x9e>
			{
				n[i].blk[2]=i;
    169c:	33 83       	std	Z+3, r19	; 0x03
    169e:	22 83       	std	Z+2, r18	; 0x02
    16a0:	81 c0       	rjmp	.+258    	; 0x17a4 <set_adj_Plots+0x1a0>
			}
			else if(i%5==0)
    16a2:	00 97       	sbiw	r24, 0x00	; 0
    16a4:	19 f4       	brne	.+6      	; 0x16ac <set_adj_Plots+0xa8>
			{
				n[i].blk[1]=i-1;
    16a6:	d1 83       	std	Z+1, r29	; 0x01
    16a8:	c0 83       	st	Z, r28
    16aa:	7c c0       	rjmp	.+248    	; 0x17a4 <set_adj_Plots+0x1a0>
			}
			else
			{
				n[i].blk[1] = i-1;
    16ac:	d1 83       	std	Z+1, r29	; 0x01
    16ae:	c0 83       	st	Z, r28
				n[i].blk[2] = i;
    16b0:	33 83       	std	Z+3, r19	; 0x03
    16b2:	22 83       	std	Z+2, r18	; 0x02
    16b4:	77 c0       	rjmp	.+238    	; 0x17a4 <set_adj_Plots+0x1a0>
			}
		}
		else if(i<=10)
    16b6:	2b 30       	cpi	r18, 0x0B	; 11
    16b8:	31 05       	cpc	r19, r1
    16ba:	ec f4       	brge	.+58     	; 0x16f6 <set_adj_Plots+0xf2>
		{
			if(i%5==1)
    16bc:	c9 01       	movw	r24, r18
    16be:	65 e0       	ldi	r22, 0x05	; 5
    16c0:	70 e0       	ldi	r23, 0x00	; 0
    16c2:	0e 94 03 1e 	call	0x3c06	; 0x3c06 <__divmodhi4>
    16c6:	81 30       	cpi	r24, 0x01	; 1
    16c8:	91 05       	cpc	r25, r1
    16ca:	29 f4       	brne	.+10     	; 0x16d6 <set_adj_Plots+0xd2>
			{
				n[i].blk[2]=i-1;
    16cc:	d3 83       	std	Z+3, r29	; 0x03
    16ce:	c2 83       	std	Z+2, r28	; 0x02
				n[i].blk[4]=i-5;
    16d0:	d7 82       	std	Z+7, r13	; 0x07
    16d2:	c6 82       	std	Z+6, r12	; 0x06
    16d4:	67 c0       	rjmp	.+206    	; 0x17a4 <set_adj_Plots+0x1a0>
			}
			else if(i%5==0)
    16d6:	00 97       	sbiw	r24, 0x00	; 0
    16d8:	29 f4       	brne	.+10     	; 0x16e4 <set_adj_Plots+0xe0>
			{
				n[i].blk[1]=i-2;
    16da:	f1 82       	std	Z+1, r15	; 0x01
    16dc:	e0 82       	st	Z, r14
				n[i].blk[3]=i-6;
    16de:	15 83       	std	Z+5, r17	; 0x05
    16e0:	04 83       	std	Z+4, r16	; 0x04
    16e2:	60 c0       	rjmp	.+192    	; 0x17a4 <set_adj_Plots+0x1a0>
			}
			else
			{
				n[i].blk[1]=i-2;
    16e4:	f1 82       	std	Z+1, r15	; 0x01
    16e6:	e0 82       	st	Z, r14
				n[i].blk[3]=i-6;
    16e8:	15 83       	std	Z+5, r17	; 0x05
    16ea:	04 83       	std	Z+4, r16	; 0x04
				n[i].blk[2]=i-1;
    16ec:	d3 83       	std	Z+3, r29	; 0x03
    16ee:	c2 83       	std	Z+2, r28	; 0x02
				n[i].blk[4]=i-5;
    16f0:	d7 82       	std	Z+7, r13	; 0x07
    16f2:	c6 82       	std	Z+6, r12	; 0x06
    16f4:	57 c0       	rjmp	.+174    	; 0x17a4 <set_adj_Plots+0x1a0>
			}
		}
		else if(i<=15)
    16f6:	20 31       	cpi	r18, 0x10	; 16
    16f8:	31 05       	cpc	r19, r1
    16fa:	ec f4       	brge	.+58     	; 0x1736 <set_adj_Plots+0x132>
		{
			if(i%5==1)
    16fc:	c9 01       	movw	r24, r18
    16fe:	65 e0       	ldi	r22, 0x05	; 5
    1700:	70 e0       	ldi	r23, 0x00	; 0
    1702:	0e 94 03 1e 	call	0x3c06	; 0x3c06 <__divmodhi4>
    1706:	81 30       	cpi	r24, 0x01	; 1
    1708:	91 05       	cpc	r25, r1
    170a:	29 f4       	brne	.+10     	; 0x1716 <set_adj_Plots+0x112>
			{
				n[i].blk[4]=i-6;
    170c:	17 83       	std	Z+7, r17	; 0x07
    170e:	06 83       	std	Z+6, r16	; 0x06
				n[i].blk[2]=i-2;
    1710:	f3 82       	std	Z+3, r15	; 0x03
    1712:	e2 82       	std	Z+2, r14	; 0x02
    1714:	47 c0       	rjmp	.+142    	; 0x17a4 <set_adj_Plots+0x1a0>
			}
			else if(i%5==0)
    1716:	00 97       	sbiw	r24, 0x00	; 0
    1718:	29 f4       	brne	.+10     	; 0x1724 <set_adj_Plots+0x120>
			{
				n[i].blk[3]=i-7;
    171a:	95 82       	std	Z+5, r9	; 0x05
    171c:	84 82       	std	Z+4, r8	; 0x04
				n[i].blk[1]=i-3;
    171e:	b1 82       	std	Z+1, r11	; 0x01
    1720:	a0 82       	st	Z, r10
    1722:	40 c0       	rjmp	.+128    	; 0x17a4 <set_adj_Plots+0x1a0>
			}
			else
			{
				n[i].blk[4]=i-6;
    1724:	17 83       	std	Z+7, r17	; 0x07
    1726:	06 83       	std	Z+6, r16	; 0x06
				n[i].blk[2]=i-2;
    1728:	f3 82       	std	Z+3, r15	; 0x03
    172a:	e2 82       	std	Z+2, r14	; 0x02
				n[i].blk[3]=i-7;
    172c:	95 82       	std	Z+5, r9	; 0x05
    172e:	84 82       	std	Z+4, r8	; 0x04
				n[i].blk[1]=i-3;
    1730:	b1 82       	std	Z+1, r11	; 0x01
    1732:	a0 82       	st	Z, r10
    1734:	37 c0       	rjmp	.+110    	; 0x17a4 <set_adj_Plots+0x1a0>
			}
		}
		else if(i<=20)
    1736:	25 31       	cpi	r18, 0x15	; 21
    1738:	31 05       	cpc	r19, r1
    173a:	ec f4       	brge	.+58     	; 0x1776 <set_adj_Plots+0x172>
		{
			if(i%5==1)
    173c:	c9 01       	movw	r24, r18
    173e:	65 e0       	ldi	r22, 0x05	; 5
    1740:	70 e0       	ldi	r23, 0x00	; 0
    1742:	0e 94 03 1e 	call	0x3c06	; 0x3c06 <__divmodhi4>
    1746:	81 30       	cpi	r24, 0x01	; 1
    1748:	91 05       	cpc	r25, r1
    174a:	29 f4       	brne	.+10     	; 0x1756 <set_adj_Plots+0x152>
			{
				n[i].blk[4]=i-7;
    174c:	97 82       	std	Z+7, r9	; 0x07
    174e:	86 82       	std	Z+6, r8	; 0x06
				n[i].blk[2]=i-3;
    1750:	b3 82       	std	Z+3, r11	; 0x03
    1752:	a2 82       	std	Z+2, r10	; 0x02
    1754:	27 c0       	rjmp	.+78     	; 0x17a4 <set_adj_Plots+0x1a0>
			}
			else if(i%5==0)
    1756:	00 97       	sbiw	r24, 0x00	; 0
    1758:	29 f4       	brne	.+10     	; 0x1764 <set_adj_Plots+0x160>
			{
				n[i].blk[3]=i-8;
    175a:	75 82       	std	Z+5, r7	; 0x05
    175c:	64 82       	std	Z+4, r6	; 0x04
				n[i].blk[1]=i-4;
    175e:	51 82       	std	Z+1, r5	; 0x01
    1760:	40 82       	st	Z, r4
    1762:	20 c0       	rjmp	.+64     	; 0x17a4 <set_adj_Plots+0x1a0>
			}
			else
			{
				n[i].blk[4]=i-7;
    1764:	97 82       	std	Z+7, r9	; 0x07
    1766:	86 82       	std	Z+6, r8	; 0x06
				n[i].blk[2]=i-3;
    1768:	b3 82       	std	Z+3, r11	; 0x03
    176a:	a2 82       	std	Z+2, r10	; 0x02
				n[i].blk[3]=i-8;
    176c:	75 82       	std	Z+5, r7	; 0x05
    176e:	64 82       	std	Z+4, r6	; 0x04
				n[i].blk[1]=i-4;
    1770:	51 82       	std	Z+1, r5	; 0x01
    1772:	40 82       	st	Z, r4
    1774:	17 c0       	rjmp	.+46     	; 0x17a4 <set_adj_Plots+0x1a0>
			}
		}
		else if(i<=25)
    1776:	2a 31       	cpi	r18, 0x1A	; 26
    1778:	31 05       	cpc	r19, r1
    177a:	a4 f4       	brge	.+40     	; 0x17a4 <set_adj_Plots+0x1a0>
		{
			if(i%5==1)
    177c:	c9 01       	movw	r24, r18
    177e:	65 e0       	ldi	r22, 0x05	; 5
    1780:	70 e0       	ldi	r23, 0x00	; 0
    1782:	0e 94 03 1e 	call	0x3c06	; 0x3c06 <__divmodhi4>
    1786:	81 30       	cpi	r24, 0x01	; 1
    1788:	91 05       	cpc	r25, r1
    178a:	19 f4       	brne	.+6      	; 0x1792 <set_adj_Plots+0x18e>
			{
				n[i].blk[4]=i-8;
    178c:	77 82       	std	Z+7, r7	; 0x07
    178e:	66 82       	std	Z+6, r6	; 0x06
    1790:	09 c0       	rjmp	.+18     	; 0x17a4 <set_adj_Plots+0x1a0>
			}
			else if(i%5==0)
    1792:	00 97       	sbiw	r24, 0x00	; 0
    1794:	19 f4       	brne	.+6      	; 0x179c <set_adj_Plots+0x198>
			{
				n[i].blk[3]=i-9;
    1796:	35 82       	std	Z+5, r3	; 0x05
    1798:	24 82       	std	Z+4, r2	; 0x04
    179a:	04 c0       	rjmp	.+8      	; 0x17a4 <set_adj_Plots+0x1a0>
			}
			else
			{
				n[i].blk[4]=i-8;
    179c:	77 82       	std	Z+7, r7	; 0x07
    179e:	66 82       	std	Z+6, r6	; 0x06
				n[i].blk[3]=i-9;
    17a0:	35 82       	std	Z+5, r3	; 0x05
    17a2:	24 82       	std	Z+4, r2	; 0x04
}

void set_adj_Plots(void)		// To initialize adjacent plots of each node
{
	int i;
	for(i=1;i<=25;i++)
    17a4:	2f 5f       	subi	r18, 0xFF	; 255
    17a6:	3f 4f       	sbci	r19, 0xFF	; 255
    17a8:	21 96       	adiw	r28, 0x01	; 1
    17aa:	76 96       	adiw	r30, 0x16	; 22
    17ac:	08 94       	sec
    17ae:	e1 1c       	adc	r14, r1
    17b0:	f1 1c       	adc	r15, r1
    17b2:	0f 5f       	subi	r16, 0xFF	; 255
    17b4:	1f 4f       	sbci	r17, 0xFF	; 255
    17b6:	08 94       	sec
    17b8:	81 1c       	adc	r8, r1
    17ba:	91 1c       	adc	r9, r1
    17bc:	08 94       	sec
    17be:	a1 1c       	adc	r10, r1
    17c0:	b1 1c       	adc	r11, r1
    17c2:	08 94       	sec
    17c4:	61 1c       	adc	r6, r1
    17c6:	71 1c       	adc	r7, r1
    17c8:	08 94       	sec
    17ca:	41 1c       	adc	r4, r1
    17cc:	51 1c       	adc	r5, r1
    17ce:	08 94       	sec
    17d0:	21 1c       	adc	r2, r1
    17d2:	31 1c       	adc	r3, r1
    17d4:	08 94       	sec
    17d6:	c1 1c       	adc	r12, r1
    17d8:	d1 1c       	adc	r13, r1
    17da:	2a 31       	cpi	r18, 0x1A	; 26
    17dc:	31 05       	cpc	r19, r1
    17de:	09 f0       	breq	.+2      	; 0x17e2 <set_adj_Plots+0x1de>
    17e0:	52 cf       	rjmp	.-348    	; 0x1686 <set_adj_Plots+0x82>
				n[i].blk[4]=i-8;
				n[i].blk[3]=i-9;
			}
		}
	}
}
    17e2:	df 91       	pop	r29
    17e4:	cf 91       	pop	r28
    17e6:	1f 91       	pop	r17
    17e8:	0f 91       	pop	r16
    17ea:	ff 90       	pop	r15
    17ec:	ef 90       	pop	r14
    17ee:	df 90       	pop	r13
    17f0:	cf 90       	pop	r12
    17f2:	bf 90       	pop	r11
    17f4:	af 90       	pop	r10
    17f6:	9f 90       	pop	r9
    17f8:	8f 90       	pop	r8
    17fa:	7f 90       	pop	r7
    17fc:	6f 90       	pop	r6
    17fe:	5f 90       	pop	r5
    1800:	4f 90       	pop	r4
    1802:	3f 90       	pop	r3
    1804:	2f 90       	pop	r2
    1806:	08 95       	ret

00001808 <set_adj_node>:

void set_adj_node(void)			// To initialize adjacent nodes of each node
{
    1808:	6f 92       	push	r6
    180a:	7f 92       	push	r7
    180c:	8f 92       	push	r8
    180e:	9f 92       	push	r9
    1810:	af 92       	push	r10
    1812:	bf 92       	push	r11
    1814:	cf 92       	push	r12
    1816:	df 92       	push	r13
    1818:	ef 92       	push	r14
    181a:	ff 92       	push	r15
    181c:	0f 93       	push	r16
    181e:	1f 93       	push	r17
    1820:	cf 93       	push	r28
    1822:	df 93       	push	r29
    1824:	0f 2e       	mov	r0, r31
    1826:	f4 ed       	ldi	r31, 0xD4	; 212
    1828:	af 2e       	mov	r10, r31
    182a:	f7 e1       	ldi	r31, 0x17	; 23
    182c:	bf 2e       	mov	r11, r31
    182e:	f0 2d       	mov	r31, r0
    1830:	0f 2e       	mov	r0, r31
    1832:	f6 e1       	ldi	r31, 0x16	; 22
    1834:	cf 2e       	mov	r12, r31
    1836:	ff e0       	ldi	r31, 0x0F	; 15
    1838:	df 2e       	mov	r13, r31
    183a:	f0 2d       	mov	r31, r0
    183c:	c2 e0       	ldi	r28, 0x02	; 2
    183e:	d0 e0       	ldi	r29, 0x00	; 0
    1840:	ee 24       	eor	r14, r14
    1842:	ff 24       	eor	r15, r15
    1844:	e3 94       	inc	r14
    1846:	00 e0       	ldi	r16, 0x00	; 0
    1848:	10 e0       	ldi	r17, 0x00	; 0
		}
		if(i<=20)
		{
			n[i].adjn[2]=i+5;
		}
		if((i%5 != 1) && ((i-1) > 0))
    184a:	0f 2e       	mov	r0, r31
    184c:	f5 e0       	ldi	r31, 0x05	; 5
    184e:	8f 2e       	mov	r8, r31
    1850:	99 24       	eor	r9, r9
    1852:	f0 2d       	mov	r31, r0
	
	for(i=1;i<=25;i++)
	{
		if(i>5)
		{
			n[i].adjn[1]=i-5;
    1854:	0f 2e       	mov	r0, r31
    1856:	fc ef       	ldi	r31, 0xFC	; 252
    1858:	6f 2e       	mov	r6, r31
    185a:	fe e0       	ldi	r31, 0x0E	; 14
    185c:	7f 2e       	mov	r7, r31
    185e:	f0 2d       	mov	r31, r0
    1860:	2a c0       	rjmp	.+84     	; 0x18b6 <set_adj_node+0xae>
{
    int i;
	
	for(i=1;i<=25;i++)
	{
		if(i>5)
    1862:	46 30       	cpi	r20, 0x06	; 6
    1864:	51 05       	cpc	r21, r1
    1866:	cc f0       	brlt	.+50     	; 0x189a <set_adj_node+0x92>
		{
			n[i].adjn[1]=i-5;
    1868:	ca 01       	movw	r24, r20
    186a:	88 0f       	add	r24, r24
    186c:	99 1f       	adc	r25, r25
    186e:	84 0f       	add	r24, r20
    1870:	95 1f       	adc	r25, r21
    1872:	9c 01       	movw	r18, r24
    1874:	22 0f       	add	r18, r18
    1876:	33 1f       	adc	r19, r19
    1878:	22 0f       	add	r18, r18
    187a:	33 1f       	adc	r19, r19
    187c:	22 0f       	add	r18, r18
    187e:	33 1f       	adc	r19, r19
    1880:	b9 01       	movw	r22, r18
    1882:	68 1b       	sub	r22, r24
    1884:	79 0b       	sbc	r23, r25
    1886:	cb 01       	movw	r24, r22
    1888:	84 0f       	add	r24, r20
    188a:	95 1f       	adc	r25, r21
    188c:	f3 01       	movw	r30, r6
    188e:	e8 0f       	add	r30, r24
    1890:	f9 1f       	adc	r31, r25
			}
		}
	}
}

void set_adj_node(void)			// To initialize adjacent nodes of each node
    1892:	c8 01       	movw	r24, r16
    1894:	03 97       	sbiw	r24, 0x03	; 3
	
	for(i=1;i<=25;i++)
	{
		if(i>5)
		{
			n[i].adjn[1]=i-5;
    1896:	93 83       	std	Z+3, r25	; 0x03
    1898:	82 83       	std	Z+2, r24	; 0x02
    189a:	0f 5f       	subi	r16, 0xFF	; 255
    189c:	1f 4f       	sbci	r17, 0xFF	; 255
    189e:	08 94       	sec
    18a0:	e1 1c       	adc	r14, r1
    18a2:	f1 1c       	adc	r15, r1
    18a4:	21 96       	adiw	r28, 0x01	; 1
    18a6:	82 e0       	ldi	r24, 0x02	; 2
    18a8:	90 e0       	ldi	r25, 0x00	; 0
    18aa:	a8 0e       	add	r10, r24
    18ac:	b9 1e       	adc	r11, r25
    18ae:	e6 e1       	ldi	r30, 0x16	; 22
    18b0:	f0 e0       	ldi	r31, 0x00	; 0
    18b2:	ce 0e       	add	r12, r30
    18b4:	df 1e       	adc	r13, r31
    18b6:	97 01       	movw	r18, r14
		}
		if(i<=20)
    18b8:	f5 e1       	ldi	r31, 0x15	; 21
    18ba:	ef 16       	cp	r14, r31
    18bc:	f1 04       	cpc	r15, r1
    18be:	2c f4       	brge	.+10     	; 0x18ca <set_adj_node+0xc2>
			}
		}
	}
}

void set_adj_node(void)			// To initialize adjacent nodes of each node
    18c0:	c8 01       	movw	r24, r16
    18c2:	06 96       	adiw	r24, 0x06	; 6
		{
			n[i].adjn[1]=i-5;
		}
		if(i<=20)
		{
			n[i].adjn[2]=i+5;
    18c4:	f6 01       	movw	r30, r12
    18c6:	91 83       	std	Z+1, r25	; 0x01
    18c8:	80 83       	st	Z, r24
		}
		if((i%5 != 1) && ((i-1) > 0))
    18ca:	c9 01       	movw	r24, r18
    18cc:	b4 01       	movw	r22, r8
    18ce:	0e 94 03 1e 	call	0x3c06	; 0x3c06 <__divmodhi4>
    18d2:	81 30       	cpi	r24, 0x01	; 1
    18d4:	91 05       	cpc	r25, r1
    18d6:	41 f0       	breq	.+16     	; 0x18e8 <set_adj_node+0xe0>
    18d8:	10 16       	cp	r1, r16
    18da:	11 06       	cpc	r1, r17
    18dc:	1c f4       	brge	.+6      	; 0x18e4 <set_adj_node+0xdc>
		{
			n[i].adjn[3]=i-1;
    18de:	f6 01       	movw	r30, r12
    18e0:	13 83       	std	Z+3, r17	; 0x03
    18e2:	02 83       	std	Z+2, r16	; 0x02
		}
		if((i%5 != 0) && ((i+1) <= 25))
    18e4:	00 97       	sbiw	r24, 0x00	; 0
    18e6:	59 f0       	breq	.+22     	; 0x18fe <set_adj_node+0xf6>
    18e8:	ae 01       	movw	r20, r28
    18ea:	ca 31       	cpi	r28, 0x1A	; 26
    18ec:	d1 05       	cpc	r29, r1
    18ee:	84 f4       	brge	.+32     	; 0x1910 <set_adj_node+0x108>
		{
			n[i].adjn[4]=i+1;
    18f0:	f6 01       	movw	r30, r12
    18f2:	d5 83       	std	Z+5, r29	; 0x05
    18f4:	c4 83       	std	Z+4, r28	; 0x04
		}
		v[i]=0;
    18f6:	f5 01       	movw	r30, r10
    18f8:	11 82       	std	Z+1, r1	; 0x01
    18fa:	10 82       	st	Z, r1
    18fc:	b2 cf       	rjmp	.-156    	; 0x1862 <set_adj_node+0x5a>
    18fe:	f5 01       	movw	r30, r10
    1900:	11 82       	std	Z+1, r1	; 0x01
    1902:	10 82       	st	Z, r1

void set_adj_node(void)			// To initialize adjacent nodes of each node
{
    int i;
	
	for(i=1;i<=25;i++)
    1904:	ae 01       	movw	r20, r28
    1906:	ca 31       	cpi	r28, 0x1A	; 26
    1908:	d1 05       	cpc	r29, r1
    190a:	0c f4       	brge	.+2      	; 0x190e <set_adj_node+0x106>
    190c:	aa cf       	rjmp	.-172    	; 0x1862 <set_adj_node+0x5a>
    190e:	07 c0       	rjmp	.+14     	; 0x191e <set_adj_node+0x116>
		}
		if((i%5 != 0) && ((i+1) <= 25))
		{
			n[i].adjn[4]=i+1;
		}
		v[i]=0;
    1910:	f9 01       	movw	r30, r18
    1912:	ee 0f       	add	r30, r30
    1914:	ff 1f       	adc	r31, r31
    1916:	ee 52       	subi	r30, 0x2E	; 46
    1918:	f8 4e       	sbci	r31, 0xE8	; 232
    191a:	11 82       	std	Z+1, r1	; 0x01
    191c:	10 82       	st	Z, r1
	}
}
    191e:	df 91       	pop	r29
    1920:	cf 91       	pop	r28
    1922:	1f 91       	pop	r17
    1924:	0f 91       	pop	r16
    1926:	ff 90       	pop	r15
    1928:	ef 90       	pop	r14
    192a:	df 90       	pop	r13
    192c:	cf 90       	pop	r12
    192e:	bf 90       	pop	r11
    1930:	af 90       	pop	r10
    1932:	9f 90       	pop	r9
    1934:	8f 90       	pop	r8
    1936:	7f 90       	pop	r7
    1938:	6f 90       	pop	r6
    193a:	08 95       	ret

0000193c <get_dir>:

int get_dir(int cnode,int nnode) // To get the direction of nnode fron cnode
{
	switch(crrt_dir)
    193c:	20 91 4a 07 	lds	r18, 0x074A
    1940:	30 91 4b 07 	lds	r19, 0x074B
    1944:	22 30       	cpi	r18, 0x02	; 2
    1946:	31 05       	cpc	r19, r1
    1948:	d1 f1       	breq	.+116    	; 0x19be <get_dir+0x82>
    194a:	23 30       	cpi	r18, 0x03	; 3
    194c:	31 05       	cpc	r19, r1
    194e:	2c f4       	brge	.+10     	; 0x195a <get_dir+0x1e>
    1950:	21 30       	cpi	r18, 0x01	; 1
    1952:	31 05       	cpc	r19, r1
    1954:	09 f0       	breq	.+2      	; 0x1958 <get_dir+0x1c>
    1956:	ae c0       	rjmp	.+348    	; 0x1ab4 <get_dir+0x178>
    1958:	09 c0       	rjmp	.+18     	; 0x196c <get_dir+0x30>
    195a:	23 30       	cpi	r18, 0x03	; 3
    195c:	31 05       	cpc	r19, r1
    195e:	09 f4       	brne	.+2      	; 0x1962 <get_dir+0x26>
    1960:	57 c0       	rjmp	.+174    	; 0x1a10 <get_dir+0xd4>
    1962:	24 30       	cpi	r18, 0x04	; 4
    1964:	31 05       	cpc	r19, r1
    1966:	09 f0       	breq	.+2      	; 0x196a <get_dir+0x2e>
    1968:	a5 c0       	rjmp	.+330    	; 0x1ab4 <get_dir+0x178>
    196a:	7c c0       	rjmp	.+248    	; 0x1a64 <get_dir+0x128>
	{
		case 1:
		switch(cnode-nnode)
    196c:	86 1b       	sub	r24, r22
    196e:	97 0b       	sbc	r25, r23
    1970:	2f ef       	ldi	r18, 0xFF	; 255
    1972:	8f 3f       	cpi	r24, 0xFF	; 255
    1974:	92 07       	cpc	r25, r18
    1976:	d1 f0       	breq	.+52     	; 0x19ac <get_dir+0x70>
    1978:	81 30       	cpi	r24, 0x01	; 1
    197a:	91 05       	cpc	r25, r1
    197c:	71 f0       	breq	.+28     	; 0x199a <get_dir+0x5e>
    197e:	2f ef       	ldi	r18, 0xFF	; 255
    1980:	8b 3f       	cpi	r24, 0xFB	; 251
    1982:	92 07       	cpc	r25, r18
    1984:	09 f0       	breq	.+2      	; 0x1988 <get_dir+0x4c>
    1986:	99 c0       	rjmp	.+306    	; 0x1aba <get_dir+0x17e>
		{
			case 5:return 0;
			break;
			case -5:crrt_dir = 2;return 180;
    1988:	82 e0       	ldi	r24, 0x02	; 2
    198a:	90 e0       	ldi	r25, 0x00	; 0
    198c:	90 93 4b 07 	sts	0x074B, r25
    1990:	80 93 4a 07 	sts	0x074A, r24
    1994:	84 eb       	ldi	r24, 0xB4	; 180
    1996:	90 e0       	ldi	r25, 0x00	; 0
    1998:	08 95       	ret
			break;
			case 1:crrt_dir = 3;return 270;
    199a:	83 e0       	ldi	r24, 0x03	; 3
    199c:	90 e0       	ldi	r25, 0x00	; 0
    199e:	90 93 4b 07 	sts	0x074B, r25
    19a2:	80 93 4a 07 	sts	0x074A, r24
    19a6:	8e e0       	ldi	r24, 0x0E	; 14
    19a8:	91 e0       	ldi	r25, 0x01	; 1
    19aa:	08 95       	ret
			break;
			case -1:crrt_dir = 4;return 90;
    19ac:	84 e0       	ldi	r24, 0x04	; 4
    19ae:	90 e0       	ldi	r25, 0x00	; 0
    19b0:	90 93 4b 07 	sts	0x074B, r25
    19b4:	80 93 4a 07 	sts	0x074A, r24
    19b8:	8a e5       	ldi	r24, 0x5A	; 90
    19ba:	90 e0       	ldi	r25, 0x00	; 0
    19bc:	08 95       	ret
			break;
			default:return 0;
		}
		break;
		case 2:
		switch(cnode-nnode)
    19be:	86 1b       	sub	r24, r22
    19c0:	97 0b       	sbc	r25, r23
    19c2:	81 30       	cpi	r24, 0x01	; 1
    19c4:	91 05       	cpc	r25, r1
    19c6:	91 f0       	breq	.+36     	; 0x19ec <get_dir+0xb0>
    19c8:	85 30       	cpi	r24, 0x05	; 5
    19ca:	91 05       	cpc	r25, r1
    19cc:	31 f0       	breq	.+12     	; 0x19da <get_dir+0x9e>
    19ce:	2f ef       	ldi	r18, 0xFF	; 255
    19d0:	8f 3f       	cpi	r24, 0xFF	; 255
    19d2:	92 07       	cpc	r25, r18
    19d4:	09 f0       	breq	.+2      	; 0x19d8 <get_dir+0x9c>
    19d6:	74 c0       	rjmp	.+232    	; 0x1ac0 <get_dir+0x184>
    19d8:	12 c0       	rjmp	.+36     	; 0x19fe <get_dir+0xc2>
		{
			case 5:crrt_dir = 1;return 180;
    19da:	81 e0       	ldi	r24, 0x01	; 1
    19dc:	90 e0       	ldi	r25, 0x00	; 0
    19de:	90 93 4b 07 	sts	0x074B, r25
    19e2:	80 93 4a 07 	sts	0x074A, r24
    19e6:	84 eb       	ldi	r24, 0xB4	; 180
    19e8:	90 e0       	ldi	r25, 0x00	; 0
    19ea:	08 95       	ret
			break;
			case -5:return 0;
			break;
			case 1:crrt_dir = 3;return 90;
    19ec:	83 e0       	ldi	r24, 0x03	; 3
    19ee:	90 e0       	ldi	r25, 0x00	; 0
    19f0:	90 93 4b 07 	sts	0x074B, r25
    19f4:	80 93 4a 07 	sts	0x074A, r24
    19f8:	8a e5       	ldi	r24, 0x5A	; 90
    19fa:	90 e0       	ldi	r25, 0x00	; 0
    19fc:	08 95       	ret
			break;
			case -1:crrt_dir = 4;return 270;
    19fe:	84 e0       	ldi	r24, 0x04	; 4
    1a00:	90 e0       	ldi	r25, 0x00	; 0
    1a02:	90 93 4b 07 	sts	0x074B, r25
    1a06:	80 93 4a 07 	sts	0x074A, r24
    1a0a:	8e e0       	ldi	r24, 0x0E	; 14
    1a0c:	91 e0       	ldi	r25, 0x01	; 1
    1a0e:	08 95       	ret
			break;
			default:return 0;
		}
		break;
		case 3:
		switch(cnode-nnode)
    1a10:	86 1b       	sub	r24, r22
    1a12:	97 0b       	sbc	r25, r23
    1a14:	2f ef       	ldi	r18, 0xFF	; 255
    1a16:	8f 3f       	cpi	r24, 0xFF	; 255
    1a18:	92 07       	cpc	r25, r18
    1a1a:	d9 f0       	breq	.+54     	; 0x1a52 <get_dir+0x116>
    1a1c:	85 30       	cpi	r24, 0x05	; 5
    1a1e:	91 05       	cpc	r25, r1
    1a20:	31 f0       	breq	.+12     	; 0x1a2e <get_dir+0xf2>
    1a22:	2f ef       	ldi	r18, 0xFF	; 255
    1a24:	8b 3f       	cpi	r24, 0xFB	; 251
    1a26:	92 07       	cpc	r25, r18
    1a28:	09 f0       	breq	.+2      	; 0x1a2c <get_dir+0xf0>
    1a2a:	4d c0       	rjmp	.+154    	; 0x1ac6 <get_dir+0x18a>
    1a2c:	09 c0       	rjmp	.+18     	; 0x1a40 <get_dir+0x104>
		{
			case 5:crrt_dir = 1;return 90;
    1a2e:	81 e0       	ldi	r24, 0x01	; 1
    1a30:	90 e0       	ldi	r25, 0x00	; 0
    1a32:	90 93 4b 07 	sts	0x074B, r25
    1a36:	80 93 4a 07 	sts	0x074A, r24
    1a3a:	8a e5       	ldi	r24, 0x5A	; 90
    1a3c:	90 e0       	ldi	r25, 0x00	; 0
    1a3e:	08 95       	ret
			break;
			case -5:crrt_dir = 2;return 270;
    1a40:	82 e0       	ldi	r24, 0x02	; 2
    1a42:	90 e0       	ldi	r25, 0x00	; 0
    1a44:	90 93 4b 07 	sts	0x074B, r25
    1a48:	80 93 4a 07 	sts	0x074A, r24
    1a4c:	8e e0       	ldi	r24, 0x0E	; 14
    1a4e:	91 e0       	ldi	r25, 0x01	; 1
    1a50:	08 95       	ret
			break;
			case 1:return 0;
			break;
			case -1:crrt_dir = 4;return 180;
    1a52:	84 e0       	ldi	r24, 0x04	; 4
    1a54:	90 e0       	ldi	r25, 0x00	; 0
    1a56:	90 93 4b 07 	sts	0x074B, r25
    1a5a:	80 93 4a 07 	sts	0x074A, r24
    1a5e:	84 eb       	ldi	r24, 0xB4	; 180
    1a60:	90 e0       	ldi	r25, 0x00	; 0
    1a62:	08 95       	ret
			break;
			default:return 0;
		}
		break;
		case 4:
		switch(cnode-nnode)
    1a64:	86 1b       	sub	r24, r22
    1a66:	97 0b       	sbc	r25, r23
    1a68:	81 30       	cpi	r24, 0x01	; 1
    1a6a:	91 05       	cpc	r25, r1
    1a6c:	d1 f0       	breq	.+52     	; 0x1aa2 <get_dir+0x166>
    1a6e:	85 30       	cpi	r24, 0x05	; 5
    1a70:	91 05       	cpc	r25, r1
    1a72:	29 f0       	breq	.+10     	; 0x1a7e <get_dir+0x142>
    1a74:	2f ef       	ldi	r18, 0xFF	; 255
    1a76:	8b 3f       	cpi	r24, 0xFB	; 251
    1a78:	92 07       	cpc	r25, r18
    1a7a:	41 f5       	brne	.+80     	; 0x1acc <get_dir+0x190>
    1a7c:	09 c0       	rjmp	.+18     	; 0x1a90 <get_dir+0x154>
		{
			case 5:crrt_dir = 1;return 270;
    1a7e:	81 e0       	ldi	r24, 0x01	; 1
    1a80:	90 e0       	ldi	r25, 0x00	; 0
    1a82:	90 93 4b 07 	sts	0x074B, r25
    1a86:	80 93 4a 07 	sts	0x074A, r24
    1a8a:	8e e0       	ldi	r24, 0x0E	; 14
    1a8c:	91 e0       	ldi	r25, 0x01	; 1
    1a8e:	08 95       	ret
			break;
			case -5:crrt_dir = 2;return 90;
    1a90:	82 e0       	ldi	r24, 0x02	; 2
    1a92:	90 e0       	ldi	r25, 0x00	; 0
    1a94:	90 93 4b 07 	sts	0x074B, r25
    1a98:	80 93 4a 07 	sts	0x074A, r24
    1a9c:	8a e5       	ldi	r24, 0x5A	; 90
    1a9e:	90 e0       	ldi	r25, 0x00	; 0
    1aa0:	08 95       	ret
			break;
			case 1:crrt_dir = 3;return 180;
    1aa2:	83 e0       	ldi	r24, 0x03	; 3
    1aa4:	90 e0       	ldi	r25, 0x00	; 0
    1aa6:	90 93 4b 07 	sts	0x074B, r25
    1aaa:	80 93 4a 07 	sts	0x074A, r24
    1aae:	84 eb       	ldi	r24, 0xB4	; 180
    1ab0:	90 e0       	ldi	r25, 0x00	; 0
    1ab2:	08 95       	ret
		break;
		default:
		break;
	}
	
	return 0;
    1ab4:	80 e0       	ldi	r24, 0x00	; 0
    1ab6:	90 e0       	ldi	r25, 0x00	; 0
    1ab8:	08 95       	ret
	switch(crrt_dir)
	{
		case 1:
		switch(cnode-nnode)
		{
			case 5:return 0;
    1aba:	80 e0       	ldi	r24, 0x00	; 0
    1abc:	90 e0       	ldi	r25, 0x00	; 0
    1abe:	08 95       	ret
		case 2:
		switch(cnode-nnode)
		{
			case 5:crrt_dir = 1;return 180;
			break;
			case -5:return 0;
    1ac0:	80 e0       	ldi	r24, 0x00	; 0
    1ac2:	90 e0       	ldi	r25, 0x00	; 0
    1ac4:	08 95       	ret
		{
			case 5:crrt_dir = 1;return 90;
			break;
			case -5:crrt_dir = 2;return 270;
			break;
			case 1:return 0;
    1ac6:	80 e0       	ldi	r24, 0x00	; 0
    1ac8:	90 e0       	ldi	r25, 0x00	; 0
    1aca:	08 95       	ret
			break;
			case -5:crrt_dir = 2;return 90;
			break;
			case 1:crrt_dir = 3;return 180;
			break;
			case -1:return 0;
    1acc:	80 e0       	ldi	r24, 0x00	; 0
    1ace:	90 e0       	ldi	r25, 0x00	; 0
		default:
		break;
	}
	
	return 0;
}
    1ad0:	08 95       	ret

00001ad2 <turn>:

void turn(int crtnode,int nxtnode)		//to turn the bot towards nxtnode from crtnode
{
	int deg = get_dir(crtnode,nxtnode);
    1ad2:	0e 94 9e 0c 	call	0x193c	; 0x193c <get_dir>

	switch(deg)
    1ad6:	84 3b       	cpi	r24, 0xB4	; 180
    1ad8:	91 05       	cpc	r25, r1
    1ada:	61 f0       	breq	.+24     	; 0x1af4 <turn+0x22>
    1adc:	21 e0       	ldi	r18, 0x01	; 1
    1ade:	8e 30       	cpi	r24, 0x0E	; 14
    1ae0:	92 07       	cpc	r25, r18
    1ae2:	69 f0       	breq	.+26     	; 0x1afe <turn+0x2c>
    1ae4:	8a 35       	cpi	r24, 0x5A	; 90
    1ae6:	91 05       	cpc	r25, r1
    1ae8:	71 f4       	brne	.+28     	; 0x1b06 <turn+0x34>
	{
		case 0:
		break;
		case 90:
		rotate_right(90);
    1aea:	8a e5       	ldi	r24, 0x5A	; 90
    1aec:	90 e0       	ldi	r25, 0x00	; 0
    1aee:	0e 94 19 06 	call	0xc32	; 0xc32 <rotate_right>
		break;
    1af2:	08 95       	ret
		case 180:
		rotate_right(180);
    1af4:	84 eb       	ldi	r24, 0xB4	; 180
    1af6:	90 e0       	ldi	r25, 0x00	; 0
    1af8:	0e 94 19 06 	call	0xc32	; 0xc32 <rotate_right>
		break;
    1afc:	08 95       	ret
		case 270:
		rotate_left(90);
    1afe:	8a e5       	ldi	r24, 0x5A	; 90
    1b00:	90 e0       	ldi	r25, 0x00	; 0
    1b02:	0e 94 3c 06 	call	0xc78	; 0xc78 <rotate_left>
    1b06:	08 95       	ret

00001b08 <go1>:
	crt_node=bn;
	path[an][bn]=path[bn][an]=1;
}

void go1(int crtnode, int nxtnode)	// To move the bot from crtnode to nxtnode
{		
    1b08:	0f 93       	push	r16
    1b0a:	1f 93       	push	r17
    1b0c:	cf 93       	push	r28
    1b0e:	df 93       	push	r29
    1b10:	8c 01       	movw	r16, r24
    1b12:	eb 01       	movw	r28, r22
	send(50,crtnode,nxtnode);
    1b14:	82 e3       	ldi	r24, 0x32	; 50
    1b16:	90 e0       	ldi	r25, 0x00	; 0
    1b18:	b8 01       	movw	r22, r16
    1b1a:	ae 01       	movw	r20, r28
    1b1c:	0e 94 69 01 	call	0x2d2	; 0x2d2 <send>
	
	turn(crtnode,nxtnode);	
    1b20:	c8 01       	movw	r24, r16
    1b22:	be 01       	movw	r22, r28
    1b24:	0e 94 69 0d 	call	0x1ad2	; 0x1ad2 <turn>
	
	path_node(1);
    1b28:	81 e0       	ldi	r24, 0x01	; 1
    1b2a:	90 e0       	ldi	r25, 0x00	; 0
    1b2c:	0e 94 be 05 	call	0xb7c	; 0xb7c <path_node>
	path_node(1);
    1b30:	81 e0       	ldi	r24, 0x01	; 1
    1b32:	90 e0       	ldi	r25, 0x00	; 0
    1b34:	0e 94 be 05 	call	0xb7c	; 0xb7c <path_node>
	
	crt_node = nxtnode;
    1b38:	d0 93 4d 07 	sts	0x074D, r29
    1b3c:	c0 93 4c 07 	sts	0x074C, r28
	
	//send(50,crt_node,0);	// position flag		
}
    1b40:	df 91       	pop	r29
    1b42:	cf 91       	pop	r28
    1b44:	1f 91       	pop	r17
    1b46:	0f 91       	pop	r16
    1b48:	08 95       	ret

00001b4a <detect_block>:
		break;
	}
}

int detect_block(int c_node,int n_node)		// To detect black debris and updating the midpoint(ob)
{
    1b4a:	0f 93       	push	r16
    1b4c:	1f 93       	push	r17
    1b4e:	cf 93       	push	r28
    1b50:	df 93       	push	r29
    1b52:	8c 01       	movw	r16, r24
    1b54:	eb 01       	movw	r28, r22
    1b56:	8f ef       	ldi	r24, 0xFF	; 255
    1b58:	9f e7       	ldi	r25, 0x7F	; 127
    1b5a:	a4 e0       	ldi	r26, 0x04	; 4
    1b5c:	81 50       	subi	r24, 0x01	; 1
    1b5e:	90 40       	sbci	r25, 0x00	; 0
    1b60:	a0 40       	sbci	r26, 0x00	; 0
    1b62:	e1 f7       	brne	.-8      	; 0x1b5c <detect_block+0x12>
    1b64:	00 c0       	rjmp	.+0      	; 0x1b66 <detect_block+0x1c>
    1b66:	00 00       	nop
	int retv=0;
	_delay_ms(100);
	int temp = detect_obstacle(80,220);
    1b68:	80 e5       	ldi	r24, 0x50	; 80
    1b6a:	90 e0       	ldi	r25, 0x00	; 0
    1b6c:	6c ed       	ldi	r22, 0xDC	; 220
    1b6e:	70 e0       	ldi	r23, 0x00	; 0
    1b70:	0e 94 6b 03 	call	0x6d6	; 0x6d6 <detect_obstacle>
	
	if(temp)
    1b74:	00 97       	sbiw	r24, 0x00	; 0
    1b76:	49 f1       	breq	.+82     	; 0x1bca <detect_block+0x80>
	{
		cost[c_node][n_node]=IN;
    1b78:	4a e1       	ldi	r20, 0x1A	; 26
    1b7a:	50 e0       	ldi	r21, 0x00	; 0
    1b7c:	04 9f       	mul	r16, r20
    1b7e:	f0 01       	movw	r30, r0
    1b80:	05 9f       	mul	r16, r21
    1b82:	f0 0d       	add	r31, r0
    1b84:	14 9f       	mul	r17, r20
    1b86:	f0 0d       	add	r31, r0
    1b88:	11 24       	eor	r1, r1
    1b8a:	ec 0f       	add	r30, r28
    1b8c:	fd 1f       	adc	r31, r29
    1b8e:	60 e0       	ldi	r22, 0x00	; 0
    1b90:	72 e0       	ldi	r23, 0x02	; 2
    1b92:	ee 0f       	add	r30, r30
    1b94:	ff 1f       	adc	r31, r31
    1b96:	e6 0f       	add	r30, r22
    1b98:	f7 1f       	adc	r31, r23
    1b9a:	23 e6       	ldi	r18, 0x63	; 99
    1b9c:	30 e0       	ldi	r19, 0x00	; 0
    1b9e:	31 83       	std	Z+1, r19	; 0x01
    1ba0:	20 83       	st	Z, r18
		cost[n_node][c_node]=IN;
    1ba2:	c4 9f       	mul	r28, r20
    1ba4:	c0 01       	movw	r24, r0
    1ba6:	c5 9f       	mul	r28, r21
    1ba8:	90 0d       	add	r25, r0
    1baa:	d4 9f       	mul	r29, r20
    1bac:	90 0d       	add	r25, r0
    1bae:	11 24       	eor	r1, r1
    1bb0:	80 0f       	add	r24, r16
    1bb2:	91 1f       	adc	r25, r17
    1bb4:	88 0f       	add	r24, r24
    1bb6:	99 1f       	adc	r25, r25
    1bb8:	68 0f       	add	r22, r24
    1bba:	79 1f       	adc	r23, r25
    1bbc:	db 01       	movw	r26, r22
    1bbe:	11 96       	adiw	r26, 0x01	; 1
    1bc0:	3c 93       	st	X, r19
    1bc2:	2e 93       	st	-X, r18
		retv=1;
    1bc4:	81 e0       	ldi	r24, 0x01	; 1
    1bc6:	90 e0       	ldi	r25, 0x00	; 0
    1bc8:	02 c0       	rjmp	.+4      	; 0x1bce <detect_block+0x84>
	}
}

int detect_block(int c_node,int n_node)		// To detect black debris and updating the midpoint(ob)
{
	int retv=0;
    1bca:	80 e0       	ldi	r24, 0x00	; 0
    1bcc:	90 e0       	ldi	r25, 0x00	; 0
		cost[n_node][c_node]=IN;
		retv=1;
	}
	
	return retv;
}
    1bce:	df 91       	pop	r29
    1bd0:	cf 91       	pop	r28
    1bd2:	1f 91       	pop	r17
    1bd4:	0f 91       	pop	r16
    1bd6:	08 95       	ret

00001bd8 <plot_scan1>:

int plot_scan1(int crtid,int nxtid, int survivor_index)		//To scan the plots for white debris
{
    1bd8:	cf 93       	push	r28
    1bda:	df 93       	push	r29
    1bdc:	fc 01       	movw	r30, r24
    1bde:	ea 01       	movw	r28, r20
	int l = 0, r = 0;
	int retval = 0;	

	switch(crtid - nxtid)
    1be0:	86 1b       	sub	r24, r22
    1be2:	97 0b       	sbc	r25, r23
    1be4:	2f ef       	ldi	r18, 0xFF	; 255
    1be6:	8f 3f       	cpi	r24, 0xFF	; 255
    1be8:	92 07       	cpc	r25, r18
    1bea:	51 f1       	breq	.+84     	; 0x1c40 <plot_scan1+0x68>
    1bec:	af ef       	ldi	r26, 0xFF	; 255
    1bee:	8f 3f       	cpi	r24, 0xFF	; 255
    1bf0:	9a 07       	cpc	r25, r26
    1bf2:	09 f0       	breq	.+2      	; 0x1bf6 <plot_scan1+0x1e>
    1bf4:	34 f4       	brge	.+12     	; 0x1c02 <plot_scan1+0x2a>
    1bf6:	bf ef       	ldi	r27, 0xFF	; 255
    1bf8:	8b 3f       	cpi	r24, 0xFB	; 251
    1bfa:	9b 07       	cpc	r25, r27
    1bfc:	09 f0       	breq	.+2      	; 0x1c00 <plot_scan1+0x28>
    1bfe:	65 c0       	rjmp	.+202    	; 0x1cca <plot_scan1+0xf2>
    1c00:	4d c0       	rjmp	.+154    	; 0x1c9c <plot_scan1+0xc4>
    1c02:	81 30       	cpi	r24, 0x01	; 1
    1c04:	91 05       	cpc	r25, r1
    1c06:	29 f0       	breq	.+10     	; 0x1c12 <plot_scan1+0x3a>
    1c08:	85 30       	cpi	r24, 0x05	; 5
    1c0a:	91 05       	cpc	r25, r1
    1c0c:	09 f0       	breq	.+2      	; 0x1c10 <plot_scan1+0x38>
    1c0e:	5d c0       	rjmp	.+186    	; 0x1cca <plot_scan1+0xf2>
    1c10:	2e c0       	rjmp	.+92     	; 0x1c6e <plot_scan1+0x96>
	{
		case 1:
		l=n[crtid].blk[1];
    1c12:	cf 01       	movw	r24, r30
    1c14:	88 0f       	add	r24, r24
    1c16:	99 1f       	adc	r25, r25
    1c18:	8e 0f       	add	r24, r30
    1c1a:	9f 1f       	adc	r25, r31
    1c1c:	9c 01       	movw	r18, r24
    1c1e:	22 0f       	add	r18, r18
    1c20:	33 1f       	adc	r19, r19
    1c22:	22 0f       	add	r18, r18
    1c24:	33 1f       	adc	r19, r19
    1c26:	22 0f       	add	r18, r18
    1c28:	33 1f       	adc	r19, r19
    1c2a:	28 1b       	sub	r18, r24
    1c2c:	39 0b       	sbc	r19, r25
    1c2e:	e2 0f       	add	r30, r18
    1c30:	f3 1f       	adc	r31, r19
    1c32:	e4 50       	subi	r30, 0x04	; 4
    1c34:	f1 4f       	sbci	r31, 0xF1	; 241
    1c36:	84 85       	ldd	r24, Z+12	; 0x0c
    1c38:	95 85       	ldd	r25, Z+13	; 0x0d
		r=n[crtid].blk[3];
    1c3a:	40 89       	ldd	r20, Z+16	; 0x10
    1c3c:	51 89       	ldd	r21, Z+17	; 0x11
		break;
    1c3e:	49 c0       	rjmp	.+146    	; 0x1cd2 <plot_scan1+0xfa>
		
		case -1:
		l=n[crtid].blk[4];	//l=n[crtid].blk[4];
    1c40:	cf 01       	movw	r24, r30
    1c42:	88 0f       	add	r24, r24
    1c44:	99 1f       	adc	r25, r25
    1c46:	8e 0f       	add	r24, r30
    1c48:	9f 1f       	adc	r25, r31
    1c4a:	9c 01       	movw	r18, r24
    1c4c:	22 0f       	add	r18, r18
    1c4e:	33 1f       	adc	r19, r19
    1c50:	22 0f       	add	r18, r18
    1c52:	33 1f       	adc	r19, r19
    1c54:	22 0f       	add	r18, r18
    1c56:	33 1f       	adc	r19, r19
    1c58:	28 1b       	sub	r18, r24
    1c5a:	39 0b       	sbc	r19, r25
    1c5c:	e2 0f       	add	r30, r18
    1c5e:	f3 1f       	adc	r31, r19
    1c60:	e4 50       	subi	r30, 0x04	; 4
    1c62:	f1 4f       	sbci	r31, 0xF1	; 241
    1c64:	82 89       	ldd	r24, Z+18	; 0x12
    1c66:	93 89       	ldd	r25, Z+19	; 0x13
		r=n[crtid].blk[2];	//r=n[crtid].blk[2];
    1c68:	46 85       	ldd	r20, Z+14	; 0x0e
    1c6a:	57 85       	ldd	r21, Z+15	; 0x0f
		break;
    1c6c:	32 c0       	rjmp	.+100    	; 0x1cd2 <plot_scan1+0xfa>
		
		case 5:
		l=n[crtid].blk[3];
    1c6e:	cf 01       	movw	r24, r30
    1c70:	88 0f       	add	r24, r24
    1c72:	99 1f       	adc	r25, r25
    1c74:	8e 0f       	add	r24, r30
    1c76:	9f 1f       	adc	r25, r31
    1c78:	9c 01       	movw	r18, r24
    1c7a:	22 0f       	add	r18, r18
    1c7c:	33 1f       	adc	r19, r19
    1c7e:	22 0f       	add	r18, r18
    1c80:	33 1f       	adc	r19, r19
    1c82:	22 0f       	add	r18, r18
    1c84:	33 1f       	adc	r19, r19
    1c86:	28 1b       	sub	r18, r24
    1c88:	39 0b       	sbc	r19, r25
    1c8a:	e2 0f       	add	r30, r18
    1c8c:	f3 1f       	adc	r31, r19
    1c8e:	e4 50       	subi	r30, 0x04	; 4
    1c90:	f1 4f       	sbci	r31, 0xF1	; 241
    1c92:	80 89       	ldd	r24, Z+16	; 0x10
    1c94:	91 89       	ldd	r25, Z+17	; 0x11
		r=n[crtid].blk[4];
    1c96:	42 89       	ldd	r20, Z+18	; 0x12
    1c98:	53 89       	ldd	r21, Z+19	; 0x13
		break;
    1c9a:	1b c0       	rjmp	.+54     	; 0x1cd2 <plot_scan1+0xfa>
		
		case -5:
		l=n[crtid].blk[2];
    1c9c:	cf 01       	movw	r24, r30
    1c9e:	88 0f       	add	r24, r24
    1ca0:	99 1f       	adc	r25, r25
    1ca2:	8e 0f       	add	r24, r30
    1ca4:	9f 1f       	adc	r25, r31
    1ca6:	9c 01       	movw	r18, r24
    1ca8:	22 0f       	add	r18, r18
    1caa:	33 1f       	adc	r19, r19
    1cac:	22 0f       	add	r18, r18
    1cae:	33 1f       	adc	r19, r19
    1cb0:	22 0f       	add	r18, r18
    1cb2:	33 1f       	adc	r19, r19
    1cb4:	28 1b       	sub	r18, r24
    1cb6:	39 0b       	sbc	r19, r25
    1cb8:	e2 0f       	add	r30, r18
    1cba:	f3 1f       	adc	r31, r19
    1cbc:	e4 50       	subi	r30, 0x04	; 4
    1cbe:	f1 4f       	sbci	r31, 0xF1	; 241
    1cc0:	86 85       	ldd	r24, Z+14	; 0x0e
    1cc2:	97 85       	ldd	r25, Z+15	; 0x0f
		r=n[crtid].blk[1];
    1cc4:	44 85       	ldd	r20, Z+12	; 0x0c
    1cc6:	55 85       	ldd	r21, Z+13	; 0x0d
		break;
    1cc8:	04 c0       	rjmp	.+8      	; 0x1cd2 <plot_scan1+0xfa>
	return retv;
}

int plot_scan1(int crtid,int nxtid, int survivor_index)		//To scan the plots for white debris
{
	int l = 0, r = 0;
    1cca:	40 e0       	ldi	r20, 0x00	; 0
    1ccc:	50 e0       	ldi	r21, 0x00	; 0
    1cce:	80 e0       	ldi	r24, 0x00	; 0
    1cd0:	90 e0       	ldi	r25, 0x00	; 0
		default: break;
	}
	
	//turn(crtid,nxtid);
	
	if(survivor_status[survivor_index] == 0)
    1cd2:	fe 01       	movw	r30, r28
    1cd4:	ee 0f       	add	r30, r30
    1cd6:	ff 1f       	adc	r31, r31
    1cd8:	ec 5d       	subi	r30, 0xDC	; 220
    1cda:	fd 4e       	sbci	r31, 0xED	; 237
    1cdc:	20 81       	ld	r18, Z
    1cde:	31 81       	ldd	r19, Z+1	; 0x01
    1ce0:	21 15       	cp	r18, r1
    1ce2:	31 05       	cpc	r19, r1
    1ce4:	09 f0       	breq	.+2      	; 0x1ce8 <plot_scan1+0x110>
    1ce6:	ce c0       	rjmp	.+412    	; 0x1e84 <plot_scan1+0x2ac>
	if(survivor_plot[survivor_index] == l )
    1ce8:	fe 01       	movw	r30, r28
    1cea:	ee 0f       	add	r30, r30
    1cec:	ff 1f       	adc	r31, r31
    1cee:	e8 5b       	subi	r30, 0xB8	; 184
    1cf0:	fe 4e       	sbci	r31, 0xEE	; 238
    1cf2:	20 81       	ld	r18, Z
    1cf4:	31 81       	ldd	r19, Z+1	; 0x01
    1cf6:	28 17       	cp	r18, r24
    1cf8:	39 07       	cpc	r19, r25
    1cfa:	09 f0       	breq	.+2      	; 0x1cfe <plot_scan1+0x126>
    1cfc:	7a c0       	rjmp	.+244    	; 0x1df2 <plot_scan1+0x21a>
	{
		//left_degrees(86);
		
		survivor_status[survivor_index]=1;
    1cfe:	ce 01       	movw	r24, r28
    1d00:	88 0f       	add	r24, r24
    1d02:	99 1f       	adc	r25, r25
    1d04:	fc 01       	movw	r30, r24
    1d06:	ec 5d       	subi	r30, 0xDC	; 220
    1d08:	fd 4e       	sbci	r31, 0xED	; 237
    1d0a:	21 e0       	ldi	r18, 0x01	; 1
    1d0c:	30 e0       	ldi	r19, 0x00	; 0
    1d0e:	31 83       	std	Z+1, r19	; 0x01
    1d10:	20 83       	st	Z, r18
		
		if (survivor_colour[survivor_index] == 0)
    1d12:	88 5f       	subi	r24, 0xF8	; 248
    1d14:	97 4e       	sbci	r25, 0xE7	; 231
    1d16:	fc 01       	movw	r30, r24
    1d18:	80 81       	ld	r24, Z
    1d1a:	91 81       	ldd	r25, Z+1	; 0x01
    1d1c:	00 97       	sbiw	r24, 0x00	; 0
    1d1e:	09 f0       	breq	.+2      	; 0x1d22 <plot_scan1+0x14a>
    1d20:	4f c0       	rjmp	.+158    	; 0x1dc0 <plot_scan1+0x1e8>
		{
			path_mm(70);
    1d22:	66 e4       	ldi	r22, 0x46	; 70
    1d24:	70 e0       	ldi	r23, 0x00	; 0
    1d26:	80 e0       	ldi	r24, 0x00	; 0
    1d28:	90 e0       	ldi	r25, 0x00	; 0
    1d2a:	0e 94 4d 05 	call	0xa9a	; 0xa9a <path_mm>
			left_degrees(30);
    1d2e:	8e e1       	ldi	r24, 0x1E	; 30
    1d30:	90 e0       	ldi	r25, 0x00	; 0
    1d32:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <left_degrees>
    1d36:	8f ef       	ldi	r24, 0xFF	; 255
    1d38:	9f ef       	ldi	r25, 0xFF	; 255
    1d3a:	ac e2       	ldi	r26, 0x2C	; 44
    1d3c:	81 50       	subi	r24, 0x01	; 1
    1d3e:	90 40       	sbci	r25, 0x00	; 0
    1d40:	a0 40       	sbci	r26, 0x00	; 0
    1d42:	e1 f7       	brne	.-8      	; 0x1d3c <plot_scan1+0x164>
    1d44:	00 c0       	rjmp	.+0      	; 0x1d46 <plot_scan1+0x16e>
    1d46:	00 00       	nop
			_delay_ms(1000);
			//back_mm(80);
			back();
    1d48:	0e 94 3e 04 	call	0x87c	; 0x87c <back>
			linear_mm(30);
    1d4c:	6e e1       	ldi	r22, 0x1E	; 30
    1d4e:	70 e0       	ldi	r23, 0x00	; 0
    1d50:	80 e0       	ldi	r24, 0x00	; 0
    1d52:	90 e0       	ldi	r25, 0x00	; 0
    1d54:	0e 94 5e 04 	call	0x8bc	; 0x8bc <linear_mm>
    1d58:	8f ef       	ldi	r24, 0xFF	; 255
    1d5a:	9f ef       	ldi	r25, 0xFF	; 255
    1d5c:	ac e2       	ldi	r26, 0x2C	; 44
    1d5e:	81 50       	subi	r24, 0x01	; 1
    1d60:	90 40       	sbci	r25, 0x00	; 0
    1d62:	a0 40       	sbci	r26, 0x00	; 0
    1d64:	e1 f7       	brne	.-8      	; 0x1d5e <plot_scan1+0x186>
    1d66:	00 c0       	rjmp	.+0      	; 0x1d68 <plot_scan1+0x190>
    1d68:	00 00       	nop
			_delay_ms(1000);
			soft_left_2_degrees(40);		
    1d6a:	88 e2       	ldi	r24, 0x28	; 40
    1d6c:	90 e0       	ldi	r25, 0x00	; 0
    1d6e:	0e 94 33 05 	call	0xa66	; 0xa66 <soft_left_2_degrees>
			
			buzzer(1);
    1d72:	81 e0       	ldi	r24, 0x01	; 1
    1d74:	90 e0       	ldi	r25, 0x00	; 0
    1d76:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <buzzer>
			
			soft_right_degrees(40);
    1d7a:	88 e2       	ldi	r24, 0x28	; 40
    1d7c:	90 e0       	ldi	r25, 0x00	; 0
    1d7e:	0e 94 26 05 	call	0xa4c	; 0xa4c <soft_right_degrees>
    1d82:	8f ef       	ldi	r24, 0xFF	; 255
    1d84:	9f ef       	ldi	r25, 0xFF	; 255
    1d86:	ac e2       	ldi	r26, 0x2C	; 44
    1d88:	81 50       	subi	r24, 0x01	; 1
    1d8a:	90 40       	sbci	r25, 0x00	; 0
    1d8c:	a0 40       	sbci	r26, 0x00	; 0
    1d8e:	e1 f7       	brne	.-8      	; 0x1d88 <plot_scan1+0x1b0>
    1d90:	00 c0       	rjmp	.+0      	; 0x1d92 <plot_scan1+0x1ba>
    1d92:	00 00       	nop
			_delay_ms(1000);
			forward();
    1d94:	0e 94 2f 04 	call	0x85e	; 0x85e <forward>
			linear_mm(30);
    1d98:	6e e1       	ldi	r22, 0x1E	; 30
    1d9a:	70 e0       	ldi	r23, 0x00	; 0
    1d9c:	80 e0       	ldi	r24, 0x00	; 0
    1d9e:	90 e0       	ldi	r25, 0x00	; 0
    1da0:	0e 94 5e 04 	call	0x8bc	; 0x8bc <linear_mm>
    1da4:	8f ef       	ldi	r24, 0xFF	; 255
    1da6:	9f ef       	ldi	r25, 0xFF	; 255
    1da8:	ac e2       	ldi	r26, 0x2C	; 44
    1daa:	81 50       	subi	r24, 0x01	; 1
    1dac:	90 40       	sbci	r25, 0x00	; 0
    1dae:	a0 40       	sbci	r26, 0x00	; 0
    1db0:	e1 f7       	brne	.-8      	; 0x1daa <plot_scan1+0x1d2>
    1db2:	00 c0       	rjmp	.+0      	; 0x1db4 <plot_scan1+0x1dc>
    1db4:	00 00       	nop
			_delay_ms(1000);
			rotate_right(40);
    1db6:	88 e2       	ldi	r24, 0x28	; 40
    1db8:	90 e0       	ldi	r25, 0x00	; 0
    1dba:	0e 94 19 06 	call	0xc32	; 0xc32 <rotate_right>
    1dbe:	6a c0       	rjmp	.+212    	; 0x1e94 <plot_scan1+0x2bc>
			
		}
		else
		{
			path_mm(30);
    1dc0:	6e e1       	ldi	r22, 0x1E	; 30
    1dc2:	70 e0       	ldi	r23, 0x00	; 0
    1dc4:	80 e0       	ldi	r24, 0x00	; 0
    1dc6:	90 e0       	ldi	r25, 0x00	; 0
    1dc8:	0e 94 4d 05 	call	0xa9a	; 0xa9a <path_mm>
			left_degrees(50);
    1dcc:	82 e3       	ldi	r24, 0x32	; 50
    1dce:	90 e0       	ldi	r25, 0x00	; 0
    1dd0:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <left_degrees>
			
			first_aid_kit_deposit();
    1dd4:	0e 94 d1 06 	call	0xda2	; 0xda2 <first_aid_kit_deposit>
			display_colour(3);
    1dd8:	83 e0       	ldi	r24, 0x03	; 3
    1dda:	90 e0       	ldi	r25, 0x00	; 0
    1ddc:	0e 94 a1 08 	call	0x1142	; 0x1142 <display_colour>
			buzzer(1);
    1de0:	81 e0       	ldi	r24, 0x01	; 1
    1de2:	90 e0       	ldi	r25, 0x00	; 0
    1de4:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <buzzer>
			
			rotate_right(40);
    1de8:	88 e2       	ldi	r24, 0x28	; 40
    1dea:	90 e0       	ldi	r25, 0x00	; 0
    1dec:	0e 94 19 06 	call	0xc32	; 0xc32 <rotate_right>
    1df0:	51 c0       	rjmp	.+162    	; 0x1e94 <plot_scan1+0x2bc>
		}
		
		//rotate_right(85);
		retval = 1;
	}
	else if(survivor_plot[survivor_index] == r)
    1df2:	fe 01       	movw	r30, r28
    1df4:	ee 0f       	add	r30, r30
    1df6:	ff 1f       	adc	r31, r31
    1df8:	e8 5b       	subi	r30, 0xB8	; 184
    1dfa:	fe 4e       	sbci	r31, 0xEE	; 238
    1dfc:	80 81       	ld	r24, Z
    1dfe:	91 81       	ldd	r25, Z+1	; 0x01
    1e00:	84 17       	cp	r24, r20
    1e02:	95 07       	cpc	r25, r21
    1e04:	09 f0       	breq	.+2      	; 0x1e08 <plot_scan1+0x230>
    1e06:	41 c0       	rjmp	.+130    	; 0x1e8a <plot_scan1+0x2b2>
	{
		//right_degrees(86);
		survivor_status[survivor_index]=1;
    1e08:	ce 01       	movw	r24, r28
    1e0a:	88 0f       	add	r24, r24
    1e0c:	99 1f       	adc	r25, r25
    1e0e:	fc 01       	movw	r30, r24
    1e10:	ec 5d       	subi	r30, 0xDC	; 220
    1e12:	fd 4e       	sbci	r31, 0xED	; 237
    1e14:	21 e0       	ldi	r18, 0x01	; 1
    1e16:	30 e0       	ldi	r19, 0x00	; 0
    1e18:	31 83       	std	Z+1, r19	; 0x01
    1e1a:	20 83       	st	Z, r18
		
		if (survivor_colour[survivor_index] == 0)
    1e1c:	88 5f       	subi	r24, 0xF8	; 248
    1e1e:	97 4e       	sbci	r25, 0xE7	; 231
    1e20:	dc 01       	movw	r26, r24
    1e22:	8d 91       	ld	r24, X+
    1e24:	9c 91       	ld	r25, X
    1e26:	11 97       	sbiw	r26, 0x01	; 1
    1e28:	00 97       	sbiw	r24, 0x00	; 0
    1e2a:	99 f4       	brne	.+38     	; 0x1e52 <plot_scan1+0x27a>
		{
			path_mm(50);
    1e2c:	62 e3       	ldi	r22, 0x32	; 50
    1e2e:	70 e0       	ldi	r23, 0x00	; 0
    1e30:	80 e0       	ldi	r24, 0x00	; 0
    1e32:	90 e0       	ldi	r25, 0x00	; 0
    1e34:	0e 94 4d 05 	call	0xa9a	; 0xa9a <path_mm>
			forward();
			linear_mm(30);
			_delay_ms(1000);
			rotate_left(40);
			*/
			right_degrees(85);
    1e38:	85 e5       	ldi	r24, 0x55	; 85
    1e3a:	90 e0       	ldi	r25, 0x00	; 0
    1e3c:	0e 94 0a 05 	call	0xa14	; 0xa14 <right_degrees>
			buzzer(1);
    1e40:	81 e0       	ldi	r24, 0x01	; 1
    1e42:	90 e0       	ldi	r25, 0x00	; 0
    1e44:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <buzzer>
			rotate_left(85);
    1e48:	85 e5       	ldi	r24, 0x55	; 85
    1e4a:	90 e0       	ldi	r25, 0x00	; 0
    1e4c:	0e 94 3c 06 	call	0xc78	; 0xc78 <rotate_left>
    1e50:	21 c0       	rjmp	.+66     	; 0x1e94 <plot_scan1+0x2bc>
		}
		else
		{
			path_mm(55);
    1e52:	67 e3       	ldi	r22, 0x37	; 55
    1e54:	70 e0       	ldi	r23, 0x00	; 0
    1e56:	80 e0       	ldi	r24, 0x00	; 0
    1e58:	90 e0       	ldi	r25, 0x00	; 0
    1e5a:	0e 94 4d 05 	call	0xa9a	; 0xa9a <path_mm>
			right_degrees(90);
    1e5e:	8a e5       	ldi	r24, 0x5A	; 90
    1e60:	90 e0       	ldi	r25, 0x00	; 0
    1e62:	0e 94 0a 05 	call	0xa14	; 0xa14 <right_degrees>
			
			first_aid_kit_deposit();
    1e66:	0e 94 d1 06 	call	0xda2	; 0xda2 <first_aid_kit_deposit>
			display_colour(3);
    1e6a:	83 e0       	ldi	r24, 0x03	; 3
    1e6c:	90 e0       	ldi	r25, 0x00	; 0
    1e6e:	0e 94 a1 08 	call	0x1142	; 0x1142 <display_colour>
			buzzer(1);
    1e72:	81 e0       	ldi	r24, 0x01	; 1
    1e74:	90 e0       	ldi	r25, 0x00	; 0
    1e76:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <buzzer>
			
			rotate_left(85);
    1e7a:	85 e5       	ldi	r24, 0x55	; 85
    1e7c:	90 e0       	ldi	r25, 0x00	; 0
    1e7e:	0e 94 3c 06 	call	0xc78	; 0xc78 <rotate_left>
    1e82:	08 c0       	rjmp	.+16     	; 0x1e94 <plot_scan1+0x2bc>
		default: break;
	}
	
	//turn(crtid,nxtid);
	
	if(survivor_status[survivor_index] == 0)
    1e84:	80 e0       	ldi	r24, 0x00	; 0
    1e86:	90 e0       	ldi	r25, 0x00	; 0
    1e88:	02 c0       	rjmp	.+4      	; 0x1e8e <plot_scan1+0x2b6>
		}
		
		//rotate_right(85);
		retval = 1;
	}
	else if(survivor_plot[survivor_index] == r)
    1e8a:	80 e0       	ldi	r24, 0x00	; 0
    1e8c:	90 e0       	ldi	r25, 0x00	; 0
	
	if(retval==1)
		b[survivor_plot[survivor_index]].pstatus=1;
	
	return retval;
}
    1e8e:	df 91       	pop	r29
    1e90:	cf 91       	pop	r28
    1e92:	08 95       	ret
		//rotate_left(85);
		retval = 1;
	}
	
	if(retval==1)
		b[survivor_plot[survivor_index]].pstatus=1;
    1e94:	cc 0f       	add	r28, r28
    1e96:	dd 1f       	adc	r29, r29
    1e98:	c8 5b       	subi	r28, 0xB8	; 184
    1e9a:	de 4e       	sbci	r29, 0xEE	; 238
    1e9c:	e8 81       	ld	r30, Y
    1e9e:	f9 81       	ldd	r31, Y+1	; 0x01
    1ea0:	ee 0f       	add	r30, r30
    1ea2:	ff 1f       	adc	r31, r31
    1ea4:	e2 95       	swap	r30
    1ea6:	f2 95       	swap	r31
    1ea8:	f0 7f       	andi	r31, 0xF0	; 240
    1eaa:	fe 27       	eor	r31, r30
    1eac:	e0 7f       	andi	r30, 0xF0	; 240
    1eae:	fe 27       	eor	r31, r30
    1eb0:	e4 52       	subi	r30, 0x24	; 36
    1eb2:	f3 4f       	sbci	r31, 0xF3	; 243
    1eb4:	81 e0       	ldi	r24, 0x01	; 1
    1eb6:	90 e0       	ldi	r25, 0x00	; 0
    1eb8:	95 8b       	std	Z+21, r25	; 0x15
    1eba:	84 8b       	std	Z+20, r24	; 0x14
    1ebc:	e8 cf       	rjmp	.-48     	; 0x1e8e <plot_scan1+0x2b6>

00001ebe <plot_scan>:
	
	return retval;
}

int plot_scan(int crtid,int nxtid, int survivor_index)		//To scan the plots for white debris
{
    1ebe:	cf 93       	push	r28
    1ec0:	df 93       	push	r29
    1ec2:	fc 01       	movw	r30, r24
    1ec4:	ea 01       	movw	r28, r20
	int l = 0, r = 0;
	int retval = 0;

	switch(crtid - nxtid)
    1ec6:	86 1b       	sub	r24, r22
    1ec8:	97 0b       	sbc	r25, r23
    1eca:	2f ef       	ldi	r18, 0xFF	; 255
    1ecc:	8f 3f       	cpi	r24, 0xFF	; 255
    1ece:	92 07       	cpc	r25, r18
    1ed0:	51 f1       	breq	.+84     	; 0x1f26 <plot_scan+0x68>
    1ed2:	2f ef       	ldi	r18, 0xFF	; 255
    1ed4:	8f 3f       	cpi	r24, 0xFF	; 255
    1ed6:	92 07       	cpc	r25, r18
    1ed8:	09 f0       	breq	.+2      	; 0x1edc <plot_scan+0x1e>
    1eda:	34 f4       	brge	.+12     	; 0x1ee8 <plot_scan+0x2a>
    1edc:	2f ef       	ldi	r18, 0xFF	; 255
    1ede:	8b 3f       	cpi	r24, 0xFB	; 251
    1ee0:	92 07       	cpc	r25, r18
    1ee2:	09 f0       	breq	.+2      	; 0x1ee6 <plot_scan+0x28>
    1ee4:	65 c0       	rjmp	.+202    	; 0x1fb0 <plot_scan+0xf2>
    1ee6:	4d c0       	rjmp	.+154    	; 0x1f82 <plot_scan+0xc4>
    1ee8:	81 30       	cpi	r24, 0x01	; 1
    1eea:	91 05       	cpc	r25, r1
    1eec:	29 f0       	breq	.+10     	; 0x1ef8 <plot_scan+0x3a>
    1eee:	85 30       	cpi	r24, 0x05	; 5
    1ef0:	91 05       	cpc	r25, r1
    1ef2:	09 f0       	breq	.+2      	; 0x1ef6 <plot_scan+0x38>
    1ef4:	5d c0       	rjmp	.+186    	; 0x1fb0 <plot_scan+0xf2>
    1ef6:	2e c0       	rjmp	.+92     	; 0x1f54 <plot_scan+0x96>
	{
		case 1:
		l=n[crtid].blk[1];
    1ef8:	cf 01       	movw	r24, r30
    1efa:	88 0f       	add	r24, r24
    1efc:	99 1f       	adc	r25, r25
    1efe:	8e 0f       	add	r24, r30
    1f00:	9f 1f       	adc	r25, r31
    1f02:	9c 01       	movw	r18, r24
    1f04:	22 0f       	add	r18, r18
    1f06:	33 1f       	adc	r19, r19
    1f08:	22 0f       	add	r18, r18
    1f0a:	33 1f       	adc	r19, r19
    1f0c:	22 0f       	add	r18, r18
    1f0e:	33 1f       	adc	r19, r19
    1f10:	28 1b       	sub	r18, r24
    1f12:	39 0b       	sbc	r19, r25
    1f14:	e2 0f       	add	r30, r18
    1f16:	f3 1f       	adc	r31, r19
    1f18:	e4 50       	subi	r30, 0x04	; 4
    1f1a:	f1 4f       	sbci	r31, 0xF1	; 241
    1f1c:	84 85       	ldd	r24, Z+12	; 0x0c
    1f1e:	95 85       	ldd	r25, Z+13	; 0x0d
		r=n[crtid].blk[3];
    1f20:	40 89       	ldd	r20, Z+16	; 0x10
    1f22:	51 89       	ldd	r21, Z+17	; 0x11
		break;
    1f24:	49 c0       	rjmp	.+146    	; 0x1fb8 <plot_scan+0xfa>
		
		case -1:
		l=n[crtid].blk[4];	//l=n[crtid].blk[4];
    1f26:	cf 01       	movw	r24, r30
    1f28:	88 0f       	add	r24, r24
    1f2a:	99 1f       	adc	r25, r25
    1f2c:	8e 0f       	add	r24, r30
    1f2e:	9f 1f       	adc	r25, r31
    1f30:	9c 01       	movw	r18, r24
    1f32:	22 0f       	add	r18, r18
    1f34:	33 1f       	adc	r19, r19
    1f36:	22 0f       	add	r18, r18
    1f38:	33 1f       	adc	r19, r19
    1f3a:	22 0f       	add	r18, r18
    1f3c:	33 1f       	adc	r19, r19
    1f3e:	28 1b       	sub	r18, r24
    1f40:	39 0b       	sbc	r19, r25
    1f42:	e2 0f       	add	r30, r18
    1f44:	f3 1f       	adc	r31, r19
    1f46:	e4 50       	subi	r30, 0x04	; 4
    1f48:	f1 4f       	sbci	r31, 0xF1	; 241
    1f4a:	82 89       	ldd	r24, Z+18	; 0x12
    1f4c:	93 89       	ldd	r25, Z+19	; 0x13
		r=n[crtid].blk[2];	//r=n[crtid].blk[2];
    1f4e:	46 85       	ldd	r20, Z+14	; 0x0e
    1f50:	57 85       	ldd	r21, Z+15	; 0x0f
		break;
    1f52:	32 c0       	rjmp	.+100    	; 0x1fb8 <plot_scan+0xfa>
		
		case 5:
		l=n[crtid].blk[3];
    1f54:	cf 01       	movw	r24, r30
    1f56:	88 0f       	add	r24, r24
    1f58:	99 1f       	adc	r25, r25
    1f5a:	8e 0f       	add	r24, r30
    1f5c:	9f 1f       	adc	r25, r31
    1f5e:	9c 01       	movw	r18, r24
    1f60:	22 0f       	add	r18, r18
    1f62:	33 1f       	adc	r19, r19
    1f64:	22 0f       	add	r18, r18
    1f66:	33 1f       	adc	r19, r19
    1f68:	22 0f       	add	r18, r18
    1f6a:	33 1f       	adc	r19, r19
    1f6c:	28 1b       	sub	r18, r24
    1f6e:	39 0b       	sbc	r19, r25
    1f70:	e2 0f       	add	r30, r18
    1f72:	f3 1f       	adc	r31, r19
    1f74:	e4 50       	subi	r30, 0x04	; 4
    1f76:	f1 4f       	sbci	r31, 0xF1	; 241
    1f78:	80 89       	ldd	r24, Z+16	; 0x10
    1f7a:	91 89       	ldd	r25, Z+17	; 0x11
		r=n[crtid].blk[4];
    1f7c:	42 89       	ldd	r20, Z+18	; 0x12
    1f7e:	53 89       	ldd	r21, Z+19	; 0x13
		break;
    1f80:	1b c0       	rjmp	.+54     	; 0x1fb8 <plot_scan+0xfa>
		
		case -5:
		l=n[crtid].blk[2];
    1f82:	cf 01       	movw	r24, r30
    1f84:	88 0f       	add	r24, r24
    1f86:	99 1f       	adc	r25, r25
    1f88:	8e 0f       	add	r24, r30
    1f8a:	9f 1f       	adc	r25, r31
    1f8c:	9c 01       	movw	r18, r24
    1f8e:	22 0f       	add	r18, r18
    1f90:	33 1f       	adc	r19, r19
    1f92:	22 0f       	add	r18, r18
    1f94:	33 1f       	adc	r19, r19
    1f96:	22 0f       	add	r18, r18
    1f98:	33 1f       	adc	r19, r19
    1f9a:	28 1b       	sub	r18, r24
    1f9c:	39 0b       	sbc	r19, r25
    1f9e:	e2 0f       	add	r30, r18
    1fa0:	f3 1f       	adc	r31, r19
    1fa2:	e4 50       	subi	r30, 0x04	; 4
    1fa4:	f1 4f       	sbci	r31, 0xF1	; 241
    1fa6:	86 85       	ldd	r24, Z+14	; 0x0e
    1fa8:	97 85       	ldd	r25, Z+15	; 0x0f
		r=n[crtid].blk[1];
    1faa:	44 85       	ldd	r20, Z+12	; 0x0c
    1fac:	55 85       	ldd	r21, Z+13	; 0x0d
		break;
    1fae:	04 c0       	rjmp	.+8      	; 0x1fb8 <plot_scan+0xfa>
	return retval;
}

int plot_scan(int crtid,int nxtid, int survivor_index)		//To scan the plots for white debris
{
	int l = 0, r = 0;
    1fb0:	40 e0       	ldi	r20, 0x00	; 0
    1fb2:	50 e0       	ldi	r21, 0x00	; 0
    1fb4:	80 e0       	ldi	r24, 0x00	; 0
    1fb6:	90 e0       	ldi	r25, 0x00	; 0
		default: break;
	}
	
	//turn(crtid,nxtid);
	
	if(survivor_status[survivor_index] == 0)
    1fb8:	fe 01       	movw	r30, r28
    1fba:	ee 0f       	add	r30, r30
    1fbc:	ff 1f       	adc	r31, r31
    1fbe:	ec 5d       	subi	r30, 0xDC	; 220
    1fc0:	fd 4e       	sbci	r31, 0xED	; 237
    1fc2:	20 81       	ld	r18, Z
    1fc4:	31 81       	ldd	r19, Z+1	; 0x01
    1fc6:	21 15       	cp	r18, r1
    1fc8:	31 05       	cpc	r19, r1
    1fca:	09 f0       	breq	.+2      	; 0x1fce <plot_scan+0x110>
    1fcc:	82 c0       	rjmp	.+260    	; 0x20d2 <plot_scan+0x214>
	if(survivor_plot[survivor_index] == l )
    1fce:	fe 01       	movw	r30, r28
    1fd0:	ee 0f       	add	r30, r30
    1fd2:	ff 1f       	adc	r31, r31
    1fd4:	e8 5b       	subi	r30, 0xB8	; 184
    1fd6:	fe 4e       	sbci	r31, 0xEE	; 238
    1fd8:	20 81       	ld	r18, Z
    1fda:	31 81       	ldd	r19, Z+1	; 0x01
    1fdc:	28 17       	cp	r18, r24
    1fde:	39 07       	cpc	r19, r25
    1fe0:	b9 f5       	brne	.+110    	; 0x2050 <plot_scan+0x192>
	{
		//left_degrees(86);
		
		
		survivor_status[survivor_index]=1;
    1fe2:	ce 01       	movw	r24, r28
    1fe4:	88 0f       	add	r24, r24
    1fe6:	99 1f       	adc	r25, r25
    1fe8:	fc 01       	movw	r30, r24
    1fea:	ec 5d       	subi	r30, 0xDC	; 220
    1fec:	fd 4e       	sbci	r31, 0xED	; 237
    1fee:	21 e0       	ldi	r18, 0x01	; 1
    1ff0:	30 e0       	ldi	r19, 0x00	; 0
    1ff2:	31 83       	std	Z+1, r19	; 0x01
    1ff4:	20 83       	st	Z, r18
		
		if (survivor_colour[survivor_index] == 0)
    1ff6:	88 5f       	subi	r24, 0xF8	; 248
    1ff8:	97 4e       	sbci	r25, 0xE7	; 231
    1ffa:	fc 01       	movw	r30, r24
    1ffc:	80 81       	ld	r24, Z
    1ffe:	91 81       	ldd	r25, Z+1	; 0x01
    2000:	00 97       	sbiw	r24, 0x00	; 0
    2002:	69 f4       	brne	.+26     	; 0x201e <plot_scan+0x160>
		{
			left_degrees(86);
    2004:	86 e5       	ldi	r24, 0x56	; 86
    2006:	90 e0       	ldi	r25, 0x00	; 0
    2008:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <left_degrees>
			buzzer(1);
    200c:	81 e0       	ldi	r24, 0x01	; 1
    200e:	90 e0       	ldi	r25, 0x00	; 0
    2010:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <buzzer>
			rotate_right(85);
    2014:	85 e5       	ldi	r24, 0x55	; 85
    2016:	90 e0       	ldi	r25, 0x00	; 0
    2018:	0e 94 19 06 	call	0xc32	; 0xc32 <rotate_right>
    201c:	62 c0       	rjmp	.+196    	; 0x20e2 <plot_scan+0x224>
		}
		else
		{
			path_mm(60);
    201e:	6c e3       	ldi	r22, 0x3C	; 60
    2020:	70 e0       	ldi	r23, 0x00	; 0
    2022:	80 e0       	ldi	r24, 0x00	; 0
    2024:	90 e0       	ldi	r25, 0x00	; 0
    2026:	0e 94 4d 05 	call	0xa9a	; 0xa9a <path_mm>
			left_degrees(86);
    202a:	86 e5       	ldi	r24, 0x56	; 86
    202c:	90 e0       	ldi	r25, 0x00	; 0
    202e:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <left_degrees>
			first_aid_kit_deposit();
    2032:	0e 94 d1 06 	call	0xda2	; 0xda2 <first_aid_kit_deposit>
			display_colour(3);
    2036:	83 e0       	ldi	r24, 0x03	; 3
    2038:	90 e0       	ldi	r25, 0x00	; 0
    203a:	0e 94 a1 08 	call	0x1142	; 0x1142 <display_colour>
			buzzer(1);
    203e:	81 e0       	ldi	r24, 0x01	; 1
    2040:	90 e0       	ldi	r25, 0x00	; 0
    2042:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <buzzer>
			rotate_right(85);
    2046:	85 e5       	ldi	r24, 0x55	; 85
    2048:	90 e0       	ldi	r25, 0x00	; 0
    204a:	0e 94 19 06 	call	0xc32	; 0xc32 <rotate_right>
    204e:	49 c0       	rjmp	.+146    	; 0x20e2 <plot_scan+0x224>
		}
		
		
		retval = 1;
	}
	else if(survivor_plot[survivor_index] == r)
    2050:	fe 01       	movw	r30, r28
    2052:	ee 0f       	add	r30, r30
    2054:	ff 1f       	adc	r31, r31
    2056:	e8 5b       	subi	r30, 0xB8	; 184
    2058:	fe 4e       	sbci	r31, 0xEE	; 238
    205a:	80 81       	ld	r24, Z
    205c:	91 81       	ldd	r25, Z+1	; 0x01
    205e:	84 17       	cp	r24, r20
    2060:	95 07       	cpc	r25, r21
    2062:	d1 f5       	brne	.+116    	; 0x20d8 <plot_scan+0x21a>
	{
		//right_degrees(86);
		survivor_status[survivor_index]=1;
    2064:	ce 01       	movw	r24, r28
    2066:	88 0f       	add	r24, r24
    2068:	99 1f       	adc	r25, r25
    206a:	fc 01       	movw	r30, r24
    206c:	ec 5d       	subi	r30, 0xDC	; 220
    206e:	fd 4e       	sbci	r31, 0xED	; 237
    2070:	21 e0       	ldi	r18, 0x01	; 1
    2072:	30 e0       	ldi	r19, 0x00	; 0
    2074:	31 83       	std	Z+1, r19	; 0x01
    2076:	20 83       	st	Z, r18
		
		if (survivor_colour[survivor_index] == 0)
    2078:	88 5f       	subi	r24, 0xF8	; 248
    207a:	97 4e       	sbci	r25, 0xE7	; 231
    207c:	fc 01       	movw	r30, r24
    207e:	80 81       	ld	r24, Z
    2080:	91 81       	ldd	r25, Z+1	; 0x01
    2082:	00 97       	sbiw	r24, 0x00	; 0
    2084:	69 f4       	brne	.+26     	; 0x20a0 <plot_scan+0x1e2>
		{
			right_degrees(86);
    2086:	86 e5       	ldi	r24, 0x56	; 86
    2088:	90 e0       	ldi	r25, 0x00	; 0
    208a:	0e 94 0a 05 	call	0xa14	; 0xa14 <right_degrees>
			buzzer(1);
    208e:	81 e0       	ldi	r24, 0x01	; 1
    2090:	90 e0       	ldi	r25, 0x00	; 0
    2092:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <buzzer>
			rotate_left(85);
    2096:	85 e5       	ldi	r24, 0x55	; 85
    2098:	90 e0       	ldi	r25, 0x00	; 0
    209a:	0e 94 3c 06 	call	0xc78	; 0xc78 <rotate_left>
    209e:	21 c0       	rjmp	.+66     	; 0x20e2 <plot_scan+0x224>
		}
		else
		{
			path_mm(60);
    20a0:	6c e3       	ldi	r22, 0x3C	; 60
    20a2:	70 e0       	ldi	r23, 0x00	; 0
    20a4:	80 e0       	ldi	r24, 0x00	; 0
    20a6:	90 e0       	ldi	r25, 0x00	; 0
    20a8:	0e 94 4d 05 	call	0xa9a	; 0xa9a <path_mm>
			right_degrees(86);
    20ac:	86 e5       	ldi	r24, 0x56	; 86
    20ae:	90 e0       	ldi	r25, 0x00	; 0
    20b0:	0e 94 0a 05 	call	0xa14	; 0xa14 <right_degrees>
			first_aid_kit_deposit();
    20b4:	0e 94 d1 06 	call	0xda2	; 0xda2 <first_aid_kit_deposit>
			display_colour(3);
    20b8:	83 e0       	ldi	r24, 0x03	; 3
    20ba:	90 e0       	ldi	r25, 0x00	; 0
    20bc:	0e 94 a1 08 	call	0x1142	; 0x1142 <display_colour>
			buzzer(1);
    20c0:	81 e0       	ldi	r24, 0x01	; 1
    20c2:	90 e0       	ldi	r25, 0x00	; 0
    20c4:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <buzzer>
			rotate_left(85);
    20c8:	85 e5       	ldi	r24, 0x55	; 85
    20ca:	90 e0       	ldi	r25, 0x00	; 0
    20cc:	0e 94 3c 06 	call	0xc78	; 0xc78 <rotate_left>
    20d0:	08 c0       	rjmp	.+16     	; 0x20e2 <plot_scan+0x224>
		default: break;
	}
	
	//turn(crtid,nxtid);
	
	if(survivor_status[survivor_index] == 0)
    20d2:	80 e0       	ldi	r24, 0x00	; 0
    20d4:	90 e0       	ldi	r25, 0x00	; 0
    20d6:	02 c0       	rjmp	.+4      	; 0x20dc <plot_scan+0x21e>
		}
		
		
		retval = 1;
	}
	else if(survivor_plot[survivor_index] == r)
    20d8:	80 e0       	ldi	r24, 0x00	; 0
    20da:	90 e0       	ldi	r25, 0x00	; 0
	
	if(retval==1)
	b[survivor_plot[survivor_index]].pstatus=1;
	
	return retval;
}
    20dc:	df 91       	pop	r29
    20de:	cf 91       	pop	r28
    20e0:	08 95       	ret
		
		retval = 1;
	}
	
	if(retval==1)
	b[survivor_plot[survivor_index]].pstatus=1;
    20e2:	cc 0f       	add	r28, r28
    20e4:	dd 1f       	adc	r29, r29
    20e6:	c8 5b       	subi	r28, 0xB8	; 184
    20e8:	de 4e       	sbci	r29, 0xEE	; 238
    20ea:	e8 81       	ld	r30, Y
    20ec:	f9 81       	ldd	r31, Y+1	; 0x01
    20ee:	ee 0f       	add	r30, r30
    20f0:	ff 1f       	adc	r31, r31
    20f2:	e2 95       	swap	r30
    20f4:	f2 95       	swap	r31
    20f6:	f0 7f       	andi	r31, 0xF0	; 240
    20f8:	fe 27       	eor	r31, r30
    20fa:	e0 7f       	andi	r30, 0xF0	; 240
    20fc:	fe 27       	eor	r31, r30
    20fe:	e4 52       	subi	r30, 0x24	; 36
    2100:	f3 4f       	sbci	r31, 0xF3	; 243
    2102:	81 e0       	ldi	r24, 0x01	; 1
    2104:	90 e0       	ldi	r25, 0x00	; 0
    2106:	95 8b       	std	Z+21, r25	; 0x15
    2108:	84 8b       	std	Z+20, r24	; 0x14
    210a:	e8 cf       	rjmp	.-48     	; 0x20dc <plot_scan+0x21e>

0000210c <pop>:
	store[sp]=x;
}

int pop(void)
{
	if(sp>=0)
    210c:	20 91 c8 0c 	lds	r18, 0x0CC8
    2110:	30 91 c9 0c 	lds	r19, 0x0CC9
    2114:	33 23       	and	r19, r19
    2116:	74 f0       	brlt	.+28     	; 0x2134 <pop+0x28>
	{
		int temp = store[sp];
    2118:	f9 01       	movw	r30, r18
    211a:	ee 0f       	add	r30, r30
    211c:	ff 1f       	adc	r31, r31
    211e:	e4 5a       	subi	r30, 0xA4	; 164
    2120:	fe 4e       	sbci	r31, 0xEE	; 238
    2122:	80 81       	ld	r24, Z
    2124:	91 81       	ldd	r25, Z+1	; 0x01
		sp--;
    2126:	21 50       	subi	r18, 0x01	; 1
    2128:	30 40       	sbci	r19, 0x00	; 0
    212a:	30 93 c9 0c 	sts	0x0CC9, r19
    212e:	20 93 c8 0c 	sts	0x0CC8, r18
		return temp;	
    2132:	08 95       	ret
	}
	else
		return -1;
    2134:	8f ef       	ldi	r24, 0xFF	; 255
    2136:	9f ef       	ldi	r25, 0xFF	; 255
}
    2138:	08 95       	ret

0000213a <go_back>:
	}
	sp=0;
}

void go_back(void)
{
    213a:	cf 93       	push	r28
    213c:	df 93       	push	r29
	go1(crt_node,pop());
    213e:	c0 91 4c 07 	lds	r28, 0x074C
    2142:	d0 91 4d 07 	lds	r29, 0x074D
    2146:	0e 94 86 10 	call	0x210c	; 0x210c <pop>
    214a:	bc 01       	movw	r22, r24
    214c:	ce 01       	movw	r24, r28
    214e:	0e 94 84 0d 	call	0x1b08	; 0x1b08 <go1>
}
    2152:	df 91       	pop	r29
    2154:	cf 91       	pop	r28
    2156:	08 95       	ret

00002158 <clear_stack>:
	else
		return -1;
}

void clear_stack(void)
{
    2158:	ec e5       	ldi	r30, 0x5C	; 92
    215a:	f1 e1       	ldi	r31, 0x11	; 17
	}
	else
		return -1;
}

void clear_stack(void)
    215c:	84 e2       	ldi	r24, 0x24	; 36
    215e:	92 e1       	ldi	r25, 0x12	; 18
{
	for(int i=0;i<100;i++)
	{
		store[i]=0;
    2160:	11 92       	st	Z+, r1
    2162:	11 92       	st	Z+, r1
		return -1;
}

void clear_stack(void)
{
	for(int i=0;i<100;i++)
    2164:	e8 17       	cp	r30, r24
    2166:	f9 07       	cpc	r31, r25
    2168:	d9 f7       	brne	.-10     	; 0x2160 <clear_stack+0x8>
	{
		store[i]=0;
	}
	sp=0;
    216a:	10 92 c9 0c 	sts	0x0CC9, r1
    216e:	10 92 c8 0c 	sts	0x0CC8, r1
}
    2172:	08 95       	ret

00002174 <goto_n>:
{
	go1(crt_node,pop());
}

int goto_n(int c_node,int d_node, int index)
{
    2174:	cf 92       	push	r12
    2176:	df 92       	push	r13
    2178:	ef 92       	push	r14
    217a:	ff 92       	push	r15
    217c:	0f 93       	push	r16
    217e:	1f 93       	push	r17
    2180:	cf 93       	push	r28
    2182:	df 93       	push	r29
    2184:	ec 01       	movw	r28, r24
    2186:	8b 01       	movw	r16, r22
    2188:	6a 01       	movw	r12, r20
	ACK=0;
    218a:	10 92 61 07 	sts	0x0761, r1
    218e:	10 92 60 07 	sts	0x0760, r1
	send(50,c_node,d_node);		// position flag
    2192:	0f 2e       	mov	r0, r31
    2194:	f9 e6       	ldi	r31, 0x69	; 105
    2196:	ef 2e       	mov	r14, r31
    2198:	f1 e0       	ldi	r31, 0x01	; 1
    219a:	ff 2e       	mov	r15, r31
    219c:	f0 2d       	mov	r31, r0
    219e:	82 e3       	ldi	r24, 0x32	; 50
    21a0:	90 e0       	ldi	r25, 0x00	; 0
    21a2:	be 01       	movw	r22, r28
    21a4:	a8 01       	movw	r20, r16
    21a6:	f7 01       	movw	r30, r14
    21a8:	19 95       	eicall
    21aa:	8f ef       	ldi	r24, 0xFF	; 255
    21ac:	9f e8       	ldi	r25, 0x8F	; 143
    21ae:	01 97       	sbiw	r24, 0x01	; 1
    21b0:	f1 f7       	brne	.-4      	; 0x21ae <goto_n+0x3a>
    21b2:	00 c0       	rjmp	.+0      	; 0x21b4 <goto_n+0x40>
    21b4:	00 00       	nop
	_delay_ms(10);
	if (ACK != 1)
    21b6:	80 91 60 07 	lds	r24, 0x0760
    21ba:	90 91 61 07 	lds	r25, 0x0761
    21be:	81 30       	cpi	r24, 0x01	; 1
    21c0:	91 05       	cpc	r25, r1
    21c2:	c9 f0       	breq	.+50     	; 0x21f6 <goto_n+0x82>
	{
		while(ACK !=1)
    21c4:	80 91 60 07 	lds	r24, 0x0760
    21c8:	90 91 61 07 	lds	r25, 0x0761
    21cc:	81 30       	cpi	r24, 0x01	; 1
    21ce:	91 05       	cpc	r25, r1
    21d0:	91 f0       	breq	.+36     	; 0x21f6 <goto_n+0x82>
		{
			send(50,c_node,d_node);
    21d2:	82 e3       	ldi	r24, 0x32	; 50
    21d4:	90 e0       	ldi	r25, 0x00	; 0
    21d6:	be 01       	movw	r22, r28
    21d8:	a8 01       	movw	r20, r16
    21da:	f7 01       	movw	r30, r14
    21dc:	19 95       	eicall
    21de:	86 e6       	ldi	r24, 0x66	; 102
    21e0:	9e e0       	ldi	r25, 0x0E	; 14
    21e2:	01 97       	sbiw	r24, 0x01	; 1
    21e4:	f1 f7       	brne	.-4      	; 0x21e2 <goto_n+0x6e>
    21e6:	00 00       	nop
	ACK=0;
	send(50,c_node,d_node);		// position flag
	_delay_ms(10);
	if (ACK != 1)
	{
		while(ACK !=1)
    21e8:	80 91 60 07 	lds	r24, 0x0760
    21ec:	90 91 61 07 	lds	r25, 0x0761
    21f0:	81 30       	cpi	r24, 0x01	; 1
    21f2:	91 05       	cpc	r25, r1
    21f4:	71 f7       	brne	.-36     	; 0x21d2 <goto_n+0x5e>
		{
			send(50,c_node,d_node);
			_delay_ms(1);
		}
	}
	ACK = 0;
    21f6:	10 92 61 07 	sts	0x0761, r1
    21fa:	10 92 60 07 	sts	0x0760, r1
				
	turn(c_node,d_node);
    21fe:	ce 01       	movw	r24, r28
    2200:	b8 01       	movw	r22, r16
    2202:	0e 94 69 0d 	call	0x1ad2	; 0x1ad2 <turn>
	
	lcd_print(1,6,c_node,2);
    2206:	81 e0       	ldi	r24, 0x01	; 1
    2208:	66 e0       	ldi	r22, 0x06	; 6
    220a:	ae 01       	movw	r20, r28
    220c:	22 e0       	ldi	r18, 0x02	; 2
    220e:	30 e0       	ldi	r19, 0x00	; 0
    2210:	0e 94 8f 02 	call	0x51e	; 0x51e <lcd_print>
	lcd_print(1,10,d_node,2);
    2214:	81 e0       	ldi	r24, 0x01	; 1
    2216:	6a e0       	ldi	r22, 0x0A	; 10
    2218:	a8 01       	movw	r20, r16
    221a:	22 e0       	ldi	r18, 0x02	; 2
    221c:	30 e0       	ldi	r19, 0x00	; 0
    221e:	0e 94 8f 02 	call	0x51e	; 0x51e <lcd_print>
	int retval=0;
	 	
	if(cost[c_node][d_node]==IN)
    2222:	8a e1       	ldi	r24, 0x1A	; 26
    2224:	90 e0       	ldi	r25, 0x00	; 0
    2226:	c8 9f       	mul	r28, r24
    2228:	90 01       	movw	r18, r0
    222a:	c9 9f       	mul	r28, r25
    222c:	30 0d       	add	r19, r0
    222e:	d8 9f       	mul	r29, r24
    2230:	30 0d       	add	r19, r0
    2232:	11 24       	eor	r1, r1
    2234:	20 0f       	add	r18, r16
    2236:	31 1f       	adc	r19, r17
    2238:	f9 01       	movw	r30, r18
    223a:	ee 0f       	add	r30, r30
    223c:	ff 1f       	adc	r31, r31
    223e:	e0 50       	subi	r30, 0x00	; 0
    2240:	fe 4f       	sbci	r31, 0xFE	; 254
    2242:	80 81       	ld	r24, Z
    2244:	91 81       	ldd	r25, Z+1	; 0x01
    2246:	83 36       	cpi	r24, 0x63	; 99
    2248:	91 05       	cpc	r25, r1
    224a:	09 f4       	brne	.+2      	; 0x224e <__stack+0x4f>
    224c:	42 c0       	rjmp	.+132    	; 0x22d2 <__stack+0xd3>
	{
		retval=-1;
	}
	else if(path[c_node][d_node]==1)
    224e:	8a e1       	ldi	r24, 0x1A	; 26
    2250:	90 e0       	ldi	r25, 0x00	; 0
    2252:	c8 9f       	mul	r28, r24
    2254:	90 01       	movw	r18, r0
    2256:	c9 9f       	mul	r28, r25
    2258:	30 0d       	add	r19, r0
    225a:	d8 9f       	mul	r29, r24
    225c:	30 0d       	add	r19, r0
    225e:	11 24       	eor	r1, r1
    2260:	20 0f       	add	r18, r16
    2262:	31 1f       	adc	r19, r17
    2264:	f9 01       	movw	r30, r18
    2266:	ee 0f       	add	r30, r30
    2268:	ff 1f       	adc	r31, r31
    226a:	e6 58       	subi	r30, 0x86	; 134
    226c:	f8 4f       	sbci	r31, 0xF8	; 248
    226e:	80 81       	ld	r24, Z
    2270:	91 81       	ldd	r25, Z+1	; 0x01
    2272:	81 30       	cpi	r24, 0x01	; 1
    2274:	91 05       	cpc	r25, r1
    2276:	79 f4       	brne	.+30     	; 0x2296 <__stack+0x97>
	{
		count++;
    2278:	80 91 6e 07 	lds	r24, 0x076E
    227c:	90 91 6f 07 	lds	r25, 0x076F
    2280:	01 96       	adiw	r24, 0x01	; 1
    2282:	90 93 6f 07 	sts	0x076F, r25
    2286:	80 93 6e 07 	sts	0x076E, r24
		retval = go(c_node,d_node,index);
    228a:	ce 01       	movw	r24, r28
    228c:	b8 01       	movw	r22, r16
    228e:	a6 01       	movw	r20, r12
    2290:	0e 94 04 15 	call	0x2a08	; 0x2a08 <go>
    2294:	20 c0       	rjmp	.+64     	; 0x22d6 <__stack+0xd7>
	}	
	else
	{
		int abs = detect_block(c_node,d_node);
    2296:	ce 01       	movw	r24, r28
    2298:	b8 01       	movw	r22, r16
    229a:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <detect_block>
	
		if(abs)
    229e:	00 97       	sbiw	r24, 0x00	; 0
    22a0:	49 f0       	breq	.+18     	; 0x22b4 <__stack+0xb5>
		{
			send(30,c_node,d_node);
    22a2:	8e e1       	ldi	r24, 0x1E	; 30
    22a4:	90 e0       	ldi	r25, 0x00	; 0
    22a6:	be 01       	movw	r22, r28
    22a8:	a8 01       	movw	r20, r16
    22aa:	f7 01       	movw	r30, r14
    22ac:	19 95       	eicall
			retval=-1;
    22ae:	8f ef       	ldi	r24, 0xFF	; 255
    22b0:	9f ef       	ldi	r25, 0xFF	; 255
    22b2:	11 c0       	rjmp	.+34     	; 0x22d6 <__stack+0xd7>
		}
		else
		{
			count++;
    22b4:	80 91 6e 07 	lds	r24, 0x076E
    22b8:	90 91 6f 07 	lds	r25, 0x076F
    22bc:	01 96       	adiw	r24, 0x01	; 1
    22be:	90 93 6f 07 	sts	0x076F, r25
    22c2:	80 93 6e 07 	sts	0x076E, r24
			retval = go(c_node,d_node,index);
    22c6:	ce 01       	movw	r24, r28
    22c8:	b8 01       	movw	r22, r16
    22ca:	a6 01       	movw	r20, r12
    22cc:	0e 94 04 15 	call	0x2a08	; 0x2a08 <go>
    22d0:	02 c0       	rjmp	.+4      	; 0x22d6 <__stack+0xd7>
	lcd_print(1,10,d_node,2);
	int retval=0;
	 	
	if(cost[c_node][d_node]==IN)
	{
		retval=-1;
    22d2:	8f ef       	ldi	r24, 0xFF	; 255
    22d4:	9f ef       	ldi	r25, 0xFF	; 255
			retval = go(c_node,d_node,index);
		}
	}
	
	return retval;
}
    22d6:	df 91       	pop	r29
    22d8:	cf 91       	pop	r28
    22da:	1f 91       	pop	r17
    22dc:	0f 91       	pop	r16
    22de:	ff 90       	pop	r15
    22e0:	ef 90       	pop	r14
    22e2:	df 90       	pop	r13
    22e4:	cf 90       	pop	r12
    22e6:	08 95       	ret

000022e8 <check_collision_midpoint>:
		turn(crtnode,nxtnode);
	}
}

void check_collision_midpoint(int crtnode,int nxtnode, int index)
{
    22e8:	2f 92       	push	r2
    22ea:	3f 92       	push	r3
    22ec:	4f 92       	push	r4
    22ee:	5f 92       	push	r5
    22f0:	6f 92       	push	r6
    22f2:	7f 92       	push	r7
    22f4:	8f 92       	push	r8
    22f6:	9f 92       	push	r9
    22f8:	af 92       	push	r10
    22fa:	bf 92       	push	r11
    22fc:	cf 92       	push	r12
    22fe:	df 92       	push	r13
    2300:	ef 92       	push	r14
    2302:	ff 92       	push	r15
    2304:	0f 93       	push	r16
    2306:	1f 93       	push	r17
    2308:	cf 93       	push	r28
    230a:	df 93       	push	r29
    230c:	00 d0       	rcall	.+0      	; 0x230e <check_collision_midpoint+0x26>
    230e:	00 d0       	rcall	.+0      	; 0x2310 <check_collision_midpoint+0x28>
    2310:	cd b7       	in	r28, 0x3d	; 61
    2312:	de b7       	in	r29, 0x3e	; 62
    2314:	4c 01       	movw	r8, r24
    2316:	6b 01       	movw	r12, r22
    2318:	2a 01       	movw	r4, r20
	int umpire=0;
	
	if (nxtnode == pos[1])
    231a:	00 91 46 11 	lds	r16, 0x1146
    231e:	10 91 47 11 	lds	r17, 0x1147
    2322:	06 17       	cp	r16, r22
    2324:	17 07       	cpc	r17, r23
    2326:	c1 f4       	brne	.+48     	; 0x2358 <check_collision_midpoint+0x70>
	{
		back();
    2328:	0e 94 3e 04 	call	0x87c	; 0x87c <back>
		linear_mm(240);
    232c:	60 ef       	ldi	r22, 0xF0	; 240
    232e:	70 e0       	ldi	r23, 0x00	; 0
    2330:	80 e0       	ldi	r24, 0x00	; 0
    2332:	90 e0       	ldi	r25, 0x00	; 0
    2334:	0e 94 5e 04 	call	0x8bc	; 0x8bc <linear_mm>
		umpire = 1;
		while(nxtnode != pos[0]);
    2338:	e4 e4       	ldi	r30, 0x44	; 68
    233a:	f1 e1       	ldi	r31, 0x11	; 17
    233c:	80 81       	ld	r24, Z
    233e:	91 81       	ldd	r25, Z+1	; 0x01
    2340:	08 17       	cp	r16, r24
    2342:	19 07       	cpc	r17, r25
    2344:	d9 f7       	brne	.-10     	; 0x233c <check_collision_midpoint+0x54>
    2346:	86 e6       	ldi	r24, 0x66	; 102
    2348:	9e e0       	ldi	r25, 0x0E	; 14
    234a:	01 97       	sbiw	r24, 0x01	; 1
    234c:	f1 f7       	brne	.-4      	; 0x234a <check_collision_midpoint+0x62>
    234e:	00 00       	nop
	
	if (nxtnode == pos[1])
	{
		back();
		linear_mm(240);
		umpire = 1;
    2350:	66 24       	eor	r6, r6
    2352:	77 24       	eor	r7, r7
    2354:	63 94       	inc	r6
    2356:	02 c0       	rjmp	.+4      	; 0x235c <check_collision_midpoint+0x74>
	}
}

void check_collision_midpoint(int crtnode,int nxtnode, int index)
{
	int umpire=0;
    2358:	66 24       	eor	r6, r6
    235a:	77 24       	eor	r7, r7
		while(nxtnode != pos[0]);
		_delay_ms(1);
		//_delay_ms(3000);
	}
	
	if ((pos[0] == nxtnode) && !((pos[0] == nxtnode) && (pos[1] == crtnode)))
    235c:	00 91 44 11 	lds	r16, 0x1144
    2360:	10 91 45 11 	lds	r17, 0x1145
    2364:	0c 15       	cp	r16, r12
    2366:	1d 05       	cpc	r17, r13
    2368:	09 f0       	breq	.+2      	; 0x236c <check_collision_midpoint+0x84>
    236a:	86 c0       	rjmp	.+268    	; 0x2478 <check_collision_midpoint+0x190>
    236c:	80 91 44 11 	lds	r24, 0x1144
    2370:	90 91 45 11 	lds	r25, 0x1145
    2374:	08 17       	cp	r16, r24
    2376:	19 07       	cpc	r17, r25
    2378:	41 f4       	brne	.+16     	; 0x238a <check_collision_midpoint+0xa2>
    237a:	80 91 46 11 	lds	r24, 0x1146
    237e:	90 91 47 11 	lds	r25, 0x1147
    2382:	88 15       	cp	r24, r8
    2384:	99 05       	cpc	r25, r9
    2386:	09 f4       	brne	.+2      	; 0x238a <check_collision_midpoint+0xa2>
    2388:	77 c0       	rjmp	.+238    	; 0x2478 <check_collision_midpoint+0x190>
	{
		if(!umpire)
    238a:	61 14       	cp	r6, r1
    238c:	71 04       	cpc	r7, r1
    238e:	59 f4       	brne	.+22     	; 0x23a6 <check_collision_midpoint+0xbe>
		{
			back();
    2390:	0e 94 3e 04 	call	0x87c	; 0x87c <back>
			linear_mm(240);
    2394:	60 ef       	ldi	r22, 0xF0	; 240
    2396:	70 e0       	ldi	r23, 0x00	; 0
    2398:	80 e0       	ldi	r24, 0x00	; 0
    239a:	90 e0       	ldi	r25, 0x00	; 0
    239c:	0e 94 5e 04 	call	0x8bc	; 0x8bc <linear_mm>
			umpire = 1;
    23a0:	66 24       	eor	r6, r6
    23a2:	77 24       	eor	r7, r7
    23a4:	63 94       	inc	r6
		}
		ACK=0;
    23a6:	10 92 61 07 	sts	0x0761, r1
    23aa:	10 92 60 07 	sts	0x0760, r1
		USART0_TX(85);
    23ae:	0f 2e       	mov	r0, r31
    23b0:	f1 e6       	ldi	r31, 0x61	; 97
    23b2:	ef 2e       	mov	r14, r31
    23b4:	f1 e0       	ldi	r31, 0x01	; 1
    23b6:	ff 2e       	mov	r15, r31
    23b8:	f0 2d       	mov	r31, r0
    23ba:	85 e5       	ldi	r24, 0x55	; 85
    23bc:	90 e0       	ldi	r25, 0x00	; 0
    23be:	f7 01       	movw	r30, r14
    23c0:	19 95       	eicall
    23c2:	af ef       	ldi	r26, 0xFF	; 255
    23c4:	bf e8       	ldi	r27, 0x8F	; 143
    23c6:	11 97       	sbiw	r26, 0x01	; 1
    23c8:	f1 f7       	brne	.-4      	; 0x23c6 <check_collision_midpoint+0xde>
    23ca:	00 c0       	rjmp	.+0      	; 0x23cc <check_collision_midpoint+0xe4>
    23cc:	00 00       	nop
		//	if (search_complete_flag==0)
		{
			_delay_ms(10);
			while(ACK == 0)
    23ce:	80 91 60 07 	lds	r24, 0x0760
    23d2:	90 91 61 07 	lds	r25, 0x0761
    23d6:	00 97       	sbiw	r24, 0x00	; 0
    23d8:	79 f4       	brne	.+30     	; 0x23f8 <check_collision_midpoint+0x110>
			{
				USART0_TX(85);
    23da:	85 e5       	ldi	r24, 0x55	; 85
    23dc:	90 e0       	ldi	r25, 0x00	; 0
    23de:	f7 01       	movw	r30, r14
    23e0:	19 95       	eicall
    23e2:	e6 e6       	ldi	r30, 0x66	; 102
    23e4:	fe e0       	ldi	r31, 0x0E	; 14
    23e6:	31 97       	sbiw	r30, 0x01	; 1
    23e8:	f1 f7       	brne	.-4      	; 0x23e6 <check_collision_midpoint+0xfe>
    23ea:	00 00       	nop
		ACK=0;
		USART0_TX(85);
		//	if (search_complete_flag==0)
		{
			_delay_ms(10);
			while(ACK == 0)
    23ec:	80 91 60 07 	lds	r24, 0x0760
    23f0:	90 91 61 07 	lds	r25, 0x0761
    23f4:	00 97       	sbiw	r24, 0x00	; 0
    23f6:	89 f3       	breq	.-30     	; 0x23da <check_collision_midpoint+0xf2>
			{
				USART0_TX(85);
				_delay_ms(1);
			}
			ACK = 0;
    23f8:	10 92 61 07 	sts	0x0761, r1
    23fc:	10 92 60 07 	sts	0x0760, r1
		}
		
		while(midpoint_flag == 0)
    2400:	80 91 5c 07 	lds	r24, 0x075C
    2404:	90 91 5d 07 	lds	r25, 0x075D
    2408:	00 97       	sbiw	r24, 0x00	; 0
    240a:	91 f5       	brne	.+100    	; 0x2470 <check_collision_midpoint+0x188>
		{
			USART0_TX(85);
			if (pos[0] != nxtnode)
    240c:	0f 2e       	mov	r0, r31
    240e:	f4 e4       	ldi	r31, 0x44	; 68
    2410:	2f 2e       	mov	r2, r31
    2412:	f1 e1       	ldi	r31, 0x11	; 17
    2414:	3f 2e       	mov	r3, r31
    2416:	f0 2d       	mov	r31, r0
			{
				break;
			}
			if((pos[0] == nxtnode) && (pos[1] == crtnode))
    2418:	0f 2e       	mov	r0, r31
    241a:	f6 e4       	ldi	r31, 0x46	; 70
    241c:	af 2e       	mov	r10, r31
    241e:	f1 e1       	ldi	r31, 0x11	; 17
    2420:	bf 2e       	mov	r11, r31
    2422:	f0 2d       	mov	r31, r0
			ACK = 0;
		}
		
		while(midpoint_flag == 0)
		{
			USART0_TX(85);
    2424:	85 e5       	ldi	r24, 0x55	; 85
    2426:	90 e0       	ldi	r25, 0x00	; 0
    2428:	f7 01       	movw	r30, r14
    242a:	19 95       	eicall
			if (pos[0] != nxtnode)
    242c:	d1 01       	movw	r26, r2
    242e:	8d 91       	ld	r24, X+
    2430:	9c 91       	ld	r25, X
    2432:	11 97       	sbiw	r26, 0x01	; 1
    2434:	08 17       	cp	r16, r24
    2436:	19 07       	cpc	r17, r25
    2438:	d9 f4       	brne	.+54     	; 0x2470 <check_collision_midpoint+0x188>
			{
				break;
			}
			if((pos[0] == nxtnode) && (pos[1] == crtnode))
    243a:	8d 91       	ld	r24, X+
    243c:	9c 91       	ld	r25, X
    243e:	11 97       	sbiw	r26, 0x01	; 1
    2440:	08 17       	cp	r16, r24
    2442:	19 07       	cpc	r17, r25
    2444:	31 f4       	brne	.+12     	; 0x2452 <check_collision_midpoint+0x16a>
    2446:	f5 01       	movw	r30, r10
    2448:	80 81       	ld	r24, Z
    244a:	91 81       	ldd	r25, Z+1	; 0x01
    244c:	88 15       	cp	r24, r8
    244e:	99 05       	cpc	r25, r9
    2450:	79 f0       	breq	.+30     	; 0x2470 <check_collision_midpoint+0x188>
    2452:	2f ef       	ldi	r18, 0xFF	; 255
    2454:	3f e7       	ldi	r19, 0x7F	; 127
    2456:	44 e0       	ldi	r20, 0x04	; 4
    2458:	21 50       	subi	r18, 0x01	; 1
    245a:	30 40       	sbci	r19, 0x00	; 0
    245c:	40 40       	sbci	r20, 0x00	; 0
    245e:	e1 f7       	brne	.-8      	; 0x2458 <check_collision_midpoint+0x170>
    2460:	00 c0       	rjmp	.+0      	; 0x2462 <check_collision_midpoint+0x17a>
    2462:	00 00       	nop
				_delay_ms(1);
			}
			ACK = 0;
		}
		
		while(midpoint_flag == 0)
    2464:	80 91 5c 07 	lds	r24, 0x075C
    2468:	90 91 5d 07 	lds	r25, 0x075D
    246c:	00 97       	sbiw	r24, 0x00	; 0
    246e:	d1 f2       	breq	.-76     	; 0x2424 <check_collision_midpoint+0x13c>
			{
				break;
			}
			_delay_ms(100);
		}
		midpoint_flag = 0;
    2470:	10 92 5d 07 	sts	0x075D, r1
    2474:	10 92 5c 07 	sts	0x075C, r1
	}
	
	if((pos[0] == nxtnode) && (pos[1] == crtnode))
    2478:	a0 90 44 11 	lds	r10, 0x1144
    247c:	b0 90 45 11 	lds	r11, 0x1145
    2480:	ac 14       	cp	r10, r12
    2482:	bd 04       	cpc	r11, r13
    2484:	09 f0       	breq	.+2      	; 0x2488 <check_collision_midpoint+0x1a0>
    2486:	00 c1       	rjmp	.+512    	; 0x2688 <check_collision_midpoint+0x3a0>
    2488:	c0 90 46 11 	lds	r12, 0x1146
    248c:	d0 90 47 11 	lds	r13, 0x1147
    2490:	c8 14       	cp	r12, r8
    2492:	d9 04       	cpc	r13, r9
    2494:	09 f0       	breq	.+2      	; 0x2498 <check_collision_midpoint+0x1b0>
    2496:	f8 c0       	rjmp	.+496    	; 0x2688 <check_collision_midpoint+0x3a0>
	{
		if(!umpire)
    2498:	61 14       	cp	r6, r1
    249a:	71 04       	cpc	r7, r1
    249c:	59 f4       	brne	.+22     	; 0x24b4 <check_collision_midpoint+0x1cc>
		{
			back();
    249e:	0e 94 3e 04 	call	0x87c	; 0x87c <back>
			linear_mm(240);
    24a2:	60 ef       	ldi	r22, 0xF0	; 240
    24a4:	70 e0       	ldi	r23, 0x00	; 0
    24a6:	80 e0       	ldi	r24, 0x00	; 0
    24a8:	90 e0       	ldi	r25, 0x00	; 0
    24aa:	0e 94 5e 04 	call	0x8bc	; 0x8bc <linear_mm>
			umpire = 1;
    24ae:	66 24       	eor	r6, r6
    24b0:	77 24       	eor	r7, r7
    24b2:	63 94       	inc	r6
		}
		
		int move_flag=0;
		
		int t_node = crt_node;
    24b4:	40 91 4c 07 	lds	r20, 0x074C
    24b8:	50 91 4d 07 	lds	r21, 0x074D
    24bc:	5c 83       	std	Y+4, r21	; 0x04
    24be:	4b 83       	std	Y+3, r20	; 0x03
		
		turn(crtnode,nxtnode);
	}
}

void check_collision_midpoint(int crtnode,int nxtnode, int index)
    24c0:	c6 01       	movw	r24, r12
    24c2:	88 0f       	add	r24, r24
    24c4:	99 1f       	adc	r25, r25
    24c6:	8c 0d       	add	r24, r12
    24c8:	9d 1d       	adc	r25, r13
    24ca:	9c 01       	movw	r18, r24
    24cc:	22 0f       	add	r18, r18
    24ce:	33 1f       	adc	r19, r19
    24d0:	22 0f       	add	r18, r18
    24d2:	33 1f       	adc	r19, r19
    24d4:	22 0f       	add	r18, r18
    24d6:	33 1f       	adc	r19, r19
    24d8:	d9 01       	movw	r26, r18
    24da:	a8 1b       	sub	r26, r24
    24dc:	b9 0b       	sbc	r27, r25
    24de:	cd 01       	movw	r24, r26
    24e0:	8c 0d       	add	r24, r12
    24e2:	9d 1d       	adc	r25, r13
    24e4:	8c 01       	movw	r16, r24
    24e6:	02 50       	subi	r16, 0x02	; 2
    24e8:	11 4f       	sbci	r17, 0xF1	; 241
		
		int move_flag=0;
		
		int t_node = crt_node;
		
		for (int j=1;j<=4;j++)
    24ea:	ee 24       	eor	r14, r14
    24ec:	ff 24       	eor	r15, r15
    24ee:	e3 94       	inc	r14
		{
			if(n[crtnode].adjn[j] == 0)
			{
				move_flag = 1;
    24f0:	22 24       	eor	r2, r2
    24f2:	33 24       	eor	r3, r3
    24f4:	23 94       	inc	r2
			else if ( n[crtnode].adjn[j] == store[sp])
			{
				move_flag = 1;
				//continue;
			}
			else if (cost[crtnode][n[crtnode].adjn[j]] == IN)
    24f6:	8a e1       	ldi	r24, 0x1A	; 26
    24f8:	90 e0       	ldi	r25, 0x00	; 0
    24fa:	c8 9e       	mul	r12, r24
    24fc:	f0 01       	movw	r30, r0
    24fe:	c9 9e       	mul	r12, r25
    2500:	f0 0d       	add	r31, r0
    2502:	d8 9e       	mul	r13, r24
    2504:	f0 0d       	add	r31, r0
    2506:	11 24       	eor	r1, r1
    2508:	fa 83       	std	Y+2, r31	; 0x02
    250a:	e9 83       	std	Y+1, r30	; 0x01
				int temp=detect_block(crtnode,n[crtnode].adjn[j]);
				
				if( temp == 0)
				{
					node_check = 0;
					send1(90,n[crt_node].adjn[j]);
    250c:	c5 01       	movw	r24, r10
    250e:	1e 83       	std	Y+6, r17	; 0x06
    2510:	0d 83       	std	Y+5, r16	; 0x05
    2512:	56 01       	movw	r10, r12
    2514:	8c 01       	movw	r16, r24
		
		turn(crtnode,nxtnode);
	}
}

void check_collision_midpoint(int crtnode,int nxtnode, int index)
    2516:	cd 80       	ldd	r12, Y+5	; 0x05
    2518:	de 80       	ldd	r13, Y+6	; 0x06
		
		int t_node = crt_node;
		
		for (int j=1;j<=4;j++)
		{
			if(n[crtnode].adjn[j] == 0)
    251a:	d6 01       	movw	r26, r12
    251c:	6d 91       	ld	r22, X+
    251e:	7c 91       	ld	r23, X
    2520:	11 97       	sbiw	r26, 0x01	; 1
    2522:	61 15       	cp	r22, r1
    2524:	71 05       	cpc	r23, r1
    2526:	09 f4       	brne	.+2      	; 0x252a <check_collision_midpoint+0x242>
    2528:	83 c0       	rjmp	.+262    	; 0x2630 <check_collision_midpoint+0x348>
			{
				move_flag = 1;
			}
			else if ( n[crtnode].adjn[j] == nxtnode )
    252a:	06 17       	cp	r16, r22
    252c:	17 07       	cpc	r17, r23
    252e:	09 f4       	brne	.+2      	; 0x2532 <check_collision_midpoint+0x24a>
    2530:	81 c0       	rjmp	.+258    	; 0x2634 <check_collision_midpoint+0x34c>
			{
				move_flag = 1;
				//continue;
			}
			else if ( n[crtnode].adjn[j] == store[sp])
    2532:	80 91 c8 0c 	lds	r24, 0x0CC8
    2536:	90 91 c9 0c 	lds	r25, 0x0CC9
    253a:	88 0f       	add	r24, r24
    253c:	99 1f       	adc	r25, r25
    253e:	84 5a       	subi	r24, 0xA4	; 164
    2540:	9e 4e       	sbci	r25, 0xEE	; 238
    2542:	fc 01       	movw	r30, r24
    2544:	80 81       	ld	r24, Z
    2546:	91 81       	ldd	r25, Z+1	; 0x01
    2548:	68 17       	cp	r22, r24
    254a:	79 07       	cpc	r23, r25
    254c:	09 f4       	brne	.+2      	; 0x2550 <check_collision_midpoint+0x268>
    254e:	74 c0       	rjmp	.+232    	; 0x2638 <check_collision_midpoint+0x350>
			{
				move_flag = 1;
				//continue;
			}
			else if (cost[crtnode][n[crtnode].adjn[j]] == IN)
    2550:	89 81       	ldd	r24, Y+1	; 0x01
    2552:	9a 81       	ldd	r25, Y+2	; 0x02
    2554:	86 0f       	add	r24, r22
    2556:	97 1f       	adc	r25, r23
    2558:	88 0f       	add	r24, r24
    255a:	99 1f       	adc	r25, r25
    255c:	80 50       	subi	r24, 0x00	; 0
    255e:	9e 4f       	sbci	r25, 0xFE	; 254
    2560:	dc 01       	movw	r26, r24
    2562:	8d 91       	ld	r24, X+
    2564:	9c 91       	ld	r25, X
    2566:	11 97       	sbiw	r26, 0x01	; 1
    2568:	83 36       	cpi	r24, 0x63	; 99
    256a:	91 05       	cpc	r25, r1
    256c:	09 f4       	brne	.+2      	; 0x2570 <check_collision_midpoint+0x288>
    256e:	66 c0       	rjmp	.+204    	; 0x263c <check_collision_midpoint+0x354>
				move_flag = 1;
				//continue;
			}
			else
			{
				turn(crtnode,n[crtnode].adjn[j]);
    2570:	c5 01       	movw	r24, r10
    2572:	0e 94 69 0d 	call	0x1ad2	; 0x1ad2 <turn>
				move_flag =1;
				int temp=detect_block(crtnode,n[crtnode].adjn[j]);
    2576:	f6 01       	movw	r30, r12
    2578:	60 81       	ld	r22, Z
    257a:	71 81       	ldd	r23, Z+1	; 0x01
    257c:	c5 01       	movw	r24, r10
    257e:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <detect_block>
				
				if( temp == 0)
    2582:	00 97       	sbiw	r24, 0x00	; 0
    2584:	09 f0       	breq	.+2      	; 0x2588 <check_collision_midpoint+0x2a0>
    2586:	5c c0       	rjmp	.+184    	; 0x2640 <check_collision_midpoint+0x358>
				{
					node_check = 0;
    2588:	10 92 63 07 	sts	0x0763, r1
    258c:	10 92 62 07 	sts	0x0762, r1
					send1(90,n[crt_node].adjn[j]);
    2590:	40 91 4c 07 	lds	r20, 0x074C
    2594:	50 91 4d 07 	lds	r21, 0x074D
    2598:	ca 01       	movw	r24, r20
    259a:	88 0f       	add	r24, r24
    259c:	99 1f       	adc	r25, r25
    259e:	9a 01       	movw	r18, r20
    25a0:	22 0f       	add	r18, r18
    25a2:	33 1f       	adc	r19, r19
    25a4:	22 0f       	add	r18, r18
    25a6:	33 1f       	adc	r19, r19
    25a8:	22 0f       	add	r18, r18
    25aa:	33 1f       	adc	r19, r19
    25ac:	82 0f       	add	r24, r18
    25ae:	93 1f       	adc	r25, r19
    25b0:	84 0f       	add	r24, r20
    25b2:	95 1f       	adc	r25, r21
    25b4:	8e 0d       	add	r24, r14
    25b6:	9f 1d       	adc	r25, r15
    25b8:	88 0f       	add	r24, r24
    25ba:	99 1f       	adc	r25, r25
    25bc:	84 50       	subi	r24, 0x04	; 4
    25be:	91 4f       	sbci	r25, 0xF1	; 241
    25c0:	dc 01       	movw	r26, r24
    25c2:	6d 91       	ld	r22, X+
    25c4:	7c 91       	ld	r23, X
    25c6:	8a e5       	ldi	r24, 0x5A	; 90
    25c8:	90 e0       	ldi	r25, 0x00	; 0
    25ca:	0e 94 9c 01 	call	0x338	; 0x338 <send1>
    25ce:	2d 81       	ldd	r18, Y+5	; 0x05
    25d0:	3e 81       	ldd	r19, Y+6	; 0x06
					while(node_check == 0);
    25d2:	80 91 62 07 	lds	r24, 0x0762
    25d6:	90 91 63 07 	lds	r25, 0x0763
    25da:	00 97       	sbiw	r24, 0x00	; 0
    25dc:	d1 f3       	breq	.-12     	; 0x25d2 <check_collision_midpoint+0x2ea>
    25de:	3e 83       	std	Y+6, r19	; 0x06
    25e0:	2d 83       	std	Y+5, r18	; 0x05
					if (node_ok)
    25e2:	80 91 64 07 	lds	r24, 0x0764
    25e6:	90 91 65 07 	lds	r25, 0x0765
    25ea:	00 97       	sbiw	r24, 0x00	; 0
    25ec:	59 f1       	breq	.+86     	; 0x2644 <check_collision_midpoint+0x35c>
					{
						move_flag = 0;
						go1(crtnode,n[crt_node].adjn[j]);
    25ee:	40 91 4c 07 	lds	r20, 0x074C
    25f2:	50 91 4d 07 	lds	r21, 0x074D
    25f6:	ca 01       	movw	r24, r20
    25f8:	88 0f       	add	r24, r24
    25fa:	99 1f       	adc	r25, r25
    25fc:	9a 01       	movw	r18, r20
    25fe:	22 0f       	add	r18, r18
    2600:	33 1f       	adc	r19, r19
    2602:	22 0f       	add	r18, r18
    2604:	33 1f       	adc	r19, r19
    2606:	22 0f       	add	r18, r18
    2608:	33 1f       	adc	r19, r19
    260a:	82 0f       	add	r24, r18
    260c:	93 1f       	adc	r25, r19
    260e:	84 0f       	add	r24, r20
    2610:	95 1f       	adc	r25, r21
    2612:	8e 0d       	add	r24, r14
    2614:	9f 1d       	adc	r25, r15
    2616:	88 0f       	add	r24, r24
    2618:	99 1f       	adc	r25, r25
    261a:	84 50       	subi	r24, 0x04	; 4
    261c:	91 4f       	sbci	r25, 0xF1	; 241
    261e:	fc 01       	movw	r30, r24
    2620:	60 81       	ld	r22, Z
    2622:	71 81       	ldd	r23, Z+1	; 0x01
    2624:	c5 01       	movw	r24, r10
    2626:	0e 94 84 0d 	call	0x1b08	; 0x1b08 <go1>
					node_check = 0;
					send1(90,n[crt_node].adjn[j]);
					while(node_check == 0);
					if (node_ok)
					{
						move_flag = 0;
    262a:	80 e0       	ldi	r24, 0x00	; 0
    262c:	90 e0       	ldi	r25, 0x00	; 0
    262e:	0b c0       	rjmp	.+22     	; 0x2646 <check_collision_midpoint+0x35e>
		
		for (int j=1;j<=4;j++)
		{
			if(n[crtnode].adjn[j] == 0)
			{
				move_flag = 1;
    2630:	c1 01       	movw	r24, r2
    2632:	09 c0       	rjmp	.+18     	; 0x2646 <check_collision_midpoint+0x35e>
			}
			else if ( n[crtnode].adjn[j] == nxtnode )
			{
				move_flag = 1;
    2634:	c1 01       	movw	r24, r2
    2636:	07 c0       	rjmp	.+14     	; 0x2646 <check_collision_midpoint+0x35e>
				//continue;
			}
			else if ( n[crtnode].adjn[j] == store[sp])
			{
				move_flag = 1;
    2638:	c1 01       	movw	r24, r2
    263a:	05 c0       	rjmp	.+10     	; 0x2646 <check_collision_midpoint+0x35e>
				//continue;
			}
			else if (cost[crtnode][n[crtnode].adjn[j]] == IN)
			{
				move_flag = 1;
    263c:	c1 01       	movw	r24, r2
    263e:	03 c0       	rjmp	.+6      	; 0x2646 <check_collision_midpoint+0x35e>
				//continue;
			}
			else
			{
				turn(crtnode,n[crtnode].adjn[j]);
				move_flag =1;
    2640:	c1 01       	movw	r24, r2
    2642:	01 c0       	rjmp	.+2      	; 0x2646 <check_collision_midpoint+0x35e>
						move_flag = 0;
						go1(crtnode,n[crt_node].adjn[j]);
					}
					else
					{
						move_flag =1;
    2644:	c1 01       	movw	r24, r2
		
		int move_flag=0;
		
		int t_node = crt_node;
		
		for (int j=1;j<=4;j++)
    2646:	08 94       	sec
    2648:	e1 1c       	adc	r14, r1
    264a:	f1 1c       	adc	r15, r1
    264c:	2d 81       	ldd	r18, Y+5	; 0x05
    264e:	3e 81       	ldd	r19, Y+6	; 0x06
    2650:	2e 5f       	subi	r18, 0xFE	; 254
    2652:	3f 4f       	sbci	r19, 0xFF	; 255
    2654:	3e 83       	std	Y+6, r19	; 0x06
    2656:	2d 83       	std	Y+5, r18	; 0x05
    2658:	35 e0       	ldi	r19, 0x05	; 5
    265a:	e3 16       	cp	r14, r19
    265c:	f1 04       	cpc	r15, r1
    265e:	09 f0       	breq	.+2      	; 0x2662 <check_collision_midpoint+0x37a>
    2660:	5a cf       	rjmp	.-332    	; 0x2516 <check_collision_midpoint+0x22e>
    2662:	58 01       	movw	r10, r16
					}
				}
			}
		}
		
		if (move_flag == 1)
    2664:	81 30       	cpi	r24, 0x01	; 1
    2666:	91 05       	cpc	r25, r1
    2668:	11 f4       	brne	.+4      	; 0x266e <check_collision_midpoint+0x386>
		{
			//goto_n(crt_node,prv_node,index);
			go_back();
    266a:	0e 94 9d 10 	call	0x213a	; 0x213a <go_back>
		}
		
		//while(nxtnode == pos[1] );
		
		//move(crt_node,t_node,index);
		goto_n(crt_node,t_node,index);
    266e:	80 91 4c 07 	lds	r24, 0x074C
    2672:	90 91 4d 07 	lds	r25, 0x074D
    2676:	6b 81       	ldd	r22, Y+3	; 0x03
    2678:	7c 81       	ldd	r23, Y+4	; 0x04
    267a:	a2 01       	movw	r20, r4
    267c:	0e 94 ba 10 	call	0x2174	; 0x2174 <goto_n>
		
		turn(crtnode,nxtnode);
    2680:	c4 01       	movw	r24, r8
    2682:	b5 01       	movw	r22, r10
    2684:	0e 94 69 0d 	call	0x1ad2	; 0x1ad2 <turn>
	}
	
	if (umpire)
    2688:	61 14       	cp	r6, r1
    268a:	71 04       	cpc	r7, r1
    268c:	21 f0       	breq	.+8      	; 0x2696 <check_collision_midpoint+0x3ae>
	{
		path_node(1);
    268e:	81 e0       	ldi	r24, 0x01	; 1
    2690:	90 e0       	ldi	r25, 0x00	; 0
    2692:	0e 94 be 05 	call	0xb7c	; 0xb7c <path_node>
		umpire = 0;
	}
}
    2696:	26 96       	adiw	r28, 0x06	; 6
    2698:	0f b6       	in	r0, 0x3f	; 63
    269a:	f8 94       	cli
    269c:	de bf       	out	0x3e, r29	; 62
    269e:	0f be       	out	0x3f, r0	; 63
    26a0:	cd bf       	out	0x3d, r28	; 61
    26a2:	df 91       	pop	r29
    26a4:	cf 91       	pop	r28
    26a6:	1f 91       	pop	r17
    26a8:	0f 91       	pop	r16
    26aa:	ff 90       	pop	r15
    26ac:	ef 90       	pop	r14
    26ae:	df 90       	pop	r13
    26b0:	cf 90       	pop	r12
    26b2:	bf 90       	pop	r11
    26b4:	af 90       	pop	r10
    26b6:	9f 90       	pop	r9
    26b8:	8f 90       	pop	r8
    26ba:	7f 90       	pop	r7
    26bc:	6f 90       	pop	r6
    26be:	5f 90       	pop	r5
    26c0:	4f 90       	pop	r4
    26c2:	3f 90       	pop	r3
    26c4:	2f 90       	pop	r2
    26c6:	08 95       	ret

000026c8 <check_collision>:
	
	return retval;
}

void check_collision(int crtnode, int nxtnode, int index)
{
    26c8:	2f 92       	push	r2
    26ca:	3f 92       	push	r3
    26cc:	4f 92       	push	r4
    26ce:	5f 92       	push	r5
    26d0:	6f 92       	push	r6
    26d2:	7f 92       	push	r7
    26d4:	8f 92       	push	r8
    26d6:	9f 92       	push	r9
    26d8:	af 92       	push	r10
    26da:	bf 92       	push	r11
    26dc:	cf 92       	push	r12
    26de:	df 92       	push	r13
    26e0:	ef 92       	push	r14
    26e2:	ff 92       	push	r15
    26e4:	0f 93       	push	r16
    26e6:	1f 93       	push	r17
    26e8:	cf 93       	push	r28
    26ea:	df 93       	push	r29
    26ec:	00 d0       	rcall	.+0      	; 0x26ee <check_collision+0x26>
    26ee:	0f 92       	push	r0
    26f0:	cd b7       	in	r28, 0x3d	; 61
    26f2:	de b7       	in	r29, 0x3e	; 62
    26f4:	4c 01       	movw	r8, r24
    26f6:	5b 01       	movw	r10, r22
    26f8:	2a 01       	movw	r4, r20
	if (nxtnode == pos[1])
    26fa:	20 91 46 11 	lds	r18, 0x1146
    26fe:	30 91 47 11 	lds	r19, 0x1147
    2702:	26 17       	cp	r18, r22
    2704:	37 07       	cpc	r19, r23
    2706:	61 f4       	brne	.+24     	; 0x2720 <check_collision+0x58>
	{
		while(nxtnode == pos[1]);	////while(nxtnode == pos[1]);
    2708:	e6 e4       	ldi	r30, 0x46	; 70
    270a:	f1 e1       	ldi	r31, 0x11	; 17
    270c:	80 81       	ld	r24, Z
    270e:	91 81       	ldd	r25, Z+1	; 0x01
    2710:	28 17       	cp	r18, r24
    2712:	39 07       	cpc	r19, r25
    2714:	d9 f3       	breq	.-10     	; 0x270c <check_collision+0x44>
    2716:	86 e6       	ldi	r24, 0x66	; 102
    2718:	9e e0       	ldi	r25, 0x0E	; 14
    271a:	01 97       	sbiw	r24, 0x01	; 1
    271c:	f1 f7       	brne	.-4      	; 0x271a <check_collision+0x52>
    271e:	00 00       	nop
		_delay_ms(1);
		//while(nxtnode == pos[1]);	////while(nxtnode == pos[1]);		
	}
	
	if ((pos[0] == nxtnode) && !((pos[0] == nxtnode) && (pos[1] == crtnode)))
    2720:	00 91 44 11 	lds	r16, 0x1144
    2724:	10 91 45 11 	lds	r17, 0x1145
    2728:	0a 15       	cp	r16, r10
    272a:	1b 05       	cpc	r17, r11
    272c:	09 f0       	breq	.+2      	; 0x2730 <check_collision+0x68>
    272e:	78 c0       	rjmp	.+240    	; 0x2820 <check_collision+0x158>
    2730:	80 91 44 11 	lds	r24, 0x1144
    2734:	90 91 45 11 	lds	r25, 0x1145
    2738:	08 17       	cp	r16, r24
    273a:	19 07       	cpc	r17, r25
    273c:	41 f4       	brne	.+16     	; 0x274e <check_collision+0x86>
    273e:	80 91 46 11 	lds	r24, 0x1146
    2742:	90 91 47 11 	lds	r25, 0x1147
    2746:	88 15       	cp	r24, r8
    2748:	99 05       	cpc	r25, r9
    274a:	09 f4       	brne	.+2      	; 0x274e <check_collision+0x86>
    274c:	69 c0       	rjmp	.+210    	; 0x2820 <check_collision+0x158>
	{
		ACK=0;
    274e:	10 92 61 07 	sts	0x0761, r1
    2752:	10 92 60 07 	sts	0x0760, r1
		USART0_TX(85);
    2756:	0f 2e       	mov	r0, r31
    2758:	f1 e6       	ldi	r31, 0x61	; 97
    275a:	ef 2e       	mov	r14, r31
    275c:	f1 e0       	ldi	r31, 0x01	; 1
    275e:	ff 2e       	mov	r15, r31
    2760:	f0 2d       	mov	r31, r0
    2762:	85 e5       	ldi	r24, 0x55	; 85
    2764:	90 e0       	ldi	r25, 0x00	; 0
    2766:	f7 01       	movw	r30, r14
    2768:	19 95       	eicall
		//if (search_complete_flag==0)
		{
			//_delay_ms(10);
			while(ACK == 0)
    276a:	80 91 60 07 	lds	r24, 0x0760
    276e:	90 91 61 07 	lds	r25, 0x0761
    2772:	00 97       	sbiw	r24, 0x00	; 0
    2774:	79 f4       	brne	.+30     	; 0x2794 <check_collision+0xcc>
			{
				USART0_TX(85);
    2776:	85 e5       	ldi	r24, 0x55	; 85
    2778:	90 e0       	ldi	r25, 0x00	; 0
    277a:	f7 01       	movw	r30, r14
    277c:	19 95       	eicall
    277e:	a6 e6       	ldi	r26, 0x66	; 102
    2780:	be e0       	ldi	r27, 0x0E	; 14
    2782:	11 97       	sbiw	r26, 0x01	; 1
    2784:	f1 f7       	brne	.-4      	; 0x2782 <check_collision+0xba>
    2786:	00 00       	nop
		ACK=0;
		USART0_TX(85);
		//if (search_complete_flag==0)
		{
			//_delay_ms(10);
			while(ACK == 0)
    2788:	80 91 60 07 	lds	r24, 0x0760
    278c:	90 91 61 07 	lds	r25, 0x0761
    2790:	00 97       	sbiw	r24, 0x00	; 0
    2792:	89 f3       	breq	.-30     	; 0x2776 <check_collision+0xae>
			{
				USART0_TX(85);
				_delay_ms(1);
			}
			ACK = 0;
    2794:	10 92 61 07 	sts	0x0761, r1
    2798:	10 92 60 07 	sts	0x0760, r1
			
		}
		//_delay_ms(500);
		while(midpoint_flag == 0)
    279c:	80 91 5c 07 	lds	r24, 0x075C
    27a0:	90 91 5d 07 	lds	r25, 0x075D
    27a4:	00 97       	sbiw	r24, 0x00	; 0
    27a6:	71 f5       	brne	.+92     	; 0x2804 <check_collision+0x13c>
		{
			USART0_TX(85);
			if (pos[0] != nxtnode)
    27a8:	0f 2e       	mov	r0, r31
    27aa:	f4 e4       	ldi	r31, 0x44	; 68
    27ac:	6f 2e       	mov	r6, r31
    27ae:	f1 e1       	ldi	r31, 0x11	; 17
    27b0:	7f 2e       	mov	r7, r31
    27b2:	f0 2d       	mov	r31, r0
			{
				break;
			}
			if((pos[0] == nxtnode) && (pos[1] == crtnode))
    27b4:	0f 2e       	mov	r0, r31
    27b6:	f6 e4       	ldi	r31, 0x46	; 70
    27b8:	cf 2e       	mov	r12, r31
    27ba:	f1 e1       	ldi	r31, 0x11	; 17
    27bc:	df 2e       	mov	r13, r31
    27be:	f0 2d       	mov	r31, r0
			
		}
		//_delay_ms(500);
		while(midpoint_flag == 0)
		{
			USART0_TX(85);
    27c0:	85 e5       	ldi	r24, 0x55	; 85
    27c2:	90 e0       	ldi	r25, 0x00	; 0
    27c4:	f7 01       	movw	r30, r14
    27c6:	19 95       	eicall
			if (pos[0] != nxtnode)
    27c8:	f3 01       	movw	r30, r6
    27ca:	80 81       	ld	r24, Z
    27cc:	91 81       	ldd	r25, Z+1	; 0x01
    27ce:	08 17       	cp	r16, r24
    27d0:	19 07       	cpc	r17, r25
    27d2:	c1 f4       	brne	.+48     	; 0x2804 <check_collision+0x13c>
			{
				break;
			}
			if((pos[0] == nxtnode) && (pos[1] == crtnode))
    27d4:	80 81       	ld	r24, Z
    27d6:	91 81       	ldd	r25, Z+1	; 0x01
    27d8:	08 17       	cp	r16, r24
    27da:	19 07       	cpc	r17, r25
    27dc:	39 f4       	brne	.+14     	; 0x27ec <check_collision+0x124>
    27de:	d6 01       	movw	r26, r12
    27e0:	8d 91       	ld	r24, X+
    27e2:	9c 91       	ld	r25, X
    27e4:	11 97       	sbiw	r26, 0x01	; 1
    27e6:	88 15       	cp	r24, r8
    27e8:	99 05       	cpc	r25, r9
    27ea:	61 f0       	breq	.+24     	; 0x2804 <check_collision+0x13c>
    27ec:	ef ef       	ldi	r30, 0xFF	; 255
    27ee:	ff e8       	ldi	r31, 0x8F	; 143
    27f0:	31 97       	sbiw	r30, 0x01	; 1
    27f2:	f1 f7       	brne	.-4      	; 0x27f0 <check_collision+0x128>
    27f4:	00 c0       	rjmp	.+0      	; 0x27f6 <check_collision+0x12e>
    27f6:	00 00       	nop
			}
			ACK = 0;
			
		}
		//_delay_ms(500);
		while(midpoint_flag == 0)
    27f8:	80 91 5c 07 	lds	r24, 0x075C
    27fc:	90 91 5d 07 	lds	r25, 0x075D
    2800:	00 97       	sbiw	r24, 0x00	; 0
    2802:	f1 f2       	breq	.-68     	; 0x27c0 <check_collision+0xf8>
    2804:	2f ef       	ldi	r18, 0xFF	; 255
    2806:	3f ef       	ldi	r19, 0xFF	; 255
    2808:	4c e2       	ldi	r20, 0x2C	; 44
    280a:	21 50       	subi	r18, 0x01	; 1
    280c:	30 40       	sbci	r19, 0x00	; 0
    280e:	40 40       	sbci	r20, 0x00	; 0
    2810:	e1 f7       	brne	.-8      	; 0x280a <check_collision+0x142>
    2812:	00 c0       	rjmp	.+0      	; 0x2814 <check_collision+0x14c>
    2814:	00 00       	nop
			_delay_ms(10);
		}
		
		_delay_ms(1000);
		
		midpoint_flag = 0;
    2816:	10 92 5d 07 	sts	0x075D, r1
    281a:	10 92 5c 07 	sts	0x075C, r1
		_delay_ms(1);
		//while(nxtnode == pos[1]);	////while(nxtnode == pos[1]);		
	}
	
	if ((pos[0] == nxtnode) && !((pos[0] == nxtnode) && (pos[1] == crtnode)))
	{
    281e:	10 c0       	rjmp	.+32     	; 0x2840 <check_collision+0x178>
		
		_delay_ms(1000);
		
		midpoint_flag = 0;
	}
	else if ((pos[0] == nxtnode))
    2820:	80 91 44 11 	lds	r24, 0x1144
    2824:	90 91 45 11 	lds	r25, 0x1145
    2828:	8a 15       	cp	r24, r10
    282a:	9b 05       	cpc	r25, r11
    282c:	49 f4       	brne	.+18     	; 0x2840 <check_collision+0x178>
    282e:	8f ef       	ldi	r24, 0xFF	; 255
    2830:	9f ef       	ldi	r25, 0xFF	; 255
    2832:	a9 e5       	ldi	r26, 0x59	; 89
    2834:	81 50       	subi	r24, 0x01	; 1
    2836:	90 40       	sbci	r25, 0x00	; 0
    2838:	a0 40       	sbci	r26, 0x00	; 0
    283a:	e1 f7       	brne	.-8      	; 0x2834 <check_collision+0x16c>
    283c:	00 c0       	rjmp	.+0      	; 0x283e <check_collision+0x176>
    283e:	00 00       	nop
	{
		_delay_ms(2000);
	}
	
	if((pos[0] == nxtnode) && (pos[1] == crtnode))
    2840:	00 91 44 11 	lds	r16, 0x1144
    2844:	10 91 45 11 	lds	r17, 0x1145
    2848:	0a 15       	cp	r16, r10
    284a:	1b 05       	cpc	r17, r11
    284c:	09 f0       	breq	.+2      	; 0x2850 <check_collision+0x188>
    284e:	c5 c0       	rjmp	.+394    	; 0x29da <check_collision+0x312>
    2850:	c0 90 46 11 	lds	r12, 0x1146
    2854:	d0 90 47 11 	lds	r13, 0x1147
    2858:	c8 14       	cp	r12, r8
    285a:	d9 04       	cpc	r13, r9
    285c:	09 f0       	breq	.+2      	; 0x2860 <check_collision+0x198>
    285e:	bd c0       	rjmp	.+378    	; 0x29da <check_collision+0x312>
	b[survivor_plot[survivor_index]].pstatus=1;
	
	return retval;
}

void check_collision(int crtnode, int nxtnode, int index)
    2860:	c6 01       	movw	r24, r12
    2862:	88 0f       	add	r24, r24
    2864:	99 1f       	adc	r25, r25
    2866:	8c 0d       	add	r24, r12
    2868:	9d 1d       	adc	r25, r13
    286a:	9c 01       	movw	r18, r24
    286c:	22 0f       	add	r18, r18
    286e:	33 1f       	adc	r19, r19
    2870:	22 0f       	add	r18, r18
    2872:	33 1f       	adc	r19, r19
    2874:	22 0f       	add	r18, r18
    2876:	33 1f       	adc	r19, r19
    2878:	d9 01       	movw	r26, r18
    287a:	a8 1b       	sub	r26, r24
    287c:	b9 0b       	sbc	r27, r25
    287e:	cd 01       	movw	r24, r26
    2880:	8c 0d       	add	r24, r12
    2882:	9d 1d       	adc	r25, r13
    2884:	fc 01       	movw	r30, r24
    2886:	e2 50       	subi	r30, 0x02	; 2
    2888:	f1 4f       	sbci	r31, 0xF1	; 241
    288a:	fc 83       	std	Y+4, r31	; 0x04
    288c:	eb 83       	std	Y+3, r30	; 0x03
    288e:	ee 24       	eor	r14, r14
    2890:	ff 24       	eor	r15, r15
    2892:	e3 94       	inc	r14
			else if ( n[crtnode].adjn[j] == nxtnode )
			{
				move_flag = 1;
				//continue;
			}
			else if ( n[crtnode].adjn[j] == store[sp])
    2894:	0f 2e       	mov	r0, r31
    2896:	fc e5       	ldi	r31, 0x5C	; 92
    2898:	2f 2e       	mov	r2, r31
    289a:	f1 e1       	ldi	r31, 0x11	; 17
    289c:	3f 2e       	mov	r3, r31
    289e:	f0 2d       	mov	r31, r0
			{
				move_flag = 1;
				//continue;
			}
			else if (cost[crtnode][n[crtnode].adjn[j]] == IN)
    28a0:	8a e1       	ldi	r24, 0x1A	; 26
    28a2:	90 e0       	ldi	r25, 0x00	; 0
    28a4:	c8 9e       	mul	r12, r24
    28a6:	90 01       	movw	r18, r0
    28a8:	c9 9e       	mul	r12, r25
    28aa:	30 0d       	add	r19, r0
    28ac:	d8 9e       	mul	r13, r24
    28ae:	30 0d       	add	r19, r0
    28b0:	11 24       	eor	r1, r1
    28b2:	3a 83       	std	Y+2, r19	; 0x02
    28b4:	29 83       	std	Y+1, r18	; 0x01
	b[survivor_plot[survivor_index]].pstatus=1;
	
	return retval;
}

void check_collision(int crtnode, int nxtnode, int index)
    28b6:	6b 80       	ldd	r6, Y+3	; 0x03
    28b8:	7c 80       	ldd	r7, Y+4	; 0x04
		int t_node = crtnode;
		int v_node;
		
		for (int j=1;j<=4;j++)
		{
			if(n[crtnode].adjn[j] == 0)
    28ba:	d3 01       	movw	r26, r6
    28bc:	6d 91       	ld	r22, X+
    28be:	7c 91       	ld	r23, X
    28c0:	11 97       	sbiw	r26, 0x01	; 1
    28c2:	61 15       	cp	r22, r1
    28c4:	71 05       	cpc	r23, r1
    28c6:	09 f4       	brne	.+2      	; 0x28ca <check_collision+0x202>
    28c8:	69 c0       	rjmp	.+210    	; 0x299c <check_collision+0x2d4>
			{
				move_flag = 1;
			}
			else if ( n[crtnode].adjn[j] == nxtnode )
    28ca:	06 17       	cp	r16, r22
    28cc:	17 07       	cpc	r17, r23
    28ce:	09 f4       	brne	.+2      	; 0x28d2 <check_collision+0x20a>
    28d0:	65 c0       	rjmp	.+202    	; 0x299c <check_collision+0x2d4>
			{
				move_flag = 1;
				//continue;
			}
			else if ( n[crtnode].adjn[j] == store[sp])
    28d2:	80 91 c8 0c 	lds	r24, 0x0CC8
    28d6:	90 91 c9 0c 	lds	r25, 0x0CC9
    28da:	88 0f       	add	r24, r24
    28dc:	99 1f       	adc	r25, r25
    28de:	82 0d       	add	r24, r2
    28e0:	93 1d       	adc	r25, r3
    28e2:	fc 01       	movw	r30, r24
    28e4:	80 81       	ld	r24, Z
    28e6:	91 81       	ldd	r25, Z+1	; 0x01
    28e8:	68 17       	cp	r22, r24
    28ea:	79 07       	cpc	r23, r25
    28ec:	09 f4       	brne	.+2      	; 0x28f0 <check_collision+0x228>
    28ee:	56 c0       	rjmp	.+172    	; 0x299c <check_collision+0x2d4>
			{
				move_flag = 1;
				//continue;
			}
			else if (cost[crtnode][n[crtnode].adjn[j]] == IN)
    28f0:	89 81       	ldd	r24, Y+1	; 0x01
    28f2:	9a 81       	ldd	r25, Y+2	; 0x02
    28f4:	86 0f       	add	r24, r22
    28f6:	97 1f       	adc	r25, r23
    28f8:	88 0f       	add	r24, r24
    28fa:	99 1f       	adc	r25, r25
    28fc:	80 50       	subi	r24, 0x00	; 0
    28fe:	9e 4f       	sbci	r25, 0xFE	; 254
    2900:	dc 01       	movw	r26, r24
    2902:	8d 91       	ld	r24, X+
    2904:	9c 91       	ld	r25, X
    2906:	11 97       	sbiw	r26, 0x01	; 1
    2908:	83 36       	cpi	r24, 0x63	; 99
    290a:	91 05       	cpc	r25, r1
    290c:	09 f4       	brne	.+2      	; 0x2910 <check_collision+0x248>
    290e:	46 c0       	rjmp	.+140    	; 0x299c <check_collision+0x2d4>
				move_flag = 1;
				//continue;
			}
			else
			{
				turn(crtnode,n[crtnode].adjn[j]);
    2910:	c6 01       	movw	r24, r12
    2912:	0e 94 69 0d 	call	0x1ad2	; 0x1ad2 <turn>
				move_flag =1;
				int temp = detect_block(crtnode,n[crtnode].adjn[j]);
    2916:	f3 01       	movw	r30, r6
    2918:	60 81       	ld	r22, Z
    291a:	71 81       	ldd	r23, Z+1	; 0x01
    291c:	c6 01       	movw	r24, r12
    291e:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <detect_block>
				
				if(temp == 0)
    2922:	00 97       	sbiw	r24, 0x00	; 0
    2924:	d9 f5       	brne	.+118    	; 0x299c <check_collision+0x2d4>
				{				
					node_check = 0;
    2926:	10 92 63 07 	sts	0x0763, r1
    292a:	10 92 62 07 	sts	0x0762, r1
					send1(90,n[crtnode].adjn[j]);
    292e:	d3 01       	movw	r26, r6
    2930:	6d 91       	ld	r22, X+
    2932:	7c 91       	ld	r23, X
    2934:	8a e5       	ldi	r24, 0x5A	; 90
    2936:	90 e0       	ldi	r25, 0x00	; 0
    2938:	0e 94 9c 01 	call	0x338	; 0x338 <send1>
					
					while(node_check == 0);
    293c:	80 91 62 07 	lds	r24, 0x0762
    2940:	90 91 63 07 	lds	r25, 0x0763
    2944:	00 97       	sbiw	r24, 0x00	; 0
    2946:	d1 f3       	breq	.-12     	; 0x293c <check_collision+0x274>
    2948:	2f ef       	ldi	r18, 0xFF	; 255
    294a:	3f ef       	ldi	r19, 0xFF	; 255
    294c:	48 e0       	ldi	r20, 0x08	; 8
    294e:	21 50       	subi	r18, 0x01	; 1
    2950:	30 40       	sbci	r19, 0x00	; 0
    2952:	40 40       	sbci	r20, 0x00	; 0
    2954:	e1 f7       	brne	.-8      	; 0x294e <check_collision+0x286>
    2956:	00 c0       	rjmp	.+0      	; 0x2958 <check_collision+0x290>
    2958:	00 00       	nop
					_delay_ms(200);
					if (node_ok)
    295a:	80 91 64 07 	lds	r24, 0x0764
    295e:	90 91 65 07 	lds	r25, 0x0765
    2962:	00 97       	sbiw	r24, 0x00	; 0
    2964:	d9 f0       	breq	.+54     	; 0x299c <check_collision+0x2d4>
					{
						move_flag = 0;
						go1(crtnode,n[crtnode].adjn[j]);
    2966:	c6 01       	movw	r24, r12
    2968:	88 0f       	add	r24, r24
    296a:	99 1f       	adc	r25, r25
    296c:	96 01       	movw	r18, r12
    296e:	22 0f       	add	r18, r18
    2970:	33 1f       	adc	r19, r19
    2972:	22 0f       	add	r18, r18
    2974:	33 1f       	adc	r19, r19
    2976:	22 0f       	add	r18, r18
    2978:	33 1f       	adc	r19, r19
    297a:	82 0f       	add	r24, r18
    297c:	93 1f       	adc	r25, r19
    297e:	8c 0d       	add	r24, r12
    2980:	9d 1d       	adc	r25, r13
    2982:	8e 0d       	add	r24, r14
    2984:	9f 1d       	adc	r25, r15
    2986:	fc 01       	movw	r30, r24
    2988:	ee 0f       	add	r30, r30
    298a:	ff 1f       	adc	r31, r31
    298c:	e4 50       	subi	r30, 0x04	; 4
    298e:	f1 4f       	sbci	r31, 0xF1	; 241
    2990:	60 81       	ld	r22, Z
    2992:	71 81       	ldd	r23, Z+1	; 0x01
    2994:	c6 01       	movw	r24, r12
    2996:	0e 94 84 0d 	call	0x1b08	; 0x1b08 <go1>
    299a:	0f c0       	rjmp	.+30     	; 0x29ba <check_collision+0x2f2>
	{
		int move_flag=0;
		int t_node = crtnode;
		int v_node;
		
		for (int j=1;j<=4;j++)
    299c:	08 94       	sec
    299e:	e1 1c       	adc	r14, r1
    29a0:	f1 1c       	adc	r15, r1
    29a2:	4b 81       	ldd	r20, Y+3	; 0x03
    29a4:	5c 81       	ldd	r21, Y+4	; 0x04
    29a6:	4e 5f       	subi	r20, 0xFE	; 254
    29a8:	5f 4f       	sbci	r21, 0xFF	; 255
    29aa:	5c 83       	std	Y+4, r21	; 0x04
    29ac:	4b 83       	std	Y+3, r20	; 0x03
    29ae:	55 e0       	ldi	r21, 0x05	; 5
    29b0:	e5 16       	cp	r14, r21
    29b2:	f1 04       	cpc	r15, r1
    29b4:	09 f0       	breq	.+2      	; 0x29b8 <check_collision+0x2f0>
    29b6:	7f cf       	rjmp	.-258    	; 0x28b6 <check_collision+0x1ee>
    29b8:	0d c0       	rjmp	.+26     	; 0x29d4 <check_collision+0x30c>
		if (move_flag == 1)
		{
			go_back();
		}
		
		goto_n(crt_node,t_node,index);
    29ba:	80 91 4c 07 	lds	r24, 0x074C
    29be:	90 91 4d 07 	lds	r25, 0x074D
    29c2:	b4 01       	movw	r22, r8
    29c4:	a2 01       	movw	r20, r4
    29c6:	0e 94 ba 10 	call	0x2174	; 0x2174 <goto_n>
		
		turn(crtnode,nxtnode);
    29ca:	c4 01       	movw	r24, r8
    29cc:	b5 01       	movw	r22, r10
    29ce:	0e 94 69 0d 	call	0x1ad2	; 0x1ad2 <turn>
    29d2:	03 c0       	rjmp	.+6      	; 0x29da <check_collision+0x312>
			}
		}
		
		if (move_flag == 1)
		{
			go_back();
    29d4:	0e 94 9d 10 	call	0x213a	; 0x213a <go_back>
    29d8:	f0 cf       	rjmp	.-32     	; 0x29ba <check_collision+0x2f2>
		
		goto_n(crt_node,t_node,index);
		
		turn(crtnode,nxtnode);
	}
}
    29da:	0f 90       	pop	r0
    29dc:	0f 90       	pop	r0
    29de:	0f 90       	pop	r0
    29e0:	0f 90       	pop	r0
    29e2:	df 91       	pop	r29
    29e4:	cf 91       	pop	r28
    29e6:	1f 91       	pop	r17
    29e8:	0f 91       	pop	r16
    29ea:	ff 90       	pop	r15
    29ec:	ef 90       	pop	r14
    29ee:	df 90       	pop	r13
    29f0:	cf 90       	pop	r12
    29f2:	bf 90       	pop	r11
    29f4:	af 90       	pop	r10
    29f6:	9f 90       	pop	r9
    29f8:	8f 90       	pop	r8
    29fa:	7f 90       	pop	r7
    29fc:	6f 90       	pop	r6
    29fe:	5f 90       	pop	r5
    2a00:	4f 90       	pop	r4
    2a02:	3f 90       	pop	r3
    2a04:	2f 90       	pop	r2
    2a06:	08 95       	ret

00002a08 <go>:
		umpire = 0;
	}
}

int go(int crtnode, int nxtnode, int index)	// To move the bot from crtnode to nxtnode
{		
    2a08:	cf 92       	push	r12
    2a0a:	df 92       	push	r13
    2a0c:	ef 92       	push	r14
    2a0e:	ff 92       	push	r15
    2a10:	0f 93       	push	r16
    2a12:	1f 93       	push	r17
    2a14:	cf 93       	push	r28
    2a16:	df 93       	push	r29
    2a18:	8c 01       	movw	r16, r24
    2a1a:	eb 01       	movw	r28, r22
    2a1c:	7a 01       	movw	r14, r20
		
	//lcd_print(2,1,crtnode,2);
	//lcd_print(2,4,nxtnode,2);
	
	check_collision(crtnode,nxtnode,index);
    2a1e:	0e 94 64 13 	call	0x26c8	; 0x26c8 <check_collision>
	check_collision(crtnode,nxtnode,index);
    2a22:	c8 01       	movw	r24, r16
    2a24:	be 01       	movw	r22, r28
    2a26:	a7 01       	movw	r20, r14
    2a28:	0e 94 64 13 	call	0x26c8	; 0x26c8 <check_collision>
	check_collision(crtnode,nxtnode,index);
    2a2c:	c8 01       	movw	r24, r16
    2a2e:	be 01       	movw	r22, r28
    2a30:	a7 01       	movw	r20, r14
    2a32:	0e 94 64 13 	call	0x26c8	; 0x26c8 <check_collision>
	
	path_node(1);
    2a36:	81 e0       	ldi	r24, 0x01	; 1
    2a38:	90 e0       	ldi	r25, 0x00	; 0
    2a3a:	0e 94 be 05 	call	0xb7c	; 0xb7c <path_node>

	check_collision_midpoint(crtnode,nxtnode,index);
    2a3e:	c8 01       	movw	r24, r16
    2a40:	be 01       	movw	r22, r28
    2a42:	a7 01       	movw	r20, r14
    2a44:	0e 94 74 11 	call	0x22e8	; 0x22e8 <check_collision_midpoint>
	check_collision_midpoint(crtnode,nxtnode,index);
    2a48:	c8 01       	movw	r24, r16
    2a4a:	be 01       	movw	r22, r28
    2a4c:	a7 01       	movw	r20, r14
    2a4e:	0e 94 74 11 	call	0x22e8	; 0x22e8 <check_collision_midpoint>
	
	int retval = plot_scan(crtnode,nxtnode,index);
    2a52:	c8 01       	movw	r24, r16
    2a54:	be 01       	movw	r22, r28
    2a56:	a7 01       	movw	r20, r14
    2a58:	0e 94 5f 0f 	call	0x1ebe	; 0x1ebe <plot_scan>
    2a5c:	d8 2e       	mov	r13, r24
    2a5e:	c9 2e       	mov	r12, r25
	
	check_collision_midpoint(crtnode,nxtnode,index);
    2a60:	c8 01       	movw	r24, r16
    2a62:	be 01       	movw	r22, r28
    2a64:	a7 01       	movw	r20, r14
    2a66:	0e 94 74 11 	call	0x22e8	; 0x22e8 <check_collision_midpoint>
	if (nxtnode == pos[0])
    2a6a:	80 91 44 11 	lds	r24, 0x1144
    2a6e:	90 91 45 11 	lds	r25, 0x1145
    2a72:	8c 17       	cp	r24, r28
    2a74:	9d 07       	cpc	r25, r29
    2a76:	49 f4       	brne	.+18     	; 0x2a8a <go+0x82>
    2a78:	8f ef       	ldi	r24, 0xFF	; 255
    2a7a:	9f ef       	ldi	r25, 0xFF	; 255
    2a7c:	a9 e5       	ldi	r26, 0x59	; 89
    2a7e:	81 50       	subi	r24, 0x01	; 1
    2a80:	90 40       	sbci	r25, 0x00	; 0
    2a82:	a0 40       	sbci	r26, 0x00	; 0
    2a84:	e1 f7       	brne	.-8      	; 0x2a7e <go+0x76>
    2a86:	00 c0       	rjmp	.+0      	; 0x2a88 <go+0x80>
    2a88:	00 00       	nop
	{
		_delay_ms(2000);
	}
	
	path_node(1);
    2a8a:	81 e0       	ldi	r24, 0x01	; 1
    2a8c:	90 e0       	ldi	r25, 0x00	; 0
    2a8e:	0e 94 be 05 	call	0xb7c	; 0xb7c <path_node>
	
	update(crtnode,nxtnode);
    2a92:	c8 01       	movw	r24, r16
    2a94:	be 01       	movw	r22, r28
    2a96:	0e 94 15 01 	call	0x22a	; 0x22a <update>
	
	return retval;
}
    2a9a:	8d 2d       	mov	r24, r13
    2a9c:	9c 2d       	mov	r25, r12
    2a9e:	df 91       	pop	r29
    2aa0:	cf 91       	pop	r28
    2aa2:	1f 91       	pop	r17
    2aa4:	0f 91       	pop	r16
    2aa6:	ff 90       	pop	r15
    2aa8:	ef 90       	pop	r14
    2aaa:	df 90       	pop	r13
    2aac:	cf 90       	pop	r12
    2aae:	08 95       	ret

00002ab0 <move>:
	
	return retval;
}

int move(int c_node,int d_node, int index)
{
    2ab0:	af 92       	push	r10
    2ab2:	bf 92       	push	r11
    2ab4:	cf 92       	push	r12
    2ab6:	df 92       	push	r13
    2ab8:	ef 92       	push	r14
    2aba:	ff 92       	push	r15
    2abc:	0f 93       	push	r16
    2abe:	1f 93       	push	r17
    2ac0:	cf 93       	push	r28
    2ac2:	df 93       	push	r29
    2ac4:	5b 01       	movw	r10, r22
    2ac6:	6a 01       	movw	r12, r20
	int i,a=0,retval=0,j=1;
	int path_length = dijsktra(c_node,d_node),flag=0;
    2ac8:	0e 94 bc 08 	call	0x1178	; 0x1178 <dijsktra>
    2acc:	7c 01       	movw	r14, r24
	int t_node,move_flag=0;
	
	for (i=1;i<path_length;i++)
    2ace:	82 30       	cpi	r24, 0x02	; 2
    2ad0:	91 05       	cpc	r25, r1
    2ad2:	64 f1       	brlt	.+88     	; 0x2b2c <move+0x7c>
    2ad4:	0c e8       	ldi	r16, 0x8C	; 140
    2ad6:	17 e1       	ldi	r17, 0x17	; 23
    2ad8:	c1 e0       	ldi	r28, 0x01	; 1
    2ada:	d0 e0       	ldi	r29, 0x00	; 0
	{
		path_ptr = i;
    2adc:	d0 93 41 11 	sts	0x1141, r29
    2ae0:	c0 93 40 11 	sts	0x1140, r28
		a = goto_n(crt_node,n_node[i],index);
    2ae4:	f8 01       	movw	r30, r16
    2ae6:	61 91       	ld	r22, Z+
    2ae8:	71 91       	ld	r23, Z+
    2aea:	8f 01       	movw	r16, r30
    2aec:	80 91 4c 07 	lds	r24, 0x074C
    2af0:	90 91 4d 07 	lds	r25, 0x074D
    2af4:	a6 01       	movw	r20, r12
    2af6:	0e 94 ba 10 	call	0x2174	; 0x2174 <goto_n>
			move(crt_node,t_node,index);
			*/
		}
		
		
		if(a == 1)
    2afa:	81 30       	cpi	r24, 0x01	; 1
    2afc:	91 05       	cpc	r25, r1
    2afe:	c9 f0       	breq	.+50     	; 0x2b32 <move+0x82>
		{
			return 1;
			//break;
		}			
		else if(a == -1)
    2b00:	ff ef       	ldi	r31, 0xFF	; 255
    2b02:	8f 3f       	cpi	r24, 0xFF	; 255
    2b04:	9f 07       	cpc	r25, r31
    2b06:	39 f0       	breq	.+14     	; 0x2b16 <move+0x66>
{
	int i,a=0,retval=0,j=1;
	int path_length = dijsktra(c_node,d_node),flag=0;
	int t_node,move_flag=0;
	
	for (i=1;i<path_length;i++)
    2b08:	21 96       	adiw	r28, 0x01	; 1
    2b0a:	ce 15       	cp	r28, r14
    2b0c:	df 05       	cpc	r29, r15
    2b0e:	31 f7       	brne	.-52     	; 0x2adc <move+0x2c>
	if(flag)
	{
		move(crt_node,d_node,index);
	}

	return retval;
    2b10:	80 e0       	ldi	r24, 0x00	; 0
    2b12:	90 e0       	ldi	r25, 0x00	; 0
    2b14:	10 c0       	rjmp	.+32     	; 0x2b36 <move+0x86>
			break;
		}			
	}
	if(flag)
	{
		move(crt_node,d_node,index);
    2b16:	80 91 4c 07 	lds	r24, 0x074C
    2b1a:	90 91 4d 07 	lds	r25, 0x074D
    2b1e:	b5 01       	movw	r22, r10
    2b20:	a6 01       	movw	r20, r12
    2b22:	0e 94 58 15 	call	0x2ab0	; 0x2ab0 <move>
	}

	return retval;
    2b26:	80 e0       	ldi	r24, 0x00	; 0
    2b28:	90 e0       	ldi	r25, 0x00	; 0
    2b2a:	05 c0       	rjmp	.+10     	; 0x2b36 <move+0x86>
    2b2c:	80 e0       	ldi	r24, 0x00	; 0
    2b2e:	90 e0       	ldi	r25, 0x00	; 0
    2b30:	02 c0       	rjmp	.+4      	; 0x2b36 <move+0x86>
		}
		
		
		if(a == 1)
		{
			return 1;
    2b32:	81 e0       	ldi	r24, 0x01	; 1
    2b34:	90 e0       	ldi	r25, 0x00	; 0
	{
		move(crt_node,d_node,index);
	}

	return retval;
}
    2b36:	df 91       	pop	r29
    2b38:	cf 91       	pop	r28
    2b3a:	1f 91       	pop	r17
    2b3c:	0f 91       	pop	r16
    2b3e:	ff 90       	pop	r15
    2b40:	ef 90       	pop	r14
    2b42:	df 90       	pop	r13
    2b44:	cf 90       	pop	r12
    2b46:	bf 90       	pop	r11
    2b48:	af 90       	pop	r10
    2b4a:	08 95       	ret

00002b4c <rescue>:

int rescue(int index)
{
    2b4c:	2f 92       	push	r2
    2b4e:	3f 92       	push	r3
    2b50:	4f 92       	push	r4
    2b52:	5f 92       	push	r5
    2b54:	6f 92       	push	r6
    2b56:	7f 92       	push	r7
    2b58:	8f 92       	push	r8
    2b5a:	9f 92       	push	r9
    2b5c:	af 92       	push	r10
    2b5e:	bf 92       	push	r11
    2b60:	cf 92       	push	r12
    2b62:	df 92       	push	r13
    2b64:	ef 92       	push	r14
    2b66:	ff 92       	push	r15
    2b68:	0f 93       	push	r16
    2b6a:	1f 93       	push	r17
    2b6c:	cf 93       	push	r28
    2b6e:	df 93       	push	r29
    2b70:	2c 01       	movw	r4, r24
	int i;
	
	int p = survivor_plot[index];
    2b72:	fc 01       	movw	r30, r24
    2b74:	ee 0f       	add	r30, r30
    2b76:	ff 1f       	adc	r31, r31
    2b78:	e8 5b       	subi	r30, 0xB8	; 184
    2b7a:	fe 4e       	sbci	r31, 0xEE	; 238
    2b7c:	c0 80       	ld	r12, Z
    2b7e:	d1 80       	ldd	r13, Z+1	; 0x01
	lcd_print(2,1,p,2);
    2b80:	82 e0       	ldi	r24, 0x02	; 2
    2b82:	61 e0       	ldi	r22, 0x01	; 1
    2b84:	a6 01       	movw	r20, r12
    2b86:	22 e0       	ldi	r18, 0x02	; 2
    2b88:	30 e0       	ldi	r19, 0x00	; 0
    2b8a:	0e 94 8f 02 	call	0x51e	; 0x51e <lcd_print>
	
	int flag=1,flag420=0;

	for(i=1;i<=4;i++)
	{
		if(b[p].adj[i] == crt_node)
    2b8e:	20 91 4c 07 	lds	r18, 0x074C
    2b92:	30 91 4d 07 	lds	r19, 0x074D
    2b96:	f6 01       	movw	r30, r12
    2b98:	ee 0f       	add	r30, r30
    2b9a:	ff 1f       	adc	r31, r31
    2b9c:	e2 95       	swap	r30
    2b9e:	f2 95       	swap	r31
    2ba0:	f0 7f       	andi	r31, 0xF0	; 240
    2ba2:	fe 27       	eor	r31, r30
    2ba4:	e0 7f       	andi	r30, 0xF0	; 240
    2ba6:	fe 27       	eor	r31, r30
    2ba8:	e4 52       	subi	r30, 0x24	; 36
    2baa:	f3 4f       	sbci	r31, 0xF3	; 243
    2bac:	80 8d       	ldd	r24, Z+24	; 0x18
    2bae:	91 8d       	ldd	r25, Z+25	; 0x19
    2bb0:	82 17       	cp	r24, r18
    2bb2:	93 07       	cpc	r25, r19
    2bb4:	b1 f1       	breq	.+108    	; 0x2c22 <rescue+0xd6>
    2bb6:	f6 01       	movw	r30, r12
    2bb8:	ee 0f       	add	r30, r30
    2bba:	ff 1f       	adc	r31, r31
    2bbc:	e2 95       	swap	r30
    2bbe:	f2 95       	swap	r31
    2bc0:	f0 7f       	andi	r31, 0xF0	; 240
    2bc2:	fe 27       	eor	r31, r30
    2bc4:	e0 7f       	andi	r30, 0xF0	; 240
    2bc6:	fe 27       	eor	r31, r30
    2bc8:	e4 52       	subi	r30, 0x24	; 36
    2bca:	f3 4f       	sbci	r31, 0xF3	; 243
    2bcc:	82 8d       	ldd	r24, Z+26	; 0x1a
    2bce:	93 8d       	ldd	r25, Z+27	; 0x1b
    2bd0:	82 17       	cp	r24, r18
    2bd2:	93 07       	cpc	r25, r19
    2bd4:	49 f1       	breq	.+82     	; 0x2c28 <rescue+0xdc>
    2bd6:	f6 01       	movw	r30, r12
    2bd8:	ee 0f       	add	r30, r30
    2bda:	ff 1f       	adc	r31, r31
    2bdc:	e2 95       	swap	r30
    2bde:	f2 95       	swap	r31
    2be0:	f0 7f       	andi	r31, 0xF0	; 240
    2be2:	fe 27       	eor	r31, r30
    2be4:	e0 7f       	andi	r30, 0xF0	; 240
    2be6:	fe 27       	eor	r31, r30
    2be8:	e4 52       	subi	r30, 0x24	; 36
    2bea:	f3 4f       	sbci	r31, 0xF3	; 243
    2bec:	84 8d       	ldd	r24, Z+28	; 0x1c
    2bee:	95 8d       	ldd	r25, Z+29	; 0x1d
    2bf0:	82 17       	cp	r24, r18
    2bf2:	93 07       	cpc	r25, r19
    2bf4:	e1 f0       	breq	.+56     	; 0x2c2e <rescue+0xe2>
    2bf6:	f6 01       	movw	r30, r12
    2bf8:	ee 0f       	add	r30, r30
    2bfa:	ff 1f       	adc	r31, r31
    2bfc:	e2 95       	swap	r30
    2bfe:	f2 95       	swap	r31
    2c00:	f0 7f       	andi	r31, 0xF0	; 240
    2c02:	fe 27       	eor	r31, r30
    2c04:	e0 7f       	andi	r30, 0xF0	; 240
    2c06:	fe 27       	eor	r31, r30
    2c08:	e4 52       	subi	r30, 0x24	; 36
    2c0a:	f3 4f       	sbci	r31, 0xF3	; 243
	}

	return retval;
}

int rescue(int index)
    2c0c:	41 e0       	ldi	r20, 0x01	; 1
    2c0e:	50 e0       	ldi	r21, 0x00	; 0
    2c10:	86 8d       	ldd	r24, Z+30	; 0x1e
    2c12:	97 8d       	ldd	r25, Z+31	; 0x1f
    2c14:	82 17       	cp	r24, r18
    2c16:	93 07       	cpc	r25, r19
    2c18:	11 f4       	brne	.+4      	; 0x2c1e <rescue+0xd2>
    2c1a:	40 e0       	ldi	r20, 0x00	; 0
    2c1c:	50 e0       	ldi	r21, 0x00	; 0

	for(i=1;i<=4;i++)
	{
		if(b[p].adj[i] == crt_node)
		{
			flag=0;
    2c1e:	5a 01       	movw	r10, r20
    2c20:	08 c0       	rjmp	.+16     	; 0x2c32 <rescue+0xe6>
    2c22:	aa 24       	eor	r10, r10
    2c24:	bb 24       	eor	r11, r11
    2c26:	05 c0       	rjmp	.+10     	; 0x2c32 <rescue+0xe6>
    2c28:	aa 24       	eor	r10, r10
    2c2a:	bb 24       	eor	r11, r11
    2c2c:	02 c0       	rjmp	.+4      	; 0x2c32 <rescue+0xe6>
    2c2e:	aa 24       	eor	r10, r10
    2c30:	bb 24       	eor	r11, r11
	}

	return retval;
}

int rescue(int index)
    2c32:	86 01       	movw	r16, r12
    2c34:	00 0f       	add	r16, r16
    2c36:	11 1f       	adc	r17, r17
    2c38:	02 95       	swap	r16
    2c3a:	12 95       	swap	r17
    2c3c:	10 7f       	andi	r17, 0xF0	; 240
    2c3e:	10 27       	eor	r17, r16
    2c40:	00 7f       	andi	r16, 0xF0	; 240
    2c42:	10 27       	eor	r17, r16
    2c44:	0c 50       	subi	r16, 0x0C	; 12
    2c46:	13 4f       	sbci	r17, 0xF3	; 243
    2c48:	c6 01       	movw	r24, r12
    2c4a:	88 0f       	add	r24, r24
    2c4c:	99 1f       	adc	r25, r25
    2c4e:	82 95       	swap	r24
    2c50:	92 95       	swap	r25
    2c52:	90 7f       	andi	r25, 0xF0	; 240
    2c54:	98 27       	eor	r25, r24
    2c56:	80 7f       	andi	r24, 0xF0	; 240
    2c58:	98 27       	eor	r25, r24
    2c5a:	0f 2e       	mov	r0, r31
    2c5c:	fc ef       	ldi	r31, 0xFC	; 252
    2c5e:	ef 2e       	mov	r14, r31
    2c60:	fc e0       	ldi	r31, 0x0C	; 12
    2c62:	ff 2e       	mov	r15, r31
    2c64:	f0 2d       	mov	r31, r0
    2c66:	e8 0e       	add	r14, r24
    2c68:	f9 1e       	adc	r15, r25
    2c6a:	e8 01       	movw	r28, r16
    2c6c:	88 24       	eor	r8, r8
    2c6e:	99 24       	eor	r9, r9
					{
						flag420=0;
						return 1;
						//break;
					}
					if(b[p].pstatus==1)
    2c70:	c6 01       	movw	r24, r12
    2c72:	88 0f       	add	r24, r24
    2c74:	99 1f       	adc	r25, r25
    2c76:	82 95       	swap	r24
    2c78:	92 95       	swap	r25
    2c7a:	90 7f       	andi	r25, 0xF0	; 240
    2c7c:	98 27       	eor	r25, r24
    2c7e:	80 7f       	andi	r24, 0xF0	; 240
    2c80:	98 27       	eor	r25, r24
    2c82:	0f 2e       	mov	r0, r31
    2c84:	f0 ef       	ldi	r31, 0xF0	; 240
    2c86:	6f 2e       	mov	r6, r31
    2c88:	fc e0       	ldi	r31, 0x0C	; 12
    2c8a:	7f 2e       	mov	r7, r31
    2c8c:	f0 2d       	mov	r31, r0
    2c8e:	68 0e       	add	r6, r24
    2c90:	79 1e       	adc	r7, r25
						return 1;
						//break;					
				}
				else
				{
					flag420=1;
    2c92:	22 24       	eor	r2, r2
    2c94:	33 24       	eor	r3, r3
    2c96:	23 94       	inc	r2
		}
	}

	for(i=1;i<=4;i++)
	{
		if(b[p].adj[i] != 0)
    2c98:	69 91       	ld	r22, Y+
    2c9a:	79 91       	ld	r23, Y+
    2c9c:	61 15       	cp	r22, r1
    2c9e:	71 05       	cpc	r23, r1
    2ca0:	09 f4       	brne	.+2      	; 0x2ca4 <rescue+0x158>
    2ca2:	46 c0       	rjmp	.+140    	; 0x2d30 <rescue+0x1e4>
		{
			dst_node = b[p].adj[i];
    2ca4:	70 93 75 07 	sts	0x0775, r23
    2ca8:	60 93 74 07 	sts	0x0774, r22
	
			if (flag)
    2cac:	a1 14       	cp	r10, r1
    2cae:	b1 04       	cpc	r11, r1
    2cb0:	a1 f0       	breq	.+40     	; 0x2cda <rescue+0x18e>
			{
				int a = move(crt_node, dst_node,index);		////
    2cb2:	80 91 4c 07 	lds	r24, 0x074C
    2cb6:	90 91 4d 07 	lds	r25, 0x074D
    2cba:	a2 01       	movw	r20, r4
    2cbc:	0e 94 58 15 	call	0x2ab0	; 0x2ab0 <move>
				if(a == 1)
    2cc0:	81 30       	cpi	r24, 0x01	; 1
    2cc2:	91 05       	cpc	r25, r1
    2cc4:	c9 f1       	breq	.+114    	; 0x2d38 <rescue+0x1ec>
				{	//return 1;
					break;
				}					
				if(b[p].pstatus==1)
    2cc6:	f3 01       	movw	r30, r6
    2cc8:	80 81       	ld	r24, Z
    2cca:	91 81       	ldd	r25, Z+1	; 0x01
    2ccc:	81 30       	cpi	r24, 0x01	; 1
    2cce:	91 05       	cpc	r25, r1
    2cd0:	09 f4       	brne	.+2      	; 0x2cd4 <rescue+0x188>
    2cd2:	61 c0       	rjmp	.+194    	; 0x2d96 <rescue+0x24a>
				//break;
					return 1;
				flag=0;
    2cd4:	aa 24       	eor	r10, r10
    2cd6:	bb 24       	eor	r11, r11
    2cd8:	2b c0       	rjmp	.+86     	; 0x2d30 <rescue+0x1e4>
			}
			else
			{
				int a=abs(dst_node - crt_node);
    2cda:	20 91 4c 07 	lds	r18, 0x074C
    2cde:	30 91 4d 07 	lds	r19, 0x074D
    2ce2:	cb 01       	movw	r24, r22
    2ce4:	82 1b       	sub	r24, r18
    2ce6:	93 0b       	sbc	r25, r19
    2ce8:	1a f4       	brpl	.+6      	; 0x2cf0 <rescue+0x1a4>
    2cea:	90 95       	com	r25
    2cec:	81 95       	neg	r24
    2cee:	9f 4f       	sbci	r25, 0xFF	; 255

				if (a==1 || a==5)
    2cf0:	81 30       	cpi	r24, 0x01	; 1
    2cf2:	91 05       	cpc	r25, r1
    2cf4:	19 f0       	breq	.+6      	; 0x2cfc <rescue+0x1b0>
    2cf6:	85 30       	cpi	r24, 0x05	; 5
    2cf8:	91 05       	cpc	r25, r1
    2cfa:	99 f4       	brne	.+38     	; 0x2d22 <rescue+0x1d6>
				{
					int bp = goto_n(crt_node,dst_node,index);
    2cfc:	c9 01       	movw	r24, r18
    2cfe:	a2 01       	movw	r20, r4
    2d00:	0e 94 ba 10 	call	0x2174	; 0x2174 <goto_n>
	
					if(bp == -1)
    2d04:	ff ef       	ldi	r31, 0xFF	; 255
    2d06:	8f 3f       	cpi	r24, 0xFF	; 255
    2d08:	9f 07       	cpc	r25, r31
    2d0a:	91 f0       	breq	.+36     	; 0x2d30 <rescue+0x1e4>
					{
						continue;
					}
					else if(bp == 1)
    2d0c:	81 30       	cpi	r24, 0x01	; 1
    2d0e:	91 05       	cpc	r25, r1
    2d10:	09 f4       	brne	.+2      	; 0x2d14 <rescue+0x1c8>
    2d12:	44 c0       	rjmp	.+136    	; 0x2d9c <rescue+0x250>
					{
						flag420=0;
						return 1;
						//break;
					}
					if(b[p].pstatus==1)
    2d14:	f3 01       	movw	r30, r6
    2d16:	80 81       	ld	r24, Z
    2d18:	91 81       	ldd	r25, Z+1	; 0x01
    2d1a:	81 30       	cpi	r24, 0x01	; 1
    2d1c:	91 05       	cpc	r25, r1
    2d1e:	41 f4       	brne	.+16     	; 0x2d30 <rescue+0x1e4>
    2d20:	40 c0       	rjmp	.+128    	; 0x2da2 <rescue+0x256>
						//break;					
				}
				else
				{
					flag420=1;
					if(b[p].pstatus==1)
    2d22:	f3 01       	movw	r30, r6
    2d24:	80 81       	ld	r24, Z
    2d26:	91 81       	ldd	r25, Z+1	; 0x01
    2d28:	81 30       	cpi	r24, 0x01	; 1
    2d2a:	91 05       	cpc	r25, r1
    2d2c:	e9 f1       	breq	.+122    	; 0x2da8 <rescue+0x25c>
						return 1;
						//break;					
				}
				else
				{
					flag420=1;
    2d2e:	41 01       	movw	r8, r2
			flag=0;
			break;
		}
	}

	for(i=1;i<=4;i++)
    2d30:	ce 15       	cp	r28, r14
    2d32:	df 05       	cpc	r29, r15
    2d34:	09 f0       	breq	.+2      	; 0x2d38 <rescue+0x1ec>
    2d36:	b0 cf       	rjmp	.-160    	; 0x2c98 <rescue+0x14c>
						//break;
				}
			}
		}
	}
	if(flag420)
    2d38:	81 14       	cp	r8, r1
    2d3a:	91 04       	cpc	r9, r1
    2d3c:	c1 f1       	breq	.+112    	; 0x2dae <rescue+0x262>
			
			if(a == 1)
				return 1;
				//break;
				
			if(b[p].pstatus==1)
    2d3e:	c6 01       	movw	r24, r12
    2d40:	88 0f       	add	r24, r24
    2d42:	99 1f       	adc	r25, r25
    2d44:	82 95       	swap	r24
    2d46:	92 95       	swap	r25
    2d48:	90 7f       	andi	r25, 0xF0	; 240
    2d4a:	98 27       	eor	r25, r24
    2d4c:	80 7f       	andi	r24, 0xF0	; 240
    2d4e:	98 27       	eor	r25, r24
    2d50:	ec 01       	movw	r28, r24
    2d52:	c0 51       	subi	r28, 0x10	; 16
    2d54:	d3 4f       	sbci	r29, 0xF3	; 243
		}
	}
	if(flag420)
	for(i=1;i<=4;i++)
	{
		if(b[p].adj[i]!=0)
    2d56:	f8 01       	movw	r30, r16
    2d58:	61 91       	ld	r22, Z+
    2d5a:	71 91       	ld	r23, Z+
    2d5c:	8f 01       	movw	r16, r30
    2d5e:	61 15       	cp	r22, r1
    2d60:	71 05       	cpc	r23, r1
    2d62:	99 f0       	breq	.+38     	; 0x2d8a <rescue+0x23e>
		{
			dst_node = b[p].adj[i];
    2d64:	70 93 75 07 	sts	0x0775, r23
    2d68:	60 93 74 07 	sts	0x0774, r22
	
			int a = move(crt_node, dst_node,index);
    2d6c:	80 91 4c 07 	lds	r24, 0x074C
    2d70:	90 91 4d 07 	lds	r25, 0x074D
    2d74:	a2 01       	movw	r20, r4
    2d76:	0e 94 58 15 	call	0x2ab0	; 0x2ab0 <move>
			
			if(a == 1)
    2d7a:	81 30       	cpi	r24, 0x01	; 1
    2d7c:	91 05       	cpc	r25, r1
    2d7e:	d1 f0       	breq	.+52     	; 0x2db4 <rescue+0x268>
				return 1;
				//break;
				
			if(b[p].pstatus==1)
    2d80:	88 81       	ld	r24, Y
    2d82:	99 81       	ldd	r25, Y+1	; 0x01
    2d84:	81 30       	cpi	r24, 0x01	; 1
    2d86:	91 05       	cpc	r25, r1
    2d88:	c1 f0       	breq	.+48     	; 0x2dba <rescue+0x26e>
				}
			}
		}
	}
	if(flag420)
	for(i=1;i<=4;i++)
    2d8a:	0e 15       	cp	r16, r14
    2d8c:	1f 05       	cpc	r17, r15
    2d8e:	19 f7       	brne	.-58     	; 0x2d56 <rescue+0x20a>
				return 1;
				//break;
		}
	}
	
	return 0;
    2d90:	80 e0       	ldi	r24, 0x00	; 0
    2d92:	90 e0       	ldi	r25, 0x00	; 0
    2d94:	14 c0       	rjmp	.+40     	; 0x2dbe <rescue+0x272>
				{	//return 1;
					break;
				}					
				if(b[p].pstatus==1)
				//break;
					return 1;
    2d96:	81 e0       	ldi	r24, 0x01	; 1
    2d98:	90 e0       	ldi	r25, 0x00	; 0
    2d9a:	11 c0       	rjmp	.+34     	; 0x2dbe <rescue+0x272>
						continue;
					}
					else if(bp == 1)
					{
						flag420=0;
						return 1;
    2d9c:	81 e0       	ldi	r24, 0x01	; 1
    2d9e:	90 e0       	ldi	r25, 0x00	; 0
    2da0:	0e c0       	rjmp	.+28     	; 0x2dbe <rescue+0x272>
						//break;
					}
					if(b[p].pstatus==1)
						return 1;
    2da2:	81 e0       	ldi	r24, 0x01	; 1
    2da4:	90 e0       	ldi	r25, 0x00	; 0
    2da6:	0b c0       	rjmp	.+22     	; 0x2dbe <rescue+0x272>
				}
				else
				{
					flag420=1;
					if(b[p].pstatus==1)
						return 1;
    2da8:	81 e0       	ldi	r24, 0x01	; 1
    2daa:	90 e0       	ldi	r25, 0x00	; 0
    2dac:	08 c0       	rjmp	.+16     	; 0x2dbe <rescue+0x272>
				return 1;
				//break;
		}
	}
	
	return 0;
    2dae:	80 e0       	ldi	r24, 0x00	; 0
    2db0:	90 e0       	ldi	r25, 0x00	; 0
    2db2:	05 c0       	rjmp	.+10     	; 0x2dbe <rescue+0x272>
			dst_node = b[p].adj[i];
	
			int a = move(crt_node, dst_node,index);
			
			if(a == 1)
				return 1;
    2db4:	81 e0       	ldi	r24, 0x01	; 1
    2db6:	90 e0       	ldi	r25, 0x00	; 0
    2db8:	02 c0       	rjmp	.+4      	; 0x2dbe <rescue+0x272>
				//break;
				
			if(b[p].pstatus==1)
				return 1;
    2dba:	81 e0       	ldi	r24, 0x01	; 1
    2dbc:	90 e0       	ldi	r25, 0x00	; 0
				//break;
		}
	}
	
	return 0;
}
    2dbe:	df 91       	pop	r29
    2dc0:	cf 91       	pop	r28
    2dc2:	1f 91       	pop	r17
    2dc4:	0f 91       	pop	r16
    2dc6:	ff 90       	pop	r15
    2dc8:	ef 90       	pop	r14
    2dca:	df 90       	pop	r13
    2dcc:	cf 90       	pop	r12
    2dce:	bf 90       	pop	r11
    2dd0:	af 90       	pop	r10
    2dd2:	9f 90       	pop	r9
    2dd4:	8f 90       	pop	r8
    2dd6:	7f 90       	pop	r7
    2dd8:	6f 90       	pop	r6
    2dda:	5f 90       	pop	r5
    2ddc:	4f 90       	pop	r4
    2dde:	3f 90       	pop	r3
    2de0:	2f 90       	pop	r2
    2de2:	08 95       	ret

00002de4 <uart0_init>:
// actual baud rate:9600 (error 0.0%)
// char size: 8 bit
// parity: Disabled
void uart0_init(void)
{
	UCSR0B = 0x00; //disable while setting baud rate
    2de4:	e1 ec       	ldi	r30, 0xC1	; 193
    2de6:	f0 e0       	ldi	r31, 0x00	; 0
    2de8:	10 82       	st	Z, r1
	UCSR0A = 0x00;
    2dea:	10 92 c0 00 	sts	0x00C0, r1
	UCSR0C = 0x06;
    2dee:	86 e0       	ldi	r24, 0x06	; 6
    2df0:	80 93 c2 00 	sts	0x00C2, r24
	UBRR0L = 0x5F; //set baud rate lo
    2df4:	8f e5       	ldi	r24, 0x5F	; 95
    2df6:	80 93 c4 00 	sts	0x00C4, r24
	UBRR0H = 0x00; //set baud rate hi
    2dfa:	10 92 c5 00 	sts	0x00C5, r1
	UCSR0B = 0x98;
    2dfe:	88 e9       	ldi	r24, 0x98	; 152
    2e00:	80 83       	st	Z, r24
}
    2e02:	08 95       	ret

00002e04 <__vector_25>:

volatile int survivor_flag=0,survivor_flag1=0,survivor_flag2=0;
volatile int clear_flag=0,clear_flag1=0;
volatile int position_flag=0,position_flag1=0;
SIGNAL(SIG_USART0_RECV) 		// ISR for receive complete interrupt
{
    2e04:	1f 92       	push	r1
    2e06:	0f 92       	push	r0
    2e08:	0f b6       	in	r0, 0x3f	; 63
    2e0a:	0f 92       	push	r0
    2e0c:	0b b6       	in	r0, 0x3b	; 59
    2e0e:	0f 92       	push	r0
    2e10:	11 24       	eor	r1, r1
    2e12:	2f 93       	push	r18
    2e14:	3f 93       	push	r19
    2e16:	4f 93       	push	r20
    2e18:	5f 93       	push	r21
    2e1a:	6f 93       	push	r22
    2e1c:	7f 93       	push	r23
    2e1e:	8f 93       	push	r24
    2e20:	9f 93       	push	r25
    2e22:	af 93       	push	r26
    2e24:	bf 93       	push	r27
    2e26:	cf 93       	push	r28
    2e28:	df 93       	push	r29
    2e2a:	ef 93       	push	r30
    2e2c:	ff 93       	push	r31
	data = UDR0; 				//making copy of data from UDR0 in 'data' variable
    2e2e:	80 91 c6 00 	lds	r24, 0x00C6
    2e32:	90 e0       	ldi	r25, 0x00	; 0
    2e34:	90 93 07 18 	sts	0x1807, r25
    2e38:	80 93 06 18 	sts	0x1806, r24
		
	if (data==30 || data==40 || data==50 || data==60 || data==80 || data==100 || data==140 || data==150 || data==160)
    2e3c:	80 91 06 18 	lds	r24, 0x1806
    2e40:	90 91 07 18 	lds	r25, 0x1807
    2e44:	8e 31       	cpi	r24, 0x1E	; 30
    2e46:	91 05       	cpc	r25, r1
    2e48:	c9 f1       	breq	.+114    	; 0x2ebc <__vector_25+0xb8>
    2e4a:	80 91 06 18 	lds	r24, 0x1806
    2e4e:	90 91 07 18 	lds	r25, 0x1807
    2e52:	88 32       	cpi	r24, 0x28	; 40
    2e54:	91 05       	cpc	r25, r1
    2e56:	91 f1       	breq	.+100    	; 0x2ebc <__vector_25+0xb8>
    2e58:	80 91 06 18 	lds	r24, 0x1806
    2e5c:	90 91 07 18 	lds	r25, 0x1807
    2e60:	82 33       	cpi	r24, 0x32	; 50
    2e62:	91 05       	cpc	r25, r1
    2e64:	59 f1       	breq	.+86     	; 0x2ebc <__vector_25+0xb8>
    2e66:	80 91 06 18 	lds	r24, 0x1806
    2e6a:	90 91 07 18 	lds	r25, 0x1807
    2e6e:	8c 33       	cpi	r24, 0x3C	; 60
    2e70:	91 05       	cpc	r25, r1
    2e72:	21 f1       	breq	.+72     	; 0x2ebc <__vector_25+0xb8>
    2e74:	80 91 06 18 	lds	r24, 0x1806
    2e78:	90 91 07 18 	lds	r25, 0x1807
    2e7c:	80 35       	cpi	r24, 0x50	; 80
    2e7e:	91 05       	cpc	r25, r1
    2e80:	e9 f0       	breq	.+58     	; 0x2ebc <__vector_25+0xb8>
    2e82:	80 91 06 18 	lds	r24, 0x1806
    2e86:	90 91 07 18 	lds	r25, 0x1807
    2e8a:	84 36       	cpi	r24, 0x64	; 100
    2e8c:	91 05       	cpc	r25, r1
    2e8e:	b1 f0       	breq	.+44     	; 0x2ebc <__vector_25+0xb8>
    2e90:	80 91 06 18 	lds	r24, 0x1806
    2e94:	90 91 07 18 	lds	r25, 0x1807
    2e98:	8c 38       	cpi	r24, 0x8C	; 140
    2e9a:	91 05       	cpc	r25, r1
    2e9c:	79 f0       	breq	.+30     	; 0x2ebc <__vector_25+0xb8>
    2e9e:	80 91 06 18 	lds	r24, 0x1806
    2ea2:	90 91 07 18 	lds	r25, 0x1807
    2ea6:	86 39       	cpi	r24, 0x96	; 150
    2ea8:	91 05       	cpc	r25, r1
    2eaa:	41 f0       	breq	.+16     	; 0x2ebc <__vector_25+0xb8>
    2eac:	80 91 06 18 	lds	r24, 0x1806
    2eb0:	90 91 07 18 	lds	r25, 0x1807
    2eb4:	80 3a       	cpi	r24, 0xA0	; 160
    2eb6:	91 05       	cpc	r25, r1
    2eb8:	09 f0       	breq	.+2      	; 0x2ebc <__vector_25+0xb8>
    2eba:	9e c0       	rjmp	.+316    	; 0x2ff8 <__vector_25+0x1f4>
	{
		switch(data)
    2ebc:	80 91 06 18 	lds	r24, 0x1806
    2ec0:	90 91 07 18 	lds	r25, 0x1807
    2ec4:	80 35       	cpi	r24, 0x50	; 80
    2ec6:	91 05       	cpc	r25, r1
    2ec8:	09 f4       	brne	.+2      	; 0x2ecc <__vector_25+0xc8>
    2eca:	53 c0       	rjmp	.+166    	; 0x2f72 <__vector_25+0x16e>
    2ecc:	81 35       	cpi	r24, 0x51	; 81
    2ece:	91 05       	cpc	r25, r1
    2ed0:	9c f4       	brge	.+38     	; 0x2ef8 <__vector_25+0xf4>
    2ed2:	88 32       	cpi	r24, 0x28	; 40
    2ed4:	91 05       	cpc	r25, r1
    2ed6:	81 f1       	breq	.+96     	; 0x2f38 <__vector_25+0x134>
    2ed8:	89 32       	cpi	r24, 0x29	; 41
    2eda:	91 05       	cpc	r25, r1
    2edc:	2c f4       	brge	.+10     	; 0x2ee8 <__vector_25+0xe4>
    2ede:	8e 31       	cpi	r24, 0x1E	; 30
    2ee0:	91 05       	cpc	r25, r1
    2ee2:	09 f0       	breq	.+2      	; 0x2ee6 <__vector_25+0xe2>
    2ee4:	7e c1       	rjmp	.+764    	; 0x31e2 <__vector_25+0x3de>
    2ee6:	1d c0       	rjmp	.+58     	; 0x2f22 <__vector_25+0x11e>
    2ee8:	82 33       	cpi	r24, 0x32	; 50
    2eea:	91 05       	cpc	r25, r1
    2eec:	81 f1       	breq	.+96     	; 0x2f4e <__vector_25+0x14a>
    2eee:	8c 33       	cpi	r24, 0x3C	; 60
    2ef0:	91 05       	cpc	r25, r1
    2ef2:	09 f0       	breq	.+2      	; 0x2ef6 <__vector_25+0xf2>
    2ef4:	76 c1       	rjmp	.+748    	; 0x31e2 <__vector_25+0x3de>
    2ef6:	32 c0       	rjmp	.+100    	; 0x2f5c <__vector_25+0x158>
    2ef8:	8c 38       	cpi	r24, 0x8C	; 140
    2efa:	91 05       	cpc	r25, r1
    2efc:	09 f4       	brne	.+2      	; 0x2f00 <__vector_25+0xfc>
    2efe:	4f c0       	rjmp	.+158    	; 0x2f9e <__vector_25+0x19a>
    2f00:	8d 38       	cpi	r24, 0x8D	; 141
    2f02:	91 05       	cpc	r25, r1
    2f04:	2c f4       	brge	.+10     	; 0x2f10 <__vector_25+0x10c>
    2f06:	84 36       	cpi	r24, 0x64	; 100
    2f08:	91 05       	cpc	r25, r1
    2f0a:	09 f0       	breq	.+2      	; 0x2f0e <__vector_25+0x10a>
    2f0c:	6a c1       	rjmp	.+724    	; 0x31e2 <__vector_25+0x3de>
    2f0e:	40 c0       	rjmp	.+128    	; 0x2f90 <__vector_25+0x18c>
    2f10:	86 39       	cpi	r24, 0x96	; 150
    2f12:	91 05       	cpc	r25, r1
    2f14:	09 f4       	brne	.+2      	; 0x2f18 <__vector_25+0x114>
    2f16:	4e c0       	rjmp	.+156    	; 0x2fb4 <__vector_25+0x1b0>
    2f18:	80 3a       	cpi	r24, 0xA0	; 160
    2f1a:	91 05       	cpc	r25, r1
    2f1c:	09 f0       	breq	.+2      	; 0x2f20 <__vector_25+0x11c>
    2f1e:	61 c1       	rjmp	.+706    	; 0x31e2 <__vector_25+0x3de>
    2f20:	54 c0       	rjmp	.+168    	; 0x2fca <__vector_25+0x1c6>
		{
			case 30:flag = 1;
    2f22:	81 e0       	ldi	r24, 0x01	; 1
    2f24:	90 e0       	ldi	r25, 0x00	; 0
    2f26:	90 93 c5 0c 	sts	0x0CC5, r25
    2f2a:	80 93 c4 0c 	sts	0x0CC4, r24
			survivor_flag = 0;
    2f2e:	10 92 5b 07 	sts	0x075B, r1
    2f32:	10 92 5a 07 	sts	0x075A, r1
			//			clear_flag=0;
			break;
    2f36:	55 c1       	rjmp	.+682    	; 0x31e2 <__vector_25+0x3de>
			case 40:survivor_flag = 1;
    2f38:	81 e0       	ldi	r24, 0x01	; 1
    2f3a:	90 e0       	ldi	r25, 0x00	; 0
    2f3c:	90 93 5b 07 	sts	0x075B, r25
    2f40:	80 93 5a 07 	sts	0x075A, r24
			flag = 0;
    2f44:	10 92 c5 0c 	sts	0x0CC5, r1
    2f48:	10 92 c4 0c 	sts	0x0CC4, r1
			//		clear_flag=0;
			break;
    2f4c:	4a c1       	rjmp	.+660    	; 0x31e2 <__vector_25+0x3de>
			case 50:survivor_flag2 =1;
    2f4e:	81 e0       	ldi	r24, 0x01	; 1
    2f50:	90 e0       	ldi	r25, 0x00	; 0
    2f52:	90 93 57 07 	sts	0x0757, r25
    2f56:	80 93 56 07 	sts	0x0756, r24
			break;
    2f5a:	43 c1       	rjmp	.+646    	; 0x31e2 <__vector_25+0x3de>
			case 60:search_complete_flag=1;
    2f5c:	81 e0       	ldi	r24, 0x01	; 1
    2f5e:	90 e0       	ldi	r25, 0x00	; 0
    2f60:	90 93 69 07 	sts	0x0769, r25
    2f64:	80 93 68 07 	sts	0x0768, r24
					USART0_TX(100);
    2f68:	84 e6       	ldi	r24, 0x64	; 100
    2f6a:	90 e0       	ldi	r25, 0x00	; 0
    2f6c:	0e 94 61 01 	call	0x2c2	; 0x2c2 <USART0_TX>
			break;
    2f70:	38 c1       	rjmp	.+624    	; 0x31e2 <__vector_25+0x3de>
			case 80:position_flag=1;
    2f72:	81 e0       	ldi	r24, 0x01	; 1
    2f74:	90 e0       	ldi	r25, 0x00	; 0
    2f76:	90 93 51 07 	sts	0x0751, r25
    2f7a:	80 93 50 07 	sts	0x0750, r24
			flag=0;
    2f7e:	10 92 c5 0c 	sts	0x0CC5, r1
    2f82:	10 92 c4 0c 	sts	0x0CC4, r1
			survivor_flag=0;
    2f86:	10 92 5b 07 	sts	0x075B, r1
    2f8a:	10 92 5a 07 	sts	0x075A, r1
			break;
    2f8e:	29 c1       	rjmp	.+594    	; 0x31e2 <__vector_25+0x3de>
			case 100:	ACK =1;
    2f90:	81 e0       	ldi	r24, 0x01	; 1
    2f92:	90 e0       	ldi	r25, 0x00	; 0
    2f94:	90 93 61 07 	sts	0x0761, r25
    2f98:	80 93 60 07 	sts	0x0760, r24
			break;
    2f9c:	22 c1       	rjmp	.+580    	; 0x31e2 <__vector_25+0x3de>
			case 140:	node_check=1;
    2f9e:	81 e0       	ldi	r24, 0x01	; 1
    2fa0:	90 e0       	ldi	r25, 0x00	; 0
    2fa2:	90 93 63 07 	sts	0x0763, r25
    2fa6:	80 93 62 07 	sts	0x0762, r24
			node_ok=0;
    2faa:	10 92 65 07 	sts	0x0765, r1
    2fae:	10 92 64 07 	sts	0x0764, r1
			break;
    2fb2:	17 c1       	rjmp	.+558    	; 0x31e2 <__vector_25+0x3de>
			case 150:
			node_check=1;
    2fb4:	81 e0       	ldi	r24, 0x01	; 1
    2fb6:	90 e0       	ldi	r25, 0x00	; 0
    2fb8:	90 93 63 07 	sts	0x0763, r25
    2fbc:	80 93 62 07 	sts	0x0762, r24
			node_ok=1;
    2fc0:	90 93 65 07 	sts	0x0765, r25
    2fc4:	80 93 64 07 	sts	0x0764, r24
			break;
    2fc8:	0c c1       	rjmp	.+536    	; 0x31e2 <__vector_25+0x3de>
			case 160:midpoint_flag = 1;
    2fca:	81 e0       	ldi	r24, 0x01	; 1
    2fcc:	90 e0       	ldi	r25, 0x00	; 0
    2fce:	90 93 5d 07 	sts	0x075D, r25
    2fd2:	80 93 5c 07 	sts	0x075C, r24
			position_flag=0;
    2fd6:	10 92 51 07 	sts	0x0751, r1
    2fda:	10 92 50 07 	sts	0x0750, r1
			flag=0;
    2fde:	10 92 c5 0c 	sts	0x0CC5, r1
    2fe2:	10 92 c4 0c 	sts	0x0CC4, r1
			survivor_flag=0;
    2fe6:	10 92 5b 07 	sts	0x075B, r1
    2fea:	10 92 5a 07 	sts	0x075A, r1
			USART0_TX(100);
    2fee:	84 e6       	ldi	r24, 0x64	; 100
    2ff0:	90 e0       	ldi	r25, 0x00	; 0
    2ff2:	0e 94 61 01 	call	0x2c2	; 0x2c2 <USART0_TX>
			break;
    2ff6:	f5 c0       	rjmp	.+490    	; 0x31e2 <__vector_25+0x3de>
			default: break;
		}
	}
	else
	{
		if(flag)
    2ff8:	80 91 c4 0c 	lds	r24, 0x0CC4
    2ffc:	90 91 c5 0c 	lds	r25, 0x0CC5
    3000:	00 97       	sbiw	r24, 0x00	; 0
    3002:	99 f0       	breq	.+38     	; 0x302a <__vector_25+0x226>
		{
			block_node[0]=data;
    3004:	80 91 06 18 	lds	r24, 0x1806
    3008:	90 91 07 18 	lds	r25, 0x1807
    300c:	90 93 59 18 	sts	0x1859, r25
    3010:	80 93 58 18 	sts	0x1858, r24
			flag1=1;
    3014:	81 e0       	ldi	r24, 0x01	; 1
    3016:	90 e0       	ldi	r25, 0x00	; 0
    3018:	90 93 c3 0c 	sts	0x0CC3, r25
    301c:	80 93 c2 0c 	sts	0x0CC2, r24
			flag=0;
    3020:	10 92 c5 0c 	sts	0x0CC5, r1
    3024:	10 92 c4 0c 	sts	0x0CC4, r1
    3028:	3e c0       	rjmp	.+124    	; 0x30a6 <__vector_25+0x2a2>
		}
		else if(flag1)
    302a:	80 91 c2 0c 	lds	r24, 0x0CC2
    302e:	90 91 c3 0c 	lds	r25, 0x0CC3
    3032:	00 97       	sbiw	r24, 0x00	; 0
    3034:	c1 f1       	breq	.+112    	; 0x30a6 <__vector_25+0x2a2>
		{
			block_node[1]=data;
    3036:	20 91 06 18 	lds	r18, 0x1806
    303a:	30 91 07 18 	lds	r19, 0x1807
    303e:	30 93 5b 18 	sts	0x185B, r19
    3042:	20 93 5a 18 	sts	0x185A, r18
			cost[block_node[0]][block_node[1]]=IN;
    3046:	60 91 58 18 	lds	r22, 0x1858
    304a:	70 91 59 18 	lds	r23, 0x1859
    304e:	4a e1       	ldi	r20, 0x1A	; 26
    3050:	50 e0       	ldi	r21, 0x00	; 0
    3052:	64 9f       	mul	r22, r20
    3054:	f0 01       	movw	r30, r0
    3056:	65 9f       	mul	r22, r21
    3058:	f0 0d       	add	r31, r0
    305a:	74 9f       	mul	r23, r20
    305c:	f0 0d       	add	r31, r0
    305e:	11 24       	eor	r1, r1
    3060:	e2 0f       	add	r30, r18
    3062:	f3 1f       	adc	r31, r19
    3064:	a0 e0       	ldi	r26, 0x00	; 0
    3066:	b2 e0       	ldi	r27, 0x02	; 2
    3068:	ee 0f       	add	r30, r30
    306a:	ff 1f       	adc	r31, r31
    306c:	ea 0f       	add	r30, r26
    306e:	fb 1f       	adc	r31, r27
    3070:	c3 e6       	ldi	r28, 0x63	; 99
    3072:	d0 e0       	ldi	r29, 0x00	; 0
    3074:	d1 83       	std	Z+1, r29	; 0x01
    3076:	c0 83       	st	Z, r28
			cost[block_node[1]][block_node[0]]=IN;
    3078:	24 9f       	mul	r18, r20
    307a:	c0 01       	movw	r24, r0
    307c:	25 9f       	mul	r18, r21
    307e:	90 0d       	add	r25, r0
    3080:	34 9f       	mul	r19, r20
    3082:	90 0d       	add	r25, r0
    3084:	11 24       	eor	r1, r1
    3086:	86 0f       	add	r24, r22
    3088:	97 1f       	adc	r25, r23
    308a:	88 0f       	add	r24, r24
    308c:	99 1f       	adc	r25, r25
    308e:	a8 0f       	add	r26, r24
    3090:	b9 1f       	adc	r27, r25
    3092:	cd 93       	st	X+, r28
    3094:	dc 93       	st	X, r29
			flag1=0;
    3096:	10 92 c3 0c 	sts	0x0CC3, r1
    309a:	10 92 c2 0c 	sts	0x0CC2, r1
			USART0_TX(100);		// sending ACK
    309e:	84 e6       	ldi	r24, 0x64	; 100
    30a0:	90 e0       	ldi	r25, 0x00	; 0
    30a2:	0e 94 61 01 	call	0x2c2	; 0x2c2 <USART0_TX>
		}
		
		if(position_flag)
    30a6:	80 91 50 07 	lds	r24, 0x0750
    30aa:	90 91 51 07 	lds	r25, 0x0751
    30ae:	00 97       	sbiw	r24, 0x00	; 0
    30b0:	e9 f0       	breq	.+58     	; 0x30ec <__vector_25+0x2e8>
		{
			pos[0]=data;
    30b2:	80 91 06 18 	lds	r24, 0x1806
    30b6:	90 91 07 18 	lds	r25, 0x1807
    30ba:	90 93 45 11 	sts	0x1145, r25
    30be:	80 93 44 11 	sts	0x1144, r24
			position_flag=0;
    30c2:	10 92 51 07 	sts	0x0751, r1
    30c6:	10 92 50 07 	sts	0x0750, r1
			position_flag1=1;
    30ca:	81 e0       	ldi	r24, 0x01	; 1
    30cc:	90 e0       	ldi	r25, 0x00	; 0
    30ce:	90 93 4f 07 	sts	0x074F, r25
    30d2:	80 93 4e 07 	sts	0x074E, r24
			lcd_print(2,7,pos[0],2);
    30d6:	40 91 44 11 	lds	r20, 0x1144
    30da:	50 91 45 11 	lds	r21, 0x1145
    30de:	82 e0       	ldi	r24, 0x02	; 2
    30e0:	67 e0       	ldi	r22, 0x07	; 7
    30e2:	22 e0       	ldi	r18, 0x02	; 2
    30e4:	30 e0       	ldi	r19, 0x00	; 0
    30e6:	0e 94 8f 02 	call	0x51e	; 0x51e <lcd_print>
    30ea:	20 c0       	rjmp	.+64     	; 0x312c <__vector_25+0x328>
		}
		else if(position_flag1)
    30ec:	80 91 4e 07 	lds	r24, 0x074E
    30f0:	90 91 4f 07 	lds	r25, 0x074F
    30f4:	00 97       	sbiw	r24, 0x00	; 0
    30f6:	d1 f0       	breq	.+52     	; 0x312c <__vector_25+0x328>
		{
			pos[1]=data;
    30f8:	80 91 06 18 	lds	r24, 0x1806
    30fc:	90 91 07 18 	lds	r25, 0x1807
    3100:	90 93 47 11 	sts	0x1147, r25
    3104:	80 93 46 11 	sts	0x1146, r24
			position_flag1=0;
    3108:	10 92 4f 07 	sts	0x074F, r1
    310c:	10 92 4e 07 	sts	0x074E, r1
			lcd_print(2,10,pos[1],2);
    3110:	40 91 46 11 	lds	r20, 0x1146
    3114:	50 91 47 11 	lds	r21, 0x1147
    3118:	82 e0       	ldi	r24, 0x02	; 2
    311a:	6a e0       	ldi	r22, 0x0A	; 10
    311c:	22 e0       	ldi	r18, 0x02	; 2
    311e:	30 e0       	ldi	r19, 0x00	; 0
    3120:	0e 94 8f 02 	call	0x51e	; 0x51e <lcd_print>
			USART0_TX(100);
    3124:	84 e6       	ldi	r24, 0x64	; 100
    3126:	90 e0       	ldi	r25, 0x00	; 0
    3128:	0e 94 61 01 	call	0x2c2	; 0x2c2 <USART0_TX>
		}
		
		if(survivor_flag)
    312c:	80 91 5a 07 	lds	r24, 0x075A
    3130:	90 91 5b 07 	lds	r25, 0x075B
    3134:	00 97       	sbiw	r24, 0x00	; 0
    3136:	c9 f0       	breq	.+50     	; 0x316a <__vector_25+0x366>
		{
			survivor_plot[survivor_ptr] = data;
    3138:	e0 91 6a 07 	lds	r30, 0x076A
    313c:	f0 91 6b 07 	lds	r31, 0x076B
    3140:	80 91 06 18 	lds	r24, 0x1806
    3144:	90 91 07 18 	lds	r25, 0x1807
    3148:	ee 0f       	add	r30, r30
    314a:	ff 1f       	adc	r31, r31
    314c:	e8 5b       	subi	r30, 0xB8	; 184
    314e:	fe 4e       	sbci	r31, 0xEE	; 238
    3150:	91 83       	std	Z+1, r25	; 0x01
    3152:	80 83       	st	Z, r24
			survivor_flag=0;
    3154:	10 92 5b 07 	sts	0x075B, r1
    3158:	10 92 5a 07 	sts	0x075A, r1
			survivor_flag1=1;
    315c:	81 e0       	ldi	r24, 0x01	; 1
    315e:	90 e0       	ldi	r25, 0x00	; 0
    3160:	90 93 59 07 	sts	0x0759, r25
    3164:	80 93 58 07 	sts	0x0758, r24
    3168:	26 c0       	rjmp	.+76     	; 0x31b6 <__vector_25+0x3b2>
		}
		else if(survivor_flag1)
    316a:	80 91 58 07 	lds	r24, 0x0758
    316e:	90 91 59 07 	lds	r25, 0x0759
    3172:	00 97       	sbiw	r24, 0x00	; 0
    3174:	01 f1       	breq	.+64     	; 0x31b6 <__vector_25+0x3b2>
		{
			survivor_colour[survivor_ptr] = data;
    3176:	e0 91 6a 07 	lds	r30, 0x076A
    317a:	f0 91 6b 07 	lds	r31, 0x076B
    317e:	80 91 06 18 	lds	r24, 0x1806
    3182:	90 91 07 18 	lds	r25, 0x1807
    3186:	ee 0f       	add	r30, r30
    3188:	ff 1f       	adc	r31, r31
    318a:	e8 5f       	subi	r30, 0xF8	; 248
    318c:	f7 4e       	sbci	r31, 0xE7	; 231
    318e:	91 83       	std	Z+1, r25	; 0x01
    3190:	80 83       	st	Z, r24
			survivor_flag1 = 0;
    3192:	10 92 59 07 	sts	0x0759, r1
    3196:	10 92 58 07 	sts	0x0758, r1
			survivor_status[survivor_ptr] = 0;
    319a:	e0 91 6a 07 	lds	r30, 0x076A
    319e:	f0 91 6b 07 	lds	r31, 0x076B
    31a2:	ee 0f       	add	r30, r30
    31a4:	ff 1f       	adc	r31, r31
    31a6:	ec 5d       	subi	r30, 0xDC	; 220
    31a8:	fd 4e       	sbci	r31, 0xED	; 237
    31aa:	11 82       	std	Z+1, r1	; 0x01
    31ac:	10 82       	st	Z, r1
			//survivor_ptr = survivor_ptr + 1;
			USART0_TX(100);
    31ae:	84 e6       	ldi	r24, 0x64	; 100
    31b0:	90 e0       	ldi	r25, 0x00	; 0
    31b2:	0e 94 61 01 	call	0x2c2	; 0x2c2 <USART0_TX>
		}
		
		if (survivor_flag2)
    31b6:	80 91 56 07 	lds	r24, 0x0756
    31ba:	90 91 57 07 	lds	r25, 0x0757
    31be:	00 97       	sbiw	r24, 0x00	; 0
    31c0:	81 f0       	breq	.+32     	; 0x31e2 <__vector_25+0x3de>
		{
			survivor_ptr = data;
    31c2:	80 91 06 18 	lds	r24, 0x1806
    31c6:	90 91 07 18 	lds	r25, 0x1807
    31ca:	90 93 6b 07 	sts	0x076B, r25
    31ce:	80 93 6a 07 	sts	0x076A, r24
			survivor_flag2 = 0;
    31d2:	10 92 57 07 	sts	0x0757, r1
    31d6:	10 92 56 07 	sts	0x0756, r1
			USART0_TX(100);
    31da:	84 e6       	ldi	r24, 0x64	; 100
    31dc:	90 e0       	ldi	r25, 0x00	; 0
    31de:	0e 94 61 01 	call	0x2c2	; 0x2c2 <USART0_TX>
		}
	}		
}
    31e2:	ff 91       	pop	r31
    31e4:	ef 91       	pop	r30
    31e6:	df 91       	pop	r29
    31e8:	cf 91       	pop	r28
    31ea:	bf 91       	pop	r27
    31ec:	af 91       	pop	r26
    31ee:	9f 91       	pop	r25
    31f0:	8f 91       	pop	r24
    31f2:	7f 91       	pop	r23
    31f4:	6f 91       	pop	r22
    31f6:	5f 91       	pop	r21
    31f8:	4f 91       	pop	r20
    31fa:	3f 91       	pop	r19
    31fc:	2f 91       	pop	r18
    31fe:	0f 90       	pop	r0
    3200:	0b be       	out	0x3b, r0	; 59
    3202:	0f 90       	pop	r0
    3204:	0f be       	out	0x3f, r0	; 63
    3206:	0f 90       	pop	r0
    3208:	1f 90       	pop	r1
    320a:	18 95       	reti

0000320c <init_arena>:
	_delay_us(100);
}

void init_arena(void)
{
	setPlot();
    320c:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <setPlot>
	set_adj_node();
    3210:	0e 94 04 0c 	call	0x1808	; 0x1808 <set_adj_node>
	set_adj_Plots();
    3214:	0e 94 02 0b 	call	0x1604	; 0x1604 <set_adj_Plots>
	init_survivors();
    3218:	0e 94 97 0a 	call	0x152e	; 0x152e <init_survivors>
}
    321c:	08 95       	ret

0000321e <port_config>:

void port_config(void)			// To configure various device interfaced to FireBird V robot
{
	lcd_port_config();
    321e:	0e 94 b1 01 	call	0x362	; 0x362 <lcd_port_config>
	buzzer_pin_config();
    3222:	0e 94 5f 06 	call	0xcbe	; 0xcbe <buzzer_pin_config>
	adc_pin_config();
    3226:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <adc_pin_config>
	motion_pin_config();
    322a:	0e 94 96 03 	call	0x72c	; 0x72c <motion_pin_config>
	left_encoder_pin_config();
    322e:	0e 94 a7 03 	call	0x74e	; 0x74e <left_encoder_pin_config>
	right_encoder_pin_config();
    3232:	0e 94 aa 03 	call	0x754	; 0x754 <right_encoder_pin_config>
}
    3236:	08 95       	ret

00003238 <init_devices>:

// To initialize the devices
void init_devices(void)
{
	cli();			//Clears the global interrupt
    3238:	f8 94       	cli
	port_config();
    323a:	0e 94 0f 19 	call	0x321e	; 0x321e <port_config>
	lcd_init();
    323e:	0e 94 20 02 	call	0x440	; 0x440 <lcd_init>
	adc_init();
    3242:	0e 94 03 03 	call	0x606	; 0x606 <adc_init>
	timer5_init();
    3246:	0e 94 bf 03 	call	0x77e	; 0x77e <timer5_init>
	left_position_encoder_interrupt_init();
    324a:	0e 94 ad 03 	call	0x75a	; 0x75a <left_position_encoder_interrupt_init>
	right_position_encoder_interrupt_init();
    324e:	0e 94 b6 03 	call	0x76c	; 0x76c <right_position_encoder_interrupt_init>
	uart0_init();
    3252:	0e 94 f2 16 	call	0x2de4	; 0x2de4 <uart0_init>
	servo_init();
    3256:	0e 94 89 06 	call	0xd12	; 0xd12 <servo_init>
	colour_init();
    325a:	0e 94 44 07 	call	0xe88	; 0xe88 <colour_init>
	sei();			//Enable the global interrupt
    325e:	78 94       	sei
}
    3260:	08 95       	ret

00003262 <main>:


int main(void)
{
    3262:	2f 92       	push	r2
    3264:	3f 92       	push	r3
    3266:	4f 92       	push	r4
    3268:	5f 92       	push	r5
    326a:	6f 92       	push	r6
    326c:	7f 92       	push	r7
    326e:	8f 92       	push	r8
    3270:	9f 92       	push	r9
    3272:	af 92       	push	r10
    3274:	bf 92       	push	r11
    3276:	cf 92       	push	r12
    3278:	df 92       	push	r13
    327a:	ef 92       	push	r14
    327c:	ff 92       	push	r15
    327e:	0f 93       	push	r16
    3280:	1f 93       	push	r17
    3282:	cf 93       	push	r28
    3284:	df 93       	push	r29
    3286:	0f 92       	push	r0
    3288:	0f 92       	push	r0
    328a:	cd b7       	in	r28, 0x3d	; 61
    328c:	de b7       	in	r29, 0x3e	; 62
	init_arena();
    328e:	0e 94 06 19 	call	0x320c	; 0x320c <init_arena>
	init_devices();
    3292:	0e 94 1c 19 	call	0x3238	; 0x3238 <init_devices>
	int i=0;
	int t=0,t1=0;
    3296:	22 24       	eor	r2, r2
    3298:	33 24       	eor	r3, r3
	
	while (1)
	{	
		int index = -1,priority_flag = 1;
    329a:	88 24       	eor	r8, r8
    329c:	99 24       	eor	r9, r9
    329e:	83 94       	inc	r8
    32a0:	44 24       	eor	r4, r4
    32a2:	4a 94       	dec	r4
    32a4:	54 2c       	mov	r5, r4
	
		for (i=0; i < survivor_ptr; i++)
    32a6:	aa 24       	eor	r10, r10
    32a8:	bb 24       	eor	r11, r11
		{
			if(survivor_status[i] == 0)
    32aa:	04 e2       	ldi	r16, 0x24	; 36
    32ac:	12 e1       	ldi	r17, 0x12	; 18
		{
			display_colour(survivor_colour[index]);

			if(t==0)
			{
				if(pos[0]==15 || pos[1]==15)
    32ae:	0f 2e       	mov	r0, r31
    32b0:	f4 e4       	ldi	r31, 0x44	; 68
    32b2:	ef 2e       	mov	r14, r31
    32b4:	f1 e1       	ldi	r31, 0x11	; 17
    32b6:	ff 2e       	mov	r15, r31
    32b8:	f0 2d       	mov	r31, r0
				{
					while(pos[0]==15 || pos[1]==15);
    32ba:	0f 2e       	mov	r0, r31
    32bc:	f6 e4       	ldi	r31, 0x46	; 70
    32be:	6f 2e       	mov	r6, r31
    32c0:	f1 e1       	ldi	r31, 0x11	; 17
    32c2:	7f 2e       	mov	r7, r31
    32c4:	f0 2d       	mov	r31, r0
					break;	
				}
				else if(survivor_colour[i] == 1 && priority_flag)
				{
					index = i;
					priority_flag = 0;
    32c6:	a9 82       	std	Y+1, r10	; 0x01
    32c8:	ba 82       	std	Y+2, r11	; 0x02
	
	while (1)
	{	
		int index = -1,priority_flag = 1;
	
		for (i=0; i < survivor_ptr; i++)
    32ca:	80 91 6a 07 	lds	r24, 0x076A
    32ce:	90 91 6b 07 	lds	r25, 0x076B
    32d2:	18 16       	cp	r1, r24
    32d4:	19 06       	cpc	r1, r25
    32d6:	0c f0       	brlt	.+2      	; 0x32da <main+0x78>
    32d8:	da c0       	rjmp	.+436    	; 0x348e <main+0x22c>
	int i=0;
	int t=0,t1=0;
	
	while (1)
	{	
		int index = -1,priority_flag = 1;
    32da:	a4 01       	movw	r20, r8
    32dc:	62 01       	movw	r12, r4
	
		for (i=0; i < survivor_ptr; i++)
    32de:	95 01       	movw	r18, r10
		{
			if(survivor_status[i] == 0)
    32e0:	c9 01       	movw	r24, r18
    32e2:	88 0f       	add	r24, r24
    32e4:	99 1f       	adc	r25, r25
    32e6:	80 0f       	add	r24, r16
    32e8:	91 1f       	adc	r25, r17
    32ea:	fc 01       	movw	r30, r24
    32ec:	80 81       	ld	r24, Z
    32ee:	91 81       	ldd	r25, Z+1	; 0x01
    32f0:	00 97       	sbiw	r24, 0x00	; 0
    32f2:	a9 f4       	brne	.+42     	; 0x331e <main+0xbc>
			{
				if (survivor_colour[i] == 0)
    32f4:	c9 01       	movw	r24, r18
    32f6:	88 0f       	add	r24, r24
    32f8:	99 1f       	adc	r25, r25
    32fa:	88 5f       	subi	r24, 0xF8	; 248
    32fc:	97 4e       	sbci	r25, 0xE7	; 231
    32fe:	fc 01       	movw	r30, r24
    3300:	80 81       	ld	r24, Z
    3302:	91 81       	ldd	r25, Z+1	; 0x01
    3304:	00 97       	sbiw	r24, 0x00	; 0
    3306:	a9 f0       	breq	.+42     	; 0x3332 <main+0xd0>
				{
					index = i;
					break;	
				}
				else if(survivor_colour[i] == 1 && priority_flag)
    3308:	80 81       	ld	r24, Z
    330a:	91 81       	ldd	r25, Z+1	; 0x01
    330c:	81 30       	cpi	r24, 0x01	; 1
    330e:	91 05       	cpc	r25, r1
    3310:	31 f4       	brne	.+12     	; 0x331e <main+0xbc>
    3312:	41 15       	cp	r20, r1
    3314:	51 05       	cpc	r21, r1
    3316:	19 f0       	breq	.+6      	; 0x331e <main+0xbc>
    3318:	69 01       	movw	r12, r18
				{
					index = i;
					priority_flag = 0;
    331a:	49 81       	ldd	r20, Y+1	; 0x01
    331c:	5a 81       	ldd	r21, Y+2	; 0x02
	
	while (1)
	{	
		int index = -1,priority_flag = 1;
	
		for (i=0; i < survivor_ptr; i++)
    331e:	2f 5f       	subi	r18, 0xFF	; 255
    3320:	3f 4f       	sbci	r19, 0xFF	; 255
    3322:	80 91 6a 07 	lds	r24, 0x076A
    3326:	90 91 6b 07 	lds	r25, 0x076B
    332a:	28 17       	cp	r18, r24
    332c:	39 07       	cpc	r19, r25
    332e:	c4 f2       	brlt	.-80     	; 0x32e0 <main+0x7e>
    3330:	01 c0       	rjmp	.+2      	; 0x3334 <main+0xd2>
		{
			if(survivor_status[i] == 0)
			{
				if (survivor_colour[i] == 0)
    3332:	69 01       	movw	r12, r18
					priority_flag = 0;
				}					
			}
		}
				
		if(index != -1)
    3334:	ff ef       	ldi	r31, 0xFF	; 255
    3336:	cf 16       	cp	r12, r31
    3338:	ff ef       	ldi	r31, 0xFF	; 255
    333a:	df 06       	cpc	r13, r31
    333c:	09 f4       	brne	.+2      	; 0x3340 <main+0xde>
    333e:	aa c0       	rjmp	.+340    	; 0x3494 <main+0x232>
		{
			display_colour(survivor_colour[index]);
    3340:	c6 01       	movw	r24, r12
    3342:	88 0f       	add	r24, r24
    3344:	99 1f       	adc	r25, r25
    3346:	88 5f       	subi	r24, 0xF8	; 248
    3348:	97 4e       	sbci	r25, 0xE7	; 231
    334a:	fc 01       	movw	r30, r24
    334c:	80 81       	ld	r24, Z
    334e:	91 81       	ldd	r25, Z+1	; 0x01
    3350:	0e 94 a1 08 	call	0x1142	; 0x1142 <display_colour>

			if(t==0)
    3354:	21 14       	cp	r2, r1
    3356:	31 04       	cpc	r3, r1
    3358:	21 f5       	brne	.+72     	; 0x33a2 <main+0x140>
			{
				if(pos[0]==15 || pos[1]==15)
    335a:	f7 01       	movw	r30, r14
    335c:	80 81       	ld	r24, Z
    335e:	91 81       	ldd	r25, Z+1	; 0x01
    3360:	8f 30       	cpi	r24, 0x0F	; 15
    3362:	91 05       	cpc	r25, r1
    3364:	31 f0       	breq	.+12     	; 0x3372 <main+0x110>
    3366:	f3 01       	movw	r30, r6
    3368:	80 81       	ld	r24, Z
    336a:	91 81       	ldd	r25, Z+1	; 0x01
    336c:	8f 30       	cpi	r24, 0x0F	; 15
    336e:	91 05       	cpc	r25, r1
    3370:	61 f4       	brne	.+24     	; 0x338a <main+0x128>
				{
					while(pos[0]==15 || pos[1]==15);
    3372:	f7 01       	movw	r30, r14
    3374:	80 81       	ld	r24, Z
    3376:	91 81       	ldd	r25, Z+1	; 0x01
    3378:	8f 30       	cpi	r24, 0x0F	; 15
    337a:	91 05       	cpc	r25, r1
    337c:	d1 f3       	breq	.-12     	; 0x3372 <main+0x110>
    337e:	f3 01       	movw	r30, r6
    3380:	80 81       	ld	r24, Z
    3382:	91 81       	ldd	r25, Z+1	; 0x01
    3384:	8f 30       	cpi	r24, 0x0F	; 15
    3386:	91 05       	cpc	r25, r1
    3388:	a1 f3       	breq	.-24     	; 0x3372 <main+0x110>
				}
				forward();
    338a:	0e 94 2f 04 	call	0x85e	; 0x85e <forward>
				linear_mm(70);
    338e:	66 e4       	ldi	r22, 0x46	; 70
    3390:	70 e0       	ldi	r23, 0x00	; 0
    3392:	80 e0       	ldi	r24, 0x00	; 0
    3394:	90 e0       	ldi	r25, 0x00	; 0
    3396:	0e 94 5e 04 	call	0x8bc	; 0x8bc <linear_mm>
				path_node(1);
    339a:	c4 01       	movw	r24, r8
    339c:	0e 94 be 05 	call	0xb7c	; 0xb7c <path_node>
				t=1;
    33a0:	14 01       	movw	r2, r8
			}	
			
			rescue(index);
    33a2:	c6 01       	movw	r24, r12
    33a4:	0e 94 a6 15 	call	0x2b4c	; 0x2b4c <rescue>
			
			if(survivor_colour[index] == 0)
    33a8:	c6 01       	movw	r24, r12
    33aa:	88 0f       	add	r24, r24
    33ac:	99 1f       	adc	r25, r25
    33ae:	88 5f       	subi	r24, 0xF8	; 248
    33b0:	97 4e       	sbci	r25, 0xE7	; 231
    33b2:	fc 01       	movw	r30, r24
    33b4:	80 81       	ld	r24, Z
    33b6:	91 81       	ldd	r25, Z+1	; 0x01
    33b8:	00 97       	sbiw	r24, 0x00	; 0
    33ba:	09 f0       	breq	.+2      	; 0x33be <main+0x15c>
    33bc:	6b c0       	rjmp	.+214    	; 0x3494 <main+0x232>
			{
				move(crt_node,15,9);
    33be:	80 91 4c 07 	lds	r24, 0x074C
    33c2:	90 91 4d 07 	lds	r25, 0x074D
    33c6:	6f e0       	ldi	r22, 0x0F	; 15
    33c8:	70 e0       	ldi	r23, 0x00	; 0
    33ca:	49 e0       	ldi	r20, 0x09	; 9
    33cc:	50 e0       	ldi	r21, 0x00	; 0
    33ce:	0e 94 58 15 	call	0x2ab0	; 0x2ab0 <move>
				turn(15,10);
    33d2:	8f e0       	ldi	r24, 0x0F	; 15
    33d4:	90 e0       	ldi	r25, 0x00	; 0
    33d6:	6a e0       	ldi	r22, 0x0A	; 10
    33d8:	70 e0       	ldi	r23, 0x00	; 0
    33da:	0e 94 69 0d 	call	0x1ad2	; 0x1ad2 <turn>
				rotate_right(85);
    33de:	85 e5       	ldi	r24, 0x55	; 85
    33e0:	90 e0       	ldi	r25, 0x00	; 0
    33e2:	0e 94 19 06 	call	0xc32	; 0xc32 <rotate_right>
				switch_flag = 1;
    33e6:	90 92 d3 0c 	sts	0x0CD3, r9
    33ea:	80 92 d2 0c 	sts	0x0CD2, r8
				path_node(1);
    33ee:	c4 01       	movw	r24, r8
    33f0:	0e 94 be 05 	call	0xb7c	; 0xb7c <path_node>
				switch_flag = 0;
    33f4:	b0 92 d3 0c 	sts	0x0CD3, r11
    33f8:	a0 92 d2 0c 	sts	0x0CD2, r10
				rotate_right(170);
    33fc:	8a ea       	ldi	r24, 0xAA	; 170
    33fe:	90 e0       	ldi	r25, 0x00	; 0
    3400:	0e 94 19 06 	call	0xc32	; 0xc32 <rotate_right>
				back();
    3404:	0e 94 3e 04 	call	0x87c	; 0x87c <back>
				linear_mm(100);
    3408:	64 e6       	ldi	r22, 0x64	; 100
    340a:	70 e0       	ldi	r23, 0x00	; 0
    340c:	80 e0       	ldi	r24, 0x00	; 0
    340e:	90 e0       	ldi	r25, 0x00	; 0
    3410:	0e 94 5e 04 	call	0x8bc	; 0x8bc <linear_mm>
				display_colour(3);
    3414:	83 e0       	ldi	r24, 0x03	; 3
    3416:	90 e0       	ldi	r25, 0x00	; 0
    3418:	0e 94 a1 08 	call	0x1142	; 0x1142 <display_colour>
				buzzer(1);
    341c:	c4 01       	movw	r24, r8
    341e:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <buzzer>
				crt_node = 15;
    3422:	8f e0       	ldi	r24, 0x0F	; 15
    3424:	90 e0       	ldi	r25, 0x00	; 0
    3426:	90 93 4d 07 	sts	0x074D, r25
    342a:	80 93 4c 07 	sts	0x074C, r24
				crrt_dir=3;
    342e:	83 e0       	ldi	r24, 0x03	; 3
    3430:	90 e0       	ldi	r25, 0x00	; 0
    3432:	90 93 4b 07 	sts	0x074B, r25
    3436:	80 93 4a 07 	sts	0x074A, r24
				t=0;
				
				clear_stack();
    343a:	0e 94 ac 10 	call	0x2158	; 0x2158 <clear_stack>
				
				ACK =0;
    343e:	b0 92 61 07 	sts	0x0761, r11
    3442:	a0 92 60 07 	sts	0x0760, r10
				send(50,0,0);
    3446:	82 e3       	ldi	r24, 0x32	; 50
    3448:	90 e0       	ldi	r25, 0x00	; 0
    344a:	b5 01       	movw	r22, r10
    344c:	a5 01       	movw	r20, r10
    344e:	0e 94 69 01 	call	0x2d2	; 0x2d2 <send>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3452:	80 e7       	ldi	r24, 0x70	; 112
    3454:	91 e0       	ldi	r25, 0x01	; 1
    3456:	01 97       	sbiw	r24, 0x01	; 1
    3458:	f1 f7       	brne	.-4      	; 0x3456 <main+0x1f4>
    345a:	00 c0       	rjmp	.+0      	; 0x345c <main+0x1fa>
				_delay_us(100);
				while(ACK == 0)
    345c:	80 91 60 07 	lds	r24, 0x0760
    3460:	90 91 61 07 	lds	r25, 0x0761
    3464:	00 97       	sbiw	r24, 0x00	; 0
    3466:	a9 f4       	brne	.+42     	; 0x3492 <main+0x230>
				{
					send(50,0,0);
    3468:	82 e3       	ldi	r24, 0x32	; 50
    346a:	90 e0       	ldi	r25, 0x00	; 0
    346c:	b5 01       	movw	r22, r10
    346e:	a5 01       	movw	r20, r10
    3470:	0e 94 69 01 	call	0x2d2	; 0x2d2 <send>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3474:	e6 e6       	ldi	r30, 0x66	; 102
    3476:	fe e0       	ldi	r31, 0x0E	; 14
    3478:	31 97       	sbiw	r30, 0x01	; 1
    347a:	f1 f7       	brne	.-4      	; 0x3478 <main+0x216>
    347c:	00 00       	nop
				clear_stack();
				
				ACK =0;
				send(50,0,0);
				_delay_us(100);
				while(ACK == 0)
    347e:	80 91 60 07 	lds	r24, 0x0760
    3482:	90 91 61 07 	lds	r25, 0x0761
    3486:	00 97       	sbiw	r24, 0x00	; 0
    3488:	79 f3       	breq	.-34     	; 0x3468 <main+0x206>
				linear_mm(100);
				display_colour(3);
				buzzer(1);
				crt_node = 15;
				crrt_dir=3;
				t=0;
    348a:	15 01       	movw	r2, r10
    348c:	03 c0       	rjmp	.+6      	; 0x3494 <main+0x232>
	int i=0;
	int t=0,t1=0;
	
	while (1)
	{	
		int index = -1,priority_flag = 1;
    348e:	62 01       	movw	r12, r4
    3490:	01 c0       	rjmp	.+2      	; 0x3494 <main+0x232>
				linear_mm(100);
				display_colour(3);
				buzzer(1);
				crt_node = 15;
				crrt_dir=3;
				t=0;
    3492:	15 01       	movw	r2, r10
				}
			}
			
		}	
		
		if((search_complete_flag == 1) && (index == -1))
    3494:	80 91 68 07 	lds	r24, 0x0768
    3498:	90 91 69 07 	lds	r25, 0x0769
    349c:	81 30       	cpi	r24, 0x01	; 1
    349e:	91 05       	cpc	r25, r1
    34a0:	09 f0       	breq	.+2      	; 0x34a4 <main+0x242>
    34a2:	13 cf       	rjmp	.-474    	; 0x32ca <main+0x68>
    34a4:	ff ef       	ldi	r31, 0xFF	; 255
    34a6:	cf 16       	cp	r12, r31
    34a8:	ff ef       	ldi	r31, 0xFF	; 255
    34aa:	df 06       	cpc	r13, r31
    34ac:	09 f0       	breq	.+2      	; 0x34b0 <main+0x24e>
    34ae:	0d cf       	rjmp	.-486    	; 0x32ca <main+0x68>
			break;
	}
	
	buzzer(5);
    34b0:	85 e0       	ldi	r24, 0x05	; 5
    34b2:	90 e0       	ldi	r25, 0x00	; 0
    34b4:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <buzzer>
	
	return 0;
    34b8:	80 e0       	ldi	r24, 0x00	; 0
    34ba:	90 e0       	ldi	r25, 0x00	; 0
    34bc:	0f 90       	pop	r0
    34be:	0f 90       	pop	r0
    34c0:	df 91       	pop	r29
    34c2:	cf 91       	pop	r28
    34c4:	1f 91       	pop	r17
    34c6:	0f 91       	pop	r16
    34c8:	ff 90       	pop	r15
    34ca:	ef 90       	pop	r14
    34cc:	df 90       	pop	r13
    34ce:	cf 90       	pop	r12
    34d0:	bf 90       	pop	r11
    34d2:	af 90       	pop	r10
    34d4:	9f 90       	pop	r9
    34d6:	8f 90       	pop	r8
    34d8:	7f 90       	pop	r7
    34da:	6f 90       	pop	r6
    34dc:	5f 90       	pop	r5
    34de:	4f 90       	pop	r4
    34e0:	3f 90       	pop	r3
    34e2:	2f 90       	pop	r2
    34e4:	08 95       	ret

000034e6 <__subsf3>:
    34e6:	50 58       	subi	r21, 0x80	; 128

000034e8 <__addsf3>:
    34e8:	bb 27       	eor	r27, r27
    34ea:	aa 27       	eor	r26, r26
    34ec:	0e d0       	rcall	.+28     	; 0x350a <__addsf3x>
    34ee:	75 c1       	rjmp	.+746    	; 0x37da <__fp_round>
    34f0:	66 d1       	rcall	.+716    	; 0x37be <__fp_pscA>
    34f2:	30 f0       	brcs	.+12     	; 0x3500 <__addsf3+0x18>
    34f4:	6b d1       	rcall	.+726    	; 0x37cc <__fp_pscB>
    34f6:	20 f0       	brcs	.+8      	; 0x3500 <__addsf3+0x18>
    34f8:	31 f4       	brne	.+12     	; 0x3506 <__addsf3+0x1e>
    34fa:	9f 3f       	cpi	r25, 0xFF	; 255
    34fc:	11 f4       	brne	.+4      	; 0x3502 <__addsf3+0x1a>
    34fe:	1e f4       	brtc	.+6      	; 0x3506 <__addsf3+0x1e>
    3500:	5b c1       	rjmp	.+694    	; 0x37b8 <__fp_nan>
    3502:	0e f4       	brtc	.+2      	; 0x3506 <__addsf3+0x1e>
    3504:	e0 95       	com	r30
    3506:	e7 fb       	bst	r30, 7
    3508:	51 c1       	rjmp	.+674    	; 0x37ac <__fp_inf>

0000350a <__addsf3x>:
    350a:	e9 2f       	mov	r30, r25
    350c:	77 d1       	rcall	.+750    	; 0x37fc <__fp_split3>
    350e:	80 f3       	brcs	.-32     	; 0x34f0 <__addsf3+0x8>
    3510:	ba 17       	cp	r27, r26
    3512:	62 07       	cpc	r22, r18
    3514:	73 07       	cpc	r23, r19
    3516:	84 07       	cpc	r24, r20
    3518:	95 07       	cpc	r25, r21
    351a:	18 f0       	brcs	.+6      	; 0x3522 <__addsf3x+0x18>
    351c:	71 f4       	brne	.+28     	; 0x353a <__addsf3x+0x30>
    351e:	9e f5       	brtc	.+102    	; 0x3586 <__addsf3x+0x7c>
    3520:	8f c1       	rjmp	.+798    	; 0x3840 <__fp_zero>
    3522:	0e f4       	brtc	.+2      	; 0x3526 <__addsf3x+0x1c>
    3524:	e0 95       	com	r30
    3526:	0b 2e       	mov	r0, r27
    3528:	ba 2f       	mov	r27, r26
    352a:	a0 2d       	mov	r26, r0
    352c:	0b 01       	movw	r0, r22
    352e:	b9 01       	movw	r22, r18
    3530:	90 01       	movw	r18, r0
    3532:	0c 01       	movw	r0, r24
    3534:	ca 01       	movw	r24, r20
    3536:	a0 01       	movw	r20, r0
    3538:	11 24       	eor	r1, r1
    353a:	ff 27       	eor	r31, r31
    353c:	59 1b       	sub	r21, r25
    353e:	99 f0       	breq	.+38     	; 0x3566 <__addsf3x+0x5c>
    3540:	59 3f       	cpi	r21, 0xF9	; 249
    3542:	50 f4       	brcc	.+20     	; 0x3558 <__addsf3x+0x4e>
    3544:	50 3e       	cpi	r21, 0xE0	; 224
    3546:	68 f1       	brcs	.+90     	; 0x35a2 <__addsf3x+0x98>
    3548:	1a 16       	cp	r1, r26
    354a:	f0 40       	sbci	r31, 0x00	; 0
    354c:	a2 2f       	mov	r26, r18
    354e:	23 2f       	mov	r18, r19
    3550:	34 2f       	mov	r19, r20
    3552:	44 27       	eor	r20, r20
    3554:	58 5f       	subi	r21, 0xF8	; 248
    3556:	f3 cf       	rjmp	.-26     	; 0x353e <__addsf3x+0x34>
    3558:	46 95       	lsr	r20
    355a:	37 95       	ror	r19
    355c:	27 95       	ror	r18
    355e:	a7 95       	ror	r26
    3560:	f0 40       	sbci	r31, 0x00	; 0
    3562:	53 95       	inc	r21
    3564:	c9 f7       	brne	.-14     	; 0x3558 <__addsf3x+0x4e>
    3566:	7e f4       	brtc	.+30     	; 0x3586 <__addsf3x+0x7c>
    3568:	1f 16       	cp	r1, r31
    356a:	ba 0b       	sbc	r27, r26
    356c:	62 0b       	sbc	r22, r18
    356e:	73 0b       	sbc	r23, r19
    3570:	84 0b       	sbc	r24, r20
    3572:	ba f0       	brmi	.+46     	; 0x35a2 <__addsf3x+0x98>
    3574:	91 50       	subi	r25, 0x01	; 1
    3576:	a1 f0       	breq	.+40     	; 0x35a0 <__addsf3x+0x96>
    3578:	ff 0f       	add	r31, r31
    357a:	bb 1f       	adc	r27, r27
    357c:	66 1f       	adc	r22, r22
    357e:	77 1f       	adc	r23, r23
    3580:	88 1f       	adc	r24, r24
    3582:	c2 f7       	brpl	.-16     	; 0x3574 <__addsf3x+0x6a>
    3584:	0e c0       	rjmp	.+28     	; 0x35a2 <__addsf3x+0x98>
    3586:	ba 0f       	add	r27, r26
    3588:	62 1f       	adc	r22, r18
    358a:	73 1f       	adc	r23, r19
    358c:	84 1f       	adc	r24, r20
    358e:	48 f4       	brcc	.+18     	; 0x35a2 <__addsf3x+0x98>
    3590:	87 95       	ror	r24
    3592:	77 95       	ror	r23
    3594:	67 95       	ror	r22
    3596:	b7 95       	ror	r27
    3598:	f7 95       	ror	r31
    359a:	9e 3f       	cpi	r25, 0xFE	; 254
    359c:	08 f0       	brcs	.+2      	; 0x35a0 <__addsf3x+0x96>
    359e:	b3 cf       	rjmp	.-154    	; 0x3506 <__addsf3+0x1e>
    35a0:	93 95       	inc	r25
    35a2:	88 0f       	add	r24, r24
    35a4:	08 f0       	brcs	.+2      	; 0x35a8 <__addsf3x+0x9e>
    35a6:	99 27       	eor	r25, r25
    35a8:	ee 0f       	add	r30, r30
    35aa:	97 95       	ror	r25
    35ac:	87 95       	ror	r24
    35ae:	08 95       	ret

000035b0 <__cmpsf2>:
    35b0:	d9 d0       	rcall	.+434    	; 0x3764 <__fp_cmp>
    35b2:	08 f4       	brcc	.+2      	; 0x35b6 <__cmpsf2+0x6>
    35b4:	81 e0       	ldi	r24, 0x01	; 1
    35b6:	08 95       	ret

000035b8 <__divsf3>:
    35b8:	0c d0       	rcall	.+24     	; 0x35d2 <__divsf3x>
    35ba:	0f c1       	rjmp	.+542    	; 0x37da <__fp_round>
    35bc:	07 d1       	rcall	.+526    	; 0x37cc <__fp_pscB>
    35be:	40 f0       	brcs	.+16     	; 0x35d0 <__divsf3+0x18>
    35c0:	fe d0       	rcall	.+508    	; 0x37be <__fp_pscA>
    35c2:	30 f0       	brcs	.+12     	; 0x35d0 <__divsf3+0x18>
    35c4:	21 f4       	brne	.+8      	; 0x35ce <__divsf3+0x16>
    35c6:	5f 3f       	cpi	r21, 0xFF	; 255
    35c8:	19 f0       	breq	.+6      	; 0x35d0 <__divsf3+0x18>
    35ca:	f0 c0       	rjmp	.+480    	; 0x37ac <__fp_inf>
    35cc:	51 11       	cpse	r21, r1
    35ce:	39 c1       	rjmp	.+626    	; 0x3842 <__fp_szero>
    35d0:	f3 c0       	rjmp	.+486    	; 0x37b8 <__fp_nan>

000035d2 <__divsf3x>:
    35d2:	14 d1       	rcall	.+552    	; 0x37fc <__fp_split3>
    35d4:	98 f3       	brcs	.-26     	; 0x35bc <__divsf3+0x4>

000035d6 <__divsf3_pse>:
    35d6:	99 23       	and	r25, r25
    35d8:	c9 f3       	breq	.-14     	; 0x35cc <__divsf3+0x14>
    35da:	55 23       	and	r21, r21
    35dc:	b1 f3       	breq	.-20     	; 0x35ca <__divsf3+0x12>
    35de:	95 1b       	sub	r25, r21
    35e0:	55 0b       	sbc	r21, r21
    35e2:	bb 27       	eor	r27, r27
    35e4:	aa 27       	eor	r26, r26
    35e6:	62 17       	cp	r22, r18
    35e8:	73 07       	cpc	r23, r19
    35ea:	84 07       	cpc	r24, r20
    35ec:	38 f0       	brcs	.+14     	; 0x35fc <__divsf3_pse+0x26>
    35ee:	9f 5f       	subi	r25, 0xFF	; 255
    35f0:	5f 4f       	sbci	r21, 0xFF	; 255
    35f2:	22 0f       	add	r18, r18
    35f4:	33 1f       	adc	r19, r19
    35f6:	44 1f       	adc	r20, r20
    35f8:	aa 1f       	adc	r26, r26
    35fa:	a9 f3       	breq	.-22     	; 0x35e6 <__divsf3_pse+0x10>
    35fc:	33 d0       	rcall	.+102    	; 0x3664 <__divsf3_pse+0x8e>
    35fe:	0e 2e       	mov	r0, r30
    3600:	3a f0       	brmi	.+14     	; 0x3610 <__divsf3_pse+0x3a>
    3602:	e0 e8       	ldi	r30, 0x80	; 128
    3604:	30 d0       	rcall	.+96     	; 0x3666 <__divsf3_pse+0x90>
    3606:	91 50       	subi	r25, 0x01	; 1
    3608:	50 40       	sbci	r21, 0x00	; 0
    360a:	e6 95       	lsr	r30
    360c:	00 1c       	adc	r0, r0
    360e:	ca f7       	brpl	.-14     	; 0x3602 <__divsf3_pse+0x2c>
    3610:	29 d0       	rcall	.+82     	; 0x3664 <__divsf3_pse+0x8e>
    3612:	fe 2f       	mov	r31, r30
    3614:	27 d0       	rcall	.+78     	; 0x3664 <__divsf3_pse+0x8e>
    3616:	66 0f       	add	r22, r22
    3618:	77 1f       	adc	r23, r23
    361a:	88 1f       	adc	r24, r24
    361c:	bb 1f       	adc	r27, r27
    361e:	26 17       	cp	r18, r22
    3620:	37 07       	cpc	r19, r23
    3622:	48 07       	cpc	r20, r24
    3624:	ab 07       	cpc	r26, r27
    3626:	b0 e8       	ldi	r27, 0x80	; 128
    3628:	09 f0       	breq	.+2      	; 0x362c <__divsf3_pse+0x56>
    362a:	bb 0b       	sbc	r27, r27
    362c:	80 2d       	mov	r24, r0
    362e:	bf 01       	movw	r22, r30
    3630:	ff 27       	eor	r31, r31
    3632:	93 58       	subi	r25, 0x83	; 131
    3634:	5f 4f       	sbci	r21, 0xFF	; 255
    3636:	2a f0       	brmi	.+10     	; 0x3642 <__divsf3_pse+0x6c>
    3638:	9e 3f       	cpi	r25, 0xFE	; 254
    363a:	51 05       	cpc	r21, r1
    363c:	68 f0       	brcs	.+26     	; 0x3658 <__divsf3_pse+0x82>
    363e:	b6 c0       	rjmp	.+364    	; 0x37ac <__fp_inf>
    3640:	00 c1       	rjmp	.+512    	; 0x3842 <__fp_szero>
    3642:	5f 3f       	cpi	r21, 0xFF	; 255
    3644:	ec f3       	brlt	.-6      	; 0x3640 <__divsf3_pse+0x6a>
    3646:	98 3e       	cpi	r25, 0xE8	; 232
    3648:	dc f3       	brlt	.-10     	; 0x3640 <__divsf3_pse+0x6a>
    364a:	86 95       	lsr	r24
    364c:	77 95       	ror	r23
    364e:	67 95       	ror	r22
    3650:	b7 95       	ror	r27
    3652:	f7 95       	ror	r31
    3654:	9f 5f       	subi	r25, 0xFF	; 255
    3656:	c9 f7       	brne	.-14     	; 0x364a <__divsf3_pse+0x74>
    3658:	88 0f       	add	r24, r24
    365a:	91 1d       	adc	r25, r1
    365c:	96 95       	lsr	r25
    365e:	87 95       	ror	r24
    3660:	97 f9       	bld	r25, 7
    3662:	08 95       	ret
    3664:	e1 e0       	ldi	r30, 0x01	; 1
    3666:	66 0f       	add	r22, r22
    3668:	77 1f       	adc	r23, r23
    366a:	88 1f       	adc	r24, r24
    366c:	bb 1f       	adc	r27, r27
    366e:	62 17       	cp	r22, r18
    3670:	73 07       	cpc	r23, r19
    3672:	84 07       	cpc	r24, r20
    3674:	ba 07       	cpc	r27, r26
    3676:	20 f0       	brcs	.+8      	; 0x3680 <__divsf3_pse+0xaa>
    3678:	62 1b       	sub	r22, r18
    367a:	73 0b       	sbc	r23, r19
    367c:	84 0b       	sbc	r24, r20
    367e:	ba 0b       	sbc	r27, r26
    3680:	ee 1f       	adc	r30, r30
    3682:	88 f7       	brcc	.-30     	; 0x3666 <__divsf3_pse+0x90>
    3684:	e0 95       	com	r30
    3686:	08 95       	ret

00003688 <__fixsfsi>:
    3688:	04 d0       	rcall	.+8      	; 0x3692 <__fixunssfsi>
    368a:	68 94       	set
    368c:	b1 11       	cpse	r27, r1
    368e:	d9 c0       	rjmp	.+434    	; 0x3842 <__fp_szero>
    3690:	08 95       	ret

00003692 <__fixunssfsi>:
    3692:	bc d0       	rcall	.+376    	; 0x380c <__fp_splitA>
    3694:	88 f0       	brcs	.+34     	; 0x36b8 <__fixunssfsi+0x26>
    3696:	9f 57       	subi	r25, 0x7F	; 127
    3698:	90 f0       	brcs	.+36     	; 0x36be <__fixunssfsi+0x2c>
    369a:	b9 2f       	mov	r27, r25
    369c:	99 27       	eor	r25, r25
    369e:	b7 51       	subi	r27, 0x17	; 23
    36a0:	a0 f0       	brcs	.+40     	; 0x36ca <__fixunssfsi+0x38>
    36a2:	d1 f0       	breq	.+52     	; 0x36d8 <__fixunssfsi+0x46>
    36a4:	66 0f       	add	r22, r22
    36a6:	77 1f       	adc	r23, r23
    36a8:	88 1f       	adc	r24, r24
    36aa:	99 1f       	adc	r25, r25
    36ac:	1a f0       	brmi	.+6      	; 0x36b4 <__fixunssfsi+0x22>
    36ae:	ba 95       	dec	r27
    36b0:	c9 f7       	brne	.-14     	; 0x36a4 <__fixunssfsi+0x12>
    36b2:	12 c0       	rjmp	.+36     	; 0x36d8 <__fixunssfsi+0x46>
    36b4:	b1 30       	cpi	r27, 0x01	; 1
    36b6:	81 f0       	breq	.+32     	; 0x36d8 <__fixunssfsi+0x46>
    36b8:	c3 d0       	rcall	.+390    	; 0x3840 <__fp_zero>
    36ba:	b1 e0       	ldi	r27, 0x01	; 1
    36bc:	08 95       	ret
    36be:	c0 c0       	rjmp	.+384    	; 0x3840 <__fp_zero>
    36c0:	67 2f       	mov	r22, r23
    36c2:	78 2f       	mov	r23, r24
    36c4:	88 27       	eor	r24, r24
    36c6:	b8 5f       	subi	r27, 0xF8	; 248
    36c8:	39 f0       	breq	.+14     	; 0x36d8 <__fixunssfsi+0x46>
    36ca:	b9 3f       	cpi	r27, 0xF9	; 249
    36cc:	cc f3       	brlt	.-14     	; 0x36c0 <__fixunssfsi+0x2e>
    36ce:	86 95       	lsr	r24
    36d0:	77 95       	ror	r23
    36d2:	67 95       	ror	r22
    36d4:	b3 95       	inc	r27
    36d6:	d9 f7       	brne	.-10     	; 0x36ce <__fixunssfsi+0x3c>
    36d8:	3e f4       	brtc	.+14     	; 0x36e8 <__fixunssfsi+0x56>
    36da:	90 95       	com	r25
    36dc:	80 95       	com	r24
    36de:	70 95       	com	r23
    36e0:	61 95       	neg	r22
    36e2:	7f 4f       	sbci	r23, 0xFF	; 255
    36e4:	8f 4f       	sbci	r24, 0xFF	; 255
    36e6:	9f 4f       	sbci	r25, 0xFF	; 255
    36e8:	08 95       	ret

000036ea <__floatunsisf>:
    36ea:	e8 94       	clt
    36ec:	09 c0       	rjmp	.+18     	; 0x3700 <__floatsisf+0x12>

000036ee <__floatsisf>:
    36ee:	97 fb       	bst	r25, 7
    36f0:	3e f4       	brtc	.+14     	; 0x3700 <__floatsisf+0x12>
    36f2:	90 95       	com	r25
    36f4:	80 95       	com	r24
    36f6:	70 95       	com	r23
    36f8:	61 95       	neg	r22
    36fa:	7f 4f       	sbci	r23, 0xFF	; 255
    36fc:	8f 4f       	sbci	r24, 0xFF	; 255
    36fe:	9f 4f       	sbci	r25, 0xFF	; 255
    3700:	99 23       	and	r25, r25
    3702:	a9 f0       	breq	.+42     	; 0x372e <__floatsisf+0x40>
    3704:	f9 2f       	mov	r31, r25
    3706:	96 e9       	ldi	r25, 0x96	; 150
    3708:	bb 27       	eor	r27, r27
    370a:	93 95       	inc	r25
    370c:	f6 95       	lsr	r31
    370e:	87 95       	ror	r24
    3710:	77 95       	ror	r23
    3712:	67 95       	ror	r22
    3714:	b7 95       	ror	r27
    3716:	f1 11       	cpse	r31, r1
    3718:	f8 cf       	rjmp	.-16     	; 0x370a <__floatsisf+0x1c>
    371a:	fa f4       	brpl	.+62     	; 0x375a <__floatsisf+0x6c>
    371c:	bb 0f       	add	r27, r27
    371e:	11 f4       	brne	.+4      	; 0x3724 <__floatsisf+0x36>
    3720:	60 ff       	sbrs	r22, 0
    3722:	1b c0       	rjmp	.+54     	; 0x375a <__floatsisf+0x6c>
    3724:	6f 5f       	subi	r22, 0xFF	; 255
    3726:	7f 4f       	sbci	r23, 0xFF	; 255
    3728:	8f 4f       	sbci	r24, 0xFF	; 255
    372a:	9f 4f       	sbci	r25, 0xFF	; 255
    372c:	16 c0       	rjmp	.+44     	; 0x375a <__floatsisf+0x6c>
    372e:	88 23       	and	r24, r24
    3730:	11 f0       	breq	.+4      	; 0x3736 <__floatsisf+0x48>
    3732:	96 e9       	ldi	r25, 0x96	; 150
    3734:	11 c0       	rjmp	.+34     	; 0x3758 <__floatsisf+0x6a>
    3736:	77 23       	and	r23, r23
    3738:	21 f0       	breq	.+8      	; 0x3742 <__floatsisf+0x54>
    373a:	9e e8       	ldi	r25, 0x8E	; 142
    373c:	87 2f       	mov	r24, r23
    373e:	76 2f       	mov	r23, r22
    3740:	05 c0       	rjmp	.+10     	; 0x374c <__floatsisf+0x5e>
    3742:	66 23       	and	r22, r22
    3744:	71 f0       	breq	.+28     	; 0x3762 <__floatsisf+0x74>
    3746:	96 e8       	ldi	r25, 0x86	; 134
    3748:	86 2f       	mov	r24, r22
    374a:	70 e0       	ldi	r23, 0x00	; 0
    374c:	60 e0       	ldi	r22, 0x00	; 0
    374e:	2a f0       	brmi	.+10     	; 0x375a <__floatsisf+0x6c>
    3750:	9a 95       	dec	r25
    3752:	66 0f       	add	r22, r22
    3754:	77 1f       	adc	r23, r23
    3756:	88 1f       	adc	r24, r24
    3758:	da f7       	brpl	.-10     	; 0x3750 <__floatsisf+0x62>
    375a:	88 0f       	add	r24, r24
    375c:	96 95       	lsr	r25
    375e:	87 95       	ror	r24
    3760:	97 f9       	bld	r25, 7
    3762:	08 95       	ret

00003764 <__fp_cmp>:
    3764:	99 0f       	add	r25, r25
    3766:	00 08       	sbc	r0, r0
    3768:	55 0f       	add	r21, r21
    376a:	aa 0b       	sbc	r26, r26
    376c:	e0 e8       	ldi	r30, 0x80	; 128
    376e:	fe ef       	ldi	r31, 0xFE	; 254
    3770:	16 16       	cp	r1, r22
    3772:	17 06       	cpc	r1, r23
    3774:	e8 07       	cpc	r30, r24
    3776:	f9 07       	cpc	r31, r25
    3778:	c0 f0       	brcs	.+48     	; 0x37aa <__fp_cmp+0x46>
    377a:	12 16       	cp	r1, r18
    377c:	13 06       	cpc	r1, r19
    377e:	e4 07       	cpc	r30, r20
    3780:	f5 07       	cpc	r31, r21
    3782:	98 f0       	brcs	.+38     	; 0x37aa <__fp_cmp+0x46>
    3784:	62 1b       	sub	r22, r18
    3786:	73 0b       	sbc	r23, r19
    3788:	84 0b       	sbc	r24, r20
    378a:	95 0b       	sbc	r25, r21
    378c:	39 f4       	brne	.+14     	; 0x379c <__fp_cmp+0x38>
    378e:	0a 26       	eor	r0, r26
    3790:	61 f0       	breq	.+24     	; 0x37aa <__fp_cmp+0x46>
    3792:	23 2b       	or	r18, r19
    3794:	24 2b       	or	r18, r20
    3796:	25 2b       	or	r18, r21
    3798:	21 f4       	brne	.+8      	; 0x37a2 <__fp_cmp+0x3e>
    379a:	08 95       	ret
    379c:	0a 26       	eor	r0, r26
    379e:	09 f4       	brne	.+2      	; 0x37a2 <__fp_cmp+0x3e>
    37a0:	a1 40       	sbci	r26, 0x01	; 1
    37a2:	a6 95       	lsr	r26
    37a4:	8f ef       	ldi	r24, 0xFF	; 255
    37a6:	81 1d       	adc	r24, r1
    37a8:	81 1d       	adc	r24, r1
    37aa:	08 95       	ret

000037ac <__fp_inf>:
    37ac:	97 f9       	bld	r25, 7
    37ae:	9f 67       	ori	r25, 0x7F	; 127
    37b0:	80 e8       	ldi	r24, 0x80	; 128
    37b2:	70 e0       	ldi	r23, 0x00	; 0
    37b4:	60 e0       	ldi	r22, 0x00	; 0
    37b6:	08 95       	ret

000037b8 <__fp_nan>:
    37b8:	9f ef       	ldi	r25, 0xFF	; 255
    37ba:	80 ec       	ldi	r24, 0xC0	; 192
    37bc:	08 95       	ret

000037be <__fp_pscA>:
    37be:	00 24       	eor	r0, r0
    37c0:	0a 94       	dec	r0
    37c2:	16 16       	cp	r1, r22
    37c4:	17 06       	cpc	r1, r23
    37c6:	18 06       	cpc	r1, r24
    37c8:	09 06       	cpc	r0, r25
    37ca:	08 95       	ret

000037cc <__fp_pscB>:
    37cc:	00 24       	eor	r0, r0
    37ce:	0a 94       	dec	r0
    37d0:	12 16       	cp	r1, r18
    37d2:	13 06       	cpc	r1, r19
    37d4:	14 06       	cpc	r1, r20
    37d6:	05 06       	cpc	r0, r21
    37d8:	08 95       	ret

000037da <__fp_round>:
    37da:	09 2e       	mov	r0, r25
    37dc:	03 94       	inc	r0
    37de:	00 0c       	add	r0, r0
    37e0:	11 f4       	brne	.+4      	; 0x37e6 <__fp_round+0xc>
    37e2:	88 23       	and	r24, r24
    37e4:	52 f0       	brmi	.+20     	; 0x37fa <__fp_round+0x20>
    37e6:	bb 0f       	add	r27, r27
    37e8:	40 f4       	brcc	.+16     	; 0x37fa <__fp_round+0x20>
    37ea:	bf 2b       	or	r27, r31
    37ec:	11 f4       	brne	.+4      	; 0x37f2 <__fp_round+0x18>
    37ee:	60 ff       	sbrs	r22, 0
    37f0:	04 c0       	rjmp	.+8      	; 0x37fa <__fp_round+0x20>
    37f2:	6f 5f       	subi	r22, 0xFF	; 255
    37f4:	7f 4f       	sbci	r23, 0xFF	; 255
    37f6:	8f 4f       	sbci	r24, 0xFF	; 255
    37f8:	9f 4f       	sbci	r25, 0xFF	; 255
    37fa:	08 95       	ret

000037fc <__fp_split3>:
    37fc:	57 fd       	sbrc	r21, 7
    37fe:	90 58       	subi	r25, 0x80	; 128
    3800:	44 0f       	add	r20, r20
    3802:	55 1f       	adc	r21, r21
    3804:	59 f0       	breq	.+22     	; 0x381c <__fp_splitA+0x10>
    3806:	5f 3f       	cpi	r21, 0xFF	; 255
    3808:	71 f0       	breq	.+28     	; 0x3826 <__fp_splitA+0x1a>
    380a:	47 95       	ror	r20

0000380c <__fp_splitA>:
    380c:	88 0f       	add	r24, r24
    380e:	97 fb       	bst	r25, 7
    3810:	99 1f       	adc	r25, r25
    3812:	61 f0       	breq	.+24     	; 0x382c <__fp_splitA+0x20>
    3814:	9f 3f       	cpi	r25, 0xFF	; 255
    3816:	79 f0       	breq	.+30     	; 0x3836 <__fp_splitA+0x2a>
    3818:	87 95       	ror	r24
    381a:	08 95       	ret
    381c:	12 16       	cp	r1, r18
    381e:	13 06       	cpc	r1, r19
    3820:	14 06       	cpc	r1, r20
    3822:	55 1f       	adc	r21, r21
    3824:	f2 cf       	rjmp	.-28     	; 0x380a <__fp_split3+0xe>
    3826:	46 95       	lsr	r20
    3828:	f1 df       	rcall	.-30     	; 0x380c <__fp_splitA>
    382a:	08 c0       	rjmp	.+16     	; 0x383c <__fp_splitA+0x30>
    382c:	16 16       	cp	r1, r22
    382e:	17 06       	cpc	r1, r23
    3830:	18 06       	cpc	r1, r24
    3832:	99 1f       	adc	r25, r25
    3834:	f1 cf       	rjmp	.-30     	; 0x3818 <__fp_splitA+0xc>
    3836:	86 95       	lsr	r24
    3838:	71 05       	cpc	r23, r1
    383a:	61 05       	cpc	r22, r1
    383c:	08 94       	sec
    383e:	08 95       	ret

00003840 <__fp_zero>:
    3840:	e8 94       	clt

00003842 <__fp_szero>:
    3842:	bb 27       	eor	r27, r27
    3844:	66 27       	eor	r22, r22
    3846:	77 27       	eor	r23, r23
    3848:	cb 01       	movw	r24, r22
    384a:	97 f9       	bld	r25, 7
    384c:	08 95       	ret

0000384e <__mulsf3>:
    384e:	0b d0       	rcall	.+22     	; 0x3866 <__mulsf3x>
    3850:	c4 cf       	rjmp	.-120    	; 0x37da <__fp_round>
    3852:	b5 df       	rcall	.-150    	; 0x37be <__fp_pscA>
    3854:	28 f0       	brcs	.+10     	; 0x3860 <__mulsf3+0x12>
    3856:	ba df       	rcall	.-140    	; 0x37cc <__fp_pscB>
    3858:	18 f0       	brcs	.+6      	; 0x3860 <__mulsf3+0x12>
    385a:	95 23       	and	r25, r21
    385c:	09 f0       	breq	.+2      	; 0x3860 <__mulsf3+0x12>
    385e:	a6 cf       	rjmp	.-180    	; 0x37ac <__fp_inf>
    3860:	ab cf       	rjmp	.-170    	; 0x37b8 <__fp_nan>
    3862:	11 24       	eor	r1, r1
    3864:	ee cf       	rjmp	.-36     	; 0x3842 <__fp_szero>

00003866 <__mulsf3x>:
    3866:	ca df       	rcall	.-108    	; 0x37fc <__fp_split3>
    3868:	a0 f3       	brcs	.-24     	; 0x3852 <__mulsf3+0x4>

0000386a <__mulsf3_pse>:
    386a:	95 9f       	mul	r25, r21
    386c:	d1 f3       	breq	.-12     	; 0x3862 <__mulsf3+0x14>
    386e:	95 0f       	add	r25, r21
    3870:	50 e0       	ldi	r21, 0x00	; 0
    3872:	55 1f       	adc	r21, r21
    3874:	62 9f       	mul	r22, r18
    3876:	f0 01       	movw	r30, r0
    3878:	72 9f       	mul	r23, r18
    387a:	bb 27       	eor	r27, r27
    387c:	f0 0d       	add	r31, r0
    387e:	b1 1d       	adc	r27, r1
    3880:	63 9f       	mul	r22, r19
    3882:	aa 27       	eor	r26, r26
    3884:	f0 0d       	add	r31, r0
    3886:	b1 1d       	adc	r27, r1
    3888:	aa 1f       	adc	r26, r26
    388a:	64 9f       	mul	r22, r20
    388c:	66 27       	eor	r22, r22
    388e:	b0 0d       	add	r27, r0
    3890:	a1 1d       	adc	r26, r1
    3892:	66 1f       	adc	r22, r22
    3894:	82 9f       	mul	r24, r18
    3896:	22 27       	eor	r18, r18
    3898:	b0 0d       	add	r27, r0
    389a:	a1 1d       	adc	r26, r1
    389c:	62 1f       	adc	r22, r18
    389e:	73 9f       	mul	r23, r19
    38a0:	b0 0d       	add	r27, r0
    38a2:	a1 1d       	adc	r26, r1
    38a4:	62 1f       	adc	r22, r18
    38a6:	83 9f       	mul	r24, r19
    38a8:	a0 0d       	add	r26, r0
    38aa:	61 1d       	adc	r22, r1
    38ac:	22 1f       	adc	r18, r18
    38ae:	74 9f       	mul	r23, r20
    38b0:	33 27       	eor	r19, r19
    38b2:	a0 0d       	add	r26, r0
    38b4:	61 1d       	adc	r22, r1
    38b6:	23 1f       	adc	r18, r19
    38b8:	84 9f       	mul	r24, r20
    38ba:	60 0d       	add	r22, r0
    38bc:	21 1d       	adc	r18, r1
    38be:	82 2f       	mov	r24, r18
    38c0:	76 2f       	mov	r23, r22
    38c2:	6a 2f       	mov	r22, r26
    38c4:	11 24       	eor	r1, r1
    38c6:	9f 57       	subi	r25, 0x7F	; 127
    38c8:	50 40       	sbci	r21, 0x00	; 0
    38ca:	8a f0       	brmi	.+34     	; 0x38ee <__mulsf3_pse+0x84>
    38cc:	e1 f0       	breq	.+56     	; 0x3906 <__mulsf3_pse+0x9c>
    38ce:	88 23       	and	r24, r24
    38d0:	4a f0       	brmi	.+18     	; 0x38e4 <__mulsf3_pse+0x7a>
    38d2:	ee 0f       	add	r30, r30
    38d4:	ff 1f       	adc	r31, r31
    38d6:	bb 1f       	adc	r27, r27
    38d8:	66 1f       	adc	r22, r22
    38da:	77 1f       	adc	r23, r23
    38dc:	88 1f       	adc	r24, r24
    38de:	91 50       	subi	r25, 0x01	; 1
    38e0:	50 40       	sbci	r21, 0x00	; 0
    38e2:	a9 f7       	brne	.-22     	; 0x38ce <__mulsf3_pse+0x64>
    38e4:	9e 3f       	cpi	r25, 0xFE	; 254
    38e6:	51 05       	cpc	r21, r1
    38e8:	70 f0       	brcs	.+28     	; 0x3906 <__mulsf3_pse+0x9c>
    38ea:	60 cf       	rjmp	.-320    	; 0x37ac <__fp_inf>
    38ec:	aa cf       	rjmp	.-172    	; 0x3842 <__fp_szero>
    38ee:	5f 3f       	cpi	r21, 0xFF	; 255
    38f0:	ec f3       	brlt	.-6      	; 0x38ec <__mulsf3_pse+0x82>
    38f2:	98 3e       	cpi	r25, 0xE8	; 232
    38f4:	dc f3       	brlt	.-10     	; 0x38ec <__mulsf3_pse+0x82>
    38f6:	86 95       	lsr	r24
    38f8:	77 95       	ror	r23
    38fa:	67 95       	ror	r22
    38fc:	b7 95       	ror	r27
    38fe:	f7 95       	ror	r31
    3900:	e7 95       	ror	r30
    3902:	9f 5f       	subi	r25, 0xFF	; 255
    3904:	c1 f7       	brne	.-16     	; 0x38f6 <__mulsf3_pse+0x8c>
    3906:	fe 2b       	or	r31, r30
    3908:	88 0f       	add	r24, r24
    390a:	91 1d       	adc	r25, r1
    390c:	96 95       	lsr	r25
    390e:	87 95       	ror	r24
    3910:	97 f9       	bld	r25, 7
    3912:	08 95       	ret

00003914 <pow>:
    3914:	fa 01       	movw	r30, r20
    3916:	ee 0f       	add	r30, r30
    3918:	ff 1f       	adc	r31, r31
    391a:	30 96       	adiw	r30, 0x00	; 0
    391c:	21 05       	cpc	r18, r1
    391e:	31 05       	cpc	r19, r1
    3920:	99 f1       	breq	.+102    	; 0x3988 <pow+0x74>
    3922:	61 15       	cp	r22, r1
    3924:	71 05       	cpc	r23, r1
    3926:	61 f4       	brne	.+24     	; 0x3940 <pow+0x2c>
    3928:	80 38       	cpi	r24, 0x80	; 128
    392a:	bf e3       	ldi	r27, 0x3F	; 63
    392c:	9b 07       	cpc	r25, r27
    392e:	49 f1       	breq	.+82     	; 0x3982 <pow+0x6e>
    3930:	68 94       	set
    3932:	90 38       	cpi	r25, 0x80	; 128
    3934:	81 05       	cpc	r24, r1
    3936:	61 f0       	breq	.+24     	; 0x3950 <pow+0x3c>
    3938:	80 38       	cpi	r24, 0x80	; 128
    393a:	bf ef       	ldi	r27, 0xFF	; 255
    393c:	9b 07       	cpc	r25, r27
    393e:	41 f0       	breq	.+16     	; 0x3950 <pow+0x3c>
    3940:	99 23       	and	r25, r25
    3942:	42 f5       	brpl	.+80     	; 0x3994 <pow+0x80>
    3944:	ff 3f       	cpi	r31, 0xFF	; 255
    3946:	e1 05       	cpc	r30, r1
    3948:	31 05       	cpc	r19, r1
    394a:	21 05       	cpc	r18, r1
    394c:	11 f1       	breq	.+68     	; 0x3992 <pow+0x7e>
    394e:	e8 94       	clt
    3950:	08 94       	sec
    3952:	e7 95       	ror	r30
    3954:	d9 01       	movw	r26, r18
    3956:	aa 23       	and	r26, r26
    3958:	29 f4       	brne	.+10     	; 0x3964 <pow+0x50>
    395a:	ab 2f       	mov	r26, r27
    395c:	be 2f       	mov	r27, r30
    395e:	f8 5f       	subi	r31, 0xF8	; 248
    3960:	d0 f3       	brcs	.-12     	; 0x3956 <pow+0x42>
    3962:	10 c0       	rjmp	.+32     	; 0x3984 <pow+0x70>
    3964:	ff 5f       	subi	r31, 0xFF	; 255
    3966:	70 f4       	brcc	.+28     	; 0x3984 <pow+0x70>
    3968:	a6 95       	lsr	r26
    396a:	e0 f7       	brcc	.-8      	; 0x3964 <pow+0x50>
    396c:	f7 39       	cpi	r31, 0x97	; 151
    396e:	50 f0       	brcs	.+20     	; 0x3984 <pow+0x70>
    3970:	19 f0       	breq	.+6      	; 0x3978 <pow+0x64>
    3972:	ff 3a       	cpi	r31, 0xAF	; 175
    3974:	38 f4       	brcc	.+14     	; 0x3984 <pow+0x70>
    3976:	9f 77       	andi	r25, 0x7F	; 127
    3978:	9f 93       	push	r25
    397a:	0c d0       	rcall	.+24     	; 0x3994 <pow+0x80>
    397c:	0f 90       	pop	r0
    397e:	07 fc       	sbrc	r0, 7
    3980:	90 58       	subi	r25, 0x80	; 128
    3982:	08 95       	ret
    3984:	3e f0       	brts	.+14     	; 0x3994 <pow+0x80>
    3986:	18 cf       	rjmp	.-464    	; 0x37b8 <__fp_nan>
    3988:	60 e0       	ldi	r22, 0x00	; 0
    398a:	70 e0       	ldi	r23, 0x00	; 0
    398c:	80 e8       	ldi	r24, 0x80	; 128
    398e:	9f e3       	ldi	r25, 0x3F	; 63
    3990:	08 95       	ret
    3992:	4f e7       	ldi	r20, 0x7F	; 127
    3994:	9f 77       	andi	r25, 0x7F	; 127
    3996:	5f 93       	push	r21
    3998:	4f 93       	push	r20
    399a:	3f 93       	push	r19
    399c:	2f 93       	push	r18
    399e:	9e d0       	rcall	.+316    	; 0x3adc <log>
    39a0:	2f 91       	pop	r18
    39a2:	3f 91       	pop	r19
    39a4:	4f 91       	pop	r20
    39a6:	5f 91       	pop	r21
    39a8:	52 df       	rcall	.-348    	; 0x384e <__mulsf3>
    39aa:	05 c0       	rjmp	.+10     	; 0x39b6 <exp>
    39ac:	19 f4       	brne	.+6      	; 0x39b4 <pow+0xa0>
    39ae:	0e f0       	brts	.+2      	; 0x39b2 <pow+0x9e>
    39b0:	fd ce       	rjmp	.-518    	; 0x37ac <__fp_inf>
    39b2:	46 cf       	rjmp	.-372    	; 0x3840 <__fp_zero>
    39b4:	01 cf       	rjmp	.-510    	; 0x37b8 <__fp_nan>

000039b6 <exp>:
    39b6:	2a df       	rcall	.-428    	; 0x380c <__fp_splitA>
    39b8:	c8 f3       	brcs	.-14     	; 0x39ac <pow+0x98>
    39ba:	96 38       	cpi	r25, 0x86	; 134
    39bc:	c0 f7       	brcc	.-16     	; 0x39ae <pow+0x9a>
    39be:	07 f8       	bld	r0, 7
    39c0:	0f 92       	push	r0
    39c2:	e8 94       	clt
    39c4:	2b e3       	ldi	r18, 0x3B	; 59
    39c6:	3a ea       	ldi	r19, 0xAA	; 170
    39c8:	48 eb       	ldi	r20, 0xB8	; 184
    39ca:	5f e7       	ldi	r21, 0x7F	; 127
    39cc:	4e df       	rcall	.-356    	; 0x386a <__mulsf3_pse>
    39ce:	0f 92       	push	r0
    39d0:	0f 92       	push	r0
    39d2:	0f 92       	push	r0
    39d4:	4d b7       	in	r20, 0x3d	; 61
    39d6:	5e b7       	in	r21, 0x3e	; 62
    39d8:	0f 92       	push	r0
    39da:	c0 d0       	rcall	.+384    	; 0x3b5c <modf>
    39dc:	e4 ee       	ldi	r30, 0xE4	; 228
    39de:	f0 e0       	ldi	r31, 0x00	; 0
    39e0:	16 d0       	rcall	.+44     	; 0x3a0e <__fp_powser>
    39e2:	4f 91       	pop	r20
    39e4:	5f 91       	pop	r21
    39e6:	ef 91       	pop	r30
    39e8:	ff 91       	pop	r31
    39ea:	e5 95       	asr	r30
    39ec:	ee 1f       	adc	r30, r30
    39ee:	ff 1f       	adc	r31, r31
    39f0:	49 f0       	breq	.+18     	; 0x3a04 <exp+0x4e>
    39f2:	fe 57       	subi	r31, 0x7E	; 126
    39f4:	e0 68       	ori	r30, 0x80	; 128
    39f6:	44 27       	eor	r20, r20
    39f8:	ee 0f       	add	r30, r30
    39fa:	44 1f       	adc	r20, r20
    39fc:	fa 95       	dec	r31
    39fe:	e1 f7       	brne	.-8      	; 0x39f8 <exp+0x42>
    3a00:	41 95       	neg	r20
    3a02:	55 0b       	sbc	r21, r21
    3a04:	32 d0       	rcall	.+100    	; 0x3a6a <ldexp>
    3a06:	0f 90       	pop	r0
    3a08:	07 fe       	sbrs	r0, 7
    3a0a:	26 c0       	rjmp	.+76     	; 0x3a58 <inverse>
    3a0c:	08 95       	ret

00003a0e <__fp_powser>:
    3a0e:	df 93       	push	r29
    3a10:	cf 93       	push	r28
    3a12:	1f 93       	push	r17
    3a14:	0f 93       	push	r16
    3a16:	ff 92       	push	r15
    3a18:	ef 92       	push	r14
    3a1a:	df 92       	push	r13
    3a1c:	7b 01       	movw	r14, r22
    3a1e:	8c 01       	movw	r16, r24
    3a20:	68 94       	set
    3a22:	05 c0       	rjmp	.+10     	; 0x3a2e <__fp_powser+0x20>
    3a24:	da 2e       	mov	r13, r26
    3a26:	ef 01       	movw	r28, r30
    3a28:	1e df       	rcall	.-452    	; 0x3866 <__mulsf3x>
    3a2a:	fe 01       	movw	r30, r28
    3a2c:	e8 94       	clt
    3a2e:	a5 91       	lpm	r26, Z+
    3a30:	25 91       	lpm	r18, Z+
    3a32:	35 91       	lpm	r19, Z+
    3a34:	45 91       	lpm	r20, Z+
    3a36:	55 91       	lpm	r21, Z+
    3a38:	ae f3       	brts	.-22     	; 0x3a24 <__fp_powser+0x16>
    3a3a:	ef 01       	movw	r28, r30
    3a3c:	66 dd       	rcall	.-1332   	; 0x350a <__addsf3x>
    3a3e:	fe 01       	movw	r30, r28
    3a40:	97 01       	movw	r18, r14
    3a42:	a8 01       	movw	r20, r16
    3a44:	da 94       	dec	r13
    3a46:	79 f7       	brne	.-34     	; 0x3a26 <__fp_powser+0x18>
    3a48:	df 90       	pop	r13
    3a4a:	ef 90       	pop	r14
    3a4c:	ff 90       	pop	r15
    3a4e:	0f 91       	pop	r16
    3a50:	1f 91       	pop	r17
    3a52:	cf 91       	pop	r28
    3a54:	df 91       	pop	r29
    3a56:	08 95       	ret

00003a58 <inverse>:
    3a58:	9b 01       	movw	r18, r22
    3a5a:	ac 01       	movw	r20, r24
    3a5c:	60 e0       	ldi	r22, 0x00	; 0
    3a5e:	70 e0       	ldi	r23, 0x00	; 0
    3a60:	80 e8       	ldi	r24, 0x80	; 128
    3a62:	9f e3       	ldi	r25, 0x3F	; 63
    3a64:	a9 cd       	rjmp	.-1198   	; 0x35b8 <__divsf3>
    3a66:	a2 ce       	rjmp	.-700    	; 0x37ac <__fp_inf>
    3a68:	ac c0       	rjmp	.+344    	; 0x3bc2 <__fp_mpack>

00003a6a <ldexp>:
    3a6a:	d0 de       	rcall	.-608    	; 0x380c <__fp_splitA>
    3a6c:	e8 f3       	brcs	.-6      	; 0x3a68 <inverse+0x10>
    3a6e:	99 23       	and	r25, r25
    3a70:	d9 f3       	breq	.-10     	; 0x3a68 <inverse+0x10>
    3a72:	94 0f       	add	r25, r20
    3a74:	51 1d       	adc	r21, r1
    3a76:	bb f3       	brvs	.-18     	; 0x3a66 <inverse+0xe>
    3a78:	91 50       	subi	r25, 0x01	; 1
    3a7a:	50 40       	sbci	r21, 0x00	; 0
    3a7c:	94 f0       	brlt	.+36     	; 0x3aa2 <ldexp+0x38>
    3a7e:	59 f0       	breq	.+22     	; 0x3a96 <ldexp+0x2c>
    3a80:	88 23       	and	r24, r24
    3a82:	32 f0       	brmi	.+12     	; 0x3a90 <ldexp+0x26>
    3a84:	66 0f       	add	r22, r22
    3a86:	77 1f       	adc	r23, r23
    3a88:	88 1f       	adc	r24, r24
    3a8a:	91 50       	subi	r25, 0x01	; 1
    3a8c:	50 40       	sbci	r21, 0x00	; 0
    3a8e:	c1 f7       	brne	.-16     	; 0x3a80 <ldexp+0x16>
    3a90:	9e 3f       	cpi	r25, 0xFE	; 254
    3a92:	51 05       	cpc	r21, r1
    3a94:	44 f7       	brge	.-48     	; 0x3a66 <inverse+0xe>
    3a96:	88 0f       	add	r24, r24
    3a98:	91 1d       	adc	r25, r1
    3a9a:	96 95       	lsr	r25
    3a9c:	87 95       	ror	r24
    3a9e:	97 f9       	bld	r25, 7
    3aa0:	08 95       	ret
    3aa2:	5f 3f       	cpi	r21, 0xFF	; 255
    3aa4:	ac f0       	brlt	.+42     	; 0x3ad0 <ldexp+0x66>
    3aa6:	98 3e       	cpi	r25, 0xE8	; 232
    3aa8:	9c f0       	brlt	.+38     	; 0x3ad0 <ldexp+0x66>
    3aaa:	bb 27       	eor	r27, r27
    3aac:	86 95       	lsr	r24
    3aae:	77 95       	ror	r23
    3ab0:	67 95       	ror	r22
    3ab2:	b7 95       	ror	r27
    3ab4:	08 f4       	brcc	.+2      	; 0x3ab8 <ldexp+0x4e>
    3ab6:	b1 60       	ori	r27, 0x01	; 1
    3ab8:	93 95       	inc	r25
    3aba:	c1 f7       	brne	.-16     	; 0x3aac <ldexp+0x42>
    3abc:	bb 0f       	add	r27, r27
    3abe:	58 f7       	brcc	.-42     	; 0x3a96 <ldexp+0x2c>
    3ac0:	11 f4       	brne	.+4      	; 0x3ac6 <ldexp+0x5c>
    3ac2:	60 ff       	sbrs	r22, 0
    3ac4:	e8 cf       	rjmp	.-48     	; 0x3a96 <ldexp+0x2c>
    3ac6:	6f 5f       	subi	r22, 0xFF	; 255
    3ac8:	7f 4f       	sbci	r23, 0xFF	; 255
    3aca:	8f 4f       	sbci	r24, 0xFF	; 255
    3acc:	9f 4f       	sbci	r25, 0xFF	; 255
    3ace:	e3 cf       	rjmp	.-58     	; 0x3a96 <ldexp+0x2c>
    3ad0:	b8 ce       	rjmp	.-656    	; 0x3842 <__fp_szero>
    3ad2:	0e f0       	brts	.+2      	; 0x3ad6 <ldexp+0x6c>
    3ad4:	76 c0       	rjmp	.+236    	; 0x3bc2 <__fp_mpack>
    3ad6:	70 ce       	rjmp	.-800    	; 0x37b8 <__fp_nan>
    3ad8:	68 94       	set
    3ada:	68 ce       	rjmp	.-816    	; 0x37ac <__fp_inf>

00003adc <log>:
    3adc:	97 de       	rcall	.-722    	; 0x380c <__fp_splitA>
    3ade:	c8 f3       	brcs	.-14     	; 0x3ad2 <ldexp+0x68>
    3ae0:	99 23       	and	r25, r25
    3ae2:	d1 f3       	breq	.-12     	; 0x3ad8 <ldexp+0x6e>
    3ae4:	c6 f3       	brts	.-16     	; 0x3ad6 <ldexp+0x6c>
    3ae6:	df 93       	push	r29
    3ae8:	cf 93       	push	r28
    3aea:	1f 93       	push	r17
    3aec:	0f 93       	push	r16
    3aee:	ff 92       	push	r15
    3af0:	c9 2f       	mov	r28, r25
    3af2:	dd 27       	eor	r29, r29
    3af4:	88 23       	and	r24, r24
    3af6:	2a f0       	brmi	.+10     	; 0x3b02 <log+0x26>
    3af8:	21 97       	sbiw	r28, 0x01	; 1
    3afa:	66 0f       	add	r22, r22
    3afc:	77 1f       	adc	r23, r23
    3afe:	88 1f       	adc	r24, r24
    3b00:	da f7       	brpl	.-10     	; 0x3af8 <log+0x1c>
    3b02:	20 e0       	ldi	r18, 0x00	; 0
    3b04:	30 e0       	ldi	r19, 0x00	; 0
    3b06:	40 e8       	ldi	r20, 0x80	; 128
    3b08:	5f eb       	ldi	r21, 0xBF	; 191
    3b0a:	9f e3       	ldi	r25, 0x3F	; 63
    3b0c:	88 39       	cpi	r24, 0x98	; 152
    3b0e:	20 f0       	brcs	.+8      	; 0x3b18 <log+0x3c>
    3b10:	80 3e       	cpi	r24, 0xE0	; 224
    3b12:	30 f0       	brcs	.+12     	; 0x3b20 <log+0x44>
    3b14:	21 96       	adiw	r28, 0x01	; 1
    3b16:	8f 77       	andi	r24, 0x7F	; 127
    3b18:	e7 dc       	rcall	.-1586   	; 0x34e8 <__addsf3>
    3b1a:	ec e0       	ldi	r30, 0x0C	; 12
    3b1c:	f1 e0       	ldi	r31, 0x01	; 1
    3b1e:	03 c0       	rjmp	.+6      	; 0x3b26 <log+0x4a>
    3b20:	e3 dc       	rcall	.-1594   	; 0x34e8 <__addsf3>
    3b22:	e9 e3       	ldi	r30, 0x39	; 57
    3b24:	f1 e0       	ldi	r31, 0x01	; 1
    3b26:	73 df       	rcall	.-282    	; 0x3a0e <__fp_powser>
    3b28:	8b 01       	movw	r16, r22
    3b2a:	be 01       	movw	r22, r28
    3b2c:	ec 01       	movw	r28, r24
    3b2e:	fb 2e       	mov	r15, r27
    3b30:	6f 57       	subi	r22, 0x7F	; 127
    3b32:	71 09       	sbc	r23, r1
    3b34:	75 95       	asr	r23
    3b36:	77 1f       	adc	r23, r23
    3b38:	88 0b       	sbc	r24, r24
    3b3a:	99 0b       	sbc	r25, r25
    3b3c:	d8 dd       	rcall	.-1104   	; 0x36ee <__floatsisf>
    3b3e:	28 e1       	ldi	r18, 0x18	; 24
    3b40:	32 e7       	ldi	r19, 0x72	; 114
    3b42:	41 e3       	ldi	r20, 0x31	; 49
    3b44:	5f e3       	ldi	r21, 0x3F	; 63
    3b46:	8f de       	rcall	.-738    	; 0x3866 <__mulsf3x>
    3b48:	af 2d       	mov	r26, r15
    3b4a:	98 01       	movw	r18, r16
    3b4c:	ae 01       	movw	r20, r28
    3b4e:	ff 90       	pop	r15
    3b50:	0f 91       	pop	r16
    3b52:	1f 91       	pop	r17
    3b54:	cf 91       	pop	r28
    3b56:	df 91       	pop	r29
    3b58:	d8 dc       	rcall	.-1616   	; 0x350a <__addsf3x>
    3b5a:	3f ce       	rjmp	.-898    	; 0x37da <__fp_round>

00003b5c <modf>:
    3b5c:	fa 01       	movw	r30, r20
    3b5e:	dc 01       	movw	r26, r24
    3b60:	aa 0f       	add	r26, r26
    3b62:	bb 1f       	adc	r27, r27
    3b64:	9b 01       	movw	r18, r22
    3b66:	ac 01       	movw	r20, r24
    3b68:	bf 57       	subi	r27, 0x7F	; 127
    3b6a:	28 f4       	brcc	.+10     	; 0x3b76 <modf+0x1a>
    3b6c:	22 27       	eor	r18, r18
    3b6e:	33 27       	eor	r19, r19
    3b70:	44 27       	eor	r20, r20
    3b72:	50 78       	andi	r21, 0x80	; 128
    3b74:	1f c0       	rjmp	.+62     	; 0x3bb4 <modf+0x58>
    3b76:	b7 51       	subi	r27, 0x17	; 23
    3b78:	88 f4       	brcc	.+34     	; 0x3b9c <modf+0x40>
    3b7a:	ab 2f       	mov	r26, r27
    3b7c:	00 24       	eor	r0, r0
    3b7e:	46 95       	lsr	r20
    3b80:	37 95       	ror	r19
    3b82:	27 95       	ror	r18
    3b84:	01 1c       	adc	r0, r1
    3b86:	a3 95       	inc	r26
    3b88:	d2 f3       	brmi	.-12     	; 0x3b7e <modf+0x22>
    3b8a:	00 20       	and	r0, r0
    3b8c:	69 f0       	breq	.+26     	; 0x3ba8 <modf+0x4c>
    3b8e:	22 0f       	add	r18, r18
    3b90:	33 1f       	adc	r19, r19
    3b92:	44 1f       	adc	r20, r20
    3b94:	b3 95       	inc	r27
    3b96:	da f3       	brmi	.-10     	; 0x3b8e <modf+0x32>
    3b98:	0d d0       	rcall	.+26     	; 0x3bb4 <modf+0x58>
    3b9a:	a5 cc       	rjmp	.-1718   	; 0x34e6 <__subsf3>
    3b9c:	61 30       	cpi	r22, 0x01	; 1
    3b9e:	71 05       	cpc	r23, r1
    3ba0:	a0 e8       	ldi	r26, 0x80	; 128
    3ba2:	8a 07       	cpc	r24, r26
    3ba4:	b9 46       	sbci	r27, 0x69	; 105
    3ba6:	30 f4       	brcc	.+12     	; 0x3bb4 <modf+0x58>
    3ba8:	9b 01       	movw	r18, r22
    3baa:	ac 01       	movw	r20, r24
    3bac:	66 27       	eor	r22, r22
    3bae:	77 27       	eor	r23, r23
    3bb0:	88 27       	eor	r24, r24
    3bb2:	90 78       	andi	r25, 0x80	; 128
    3bb4:	30 96       	adiw	r30, 0x00	; 0
    3bb6:	21 f0       	breq	.+8      	; 0x3bc0 <modf+0x64>
    3bb8:	20 83       	st	Z, r18
    3bba:	31 83       	std	Z+1, r19	; 0x01
    3bbc:	42 83       	std	Z+2, r20	; 0x02
    3bbe:	53 83       	std	Z+3, r21	; 0x03
    3bc0:	08 95       	ret

00003bc2 <__fp_mpack>:
    3bc2:	9f 3f       	cpi	r25, 0xFF	; 255
    3bc4:	31 f0       	breq	.+12     	; 0x3bd2 <__fp_mpack_finite+0xc>

00003bc6 <__fp_mpack_finite>:
    3bc6:	91 50       	subi	r25, 0x01	; 1
    3bc8:	20 f4       	brcc	.+8      	; 0x3bd2 <__fp_mpack_finite+0xc>
    3bca:	87 95       	ror	r24
    3bcc:	77 95       	ror	r23
    3bce:	67 95       	ror	r22
    3bd0:	b7 95       	ror	r27
    3bd2:	88 0f       	add	r24, r24
    3bd4:	91 1d       	adc	r25, r1
    3bd6:	96 95       	lsr	r25
    3bd8:	87 95       	ror	r24
    3bda:	97 f9       	bld	r25, 7
    3bdc:	08 95       	ret

00003bde <__udivmodhi4>:
    3bde:	aa 1b       	sub	r26, r26
    3be0:	bb 1b       	sub	r27, r27
    3be2:	51 e1       	ldi	r21, 0x11	; 17
    3be4:	07 c0       	rjmp	.+14     	; 0x3bf4 <__udivmodhi4_ep>

00003be6 <__udivmodhi4_loop>:
    3be6:	aa 1f       	adc	r26, r26
    3be8:	bb 1f       	adc	r27, r27
    3bea:	a6 17       	cp	r26, r22
    3bec:	b7 07       	cpc	r27, r23
    3bee:	10 f0       	brcs	.+4      	; 0x3bf4 <__udivmodhi4_ep>
    3bf0:	a6 1b       	sub	r26, r22
    3bf2:	b7 0b       	sbc	r27, r23

00003bf4 <__udivmodhi4_ep>:
    3bf4:	88 1f       	adc	r24, r24
    3bf6:	99 1f       	adc	r25, r25
    3bf8:	5a 95       	dec	r21
    3bfa:	a9 f7       	brne	.-22     	; 0x3be6 <__udivmodhi4_loop>
    3bfc:	80 95       	com	r24
    3bfe:	90 95       	com	r25
    3c00:	bc 01       	movw	r22, r24
    3c02:	cd 01       	movw	r24, r26
    3c04:	08 95       	ret

00003c06 <__divmodhi4>:
    3c06:	97 fb       	bst	r25, 7
    3c08:	09 2e       	mov	r0, r25
    3c0a:	07 26       	eor	r0, r23
    3c0c:	0a d0       	rcall	.+20     	; 0x3c22 <__divmodhi4_neg1>
    3c0e:	77 fd       	sbrc	r23, 7
    3c10:	04 d0       	rcall	.+8      	; 0x3c1a <__divmodhi4_neg2>
    3c12:	e5 df       	rcall	.-54     	; 0x3bde <__udivmodhi4>
    3c14:	06 d0       	rcall	.+12     	; 0x3c22 <__divmodhi4_neg1>
    3c16:	00 20       	and	r0, r0
    3c18:	1a f4       	brpl	.+6      	; 0x3c20 <__divmodhi4_exit>

00003c1a <__divmodhi4_neg2>:
    3c1a:	70 95       	com	r23
    3c1c:	61 95       	neg	r22
    3c1e:	7f 4f       	sbci	r23, 0xFF	; 255

00003c20 <__divmodhi4_exit>:
    3c20:	08 95       	ret

00003c22 <__divmodhi4_neg1>:
    3c22:	f6 f7       	brtc	.-4      	; 0x3c20 <__divmodhi4_exit>
    3c24:	90 95       	com	r25
    3c26:	81 95       	neg	r24
    3c28:	9f 4f       	sbci	r25, 0xFF	; 255
    3c2a:	08 95       	ret

00003c2c <__udivmodsi4>:
    3c2c:	a1 e2       	ldi	r26, 0x21	; 33
    3c2e:	1a 2e       	mov	r1, r26
    3c30:	aa 1b       	sub	r26, r26
    3c32:	bb 1b       	sub	r27, r27
    3c34:	fd 01       	movw	r30, r26
    3c36:	0d c0       	rjmp	.+26     	; 0x3c52 <__udivmodsi4_ep>

00003c38 <__udivmodsi4_loop>:
    3c38:	aa 1f       	adc	r26, r26
    3c3a:	bb 1f       	adc	r27, r27
    3c3c:	ee 1f       	adc	r30, r30
    3c3e:	ff 1f       	adc	r31, r31
    3c40:	a2 17       	cp	r26, r18
    3c42:	b3 07       	cpc	r27, r19
    3c44:	e4 07       	cpc	r30, r20
    3c46:	f5 07       	cpc	r31, r21
    3c48:	20 f0       	brcs	.+8      	; 0x3c52 <__udivmodsi4_ep>
    3c4a:	a2 1b       	sub	r26, r18
    3c4c:	b3 0b       	sbc	r27, r19
    3c4e:	e4 0b       	sbc	r30, r20
    3c50:	f5 0b       	sbc	r31, r21

00003c52 <__udivmodsi4_ep>:
    3c52:	66 1f       	adc	r22, r22
    3c54:	77 1f       	adc	r23, r23
    3c56:	88 1f       	adc	r24, r24
    3c58:	99 1f       	adc	r25, r25
    3c5a:	1a 94       	dec	r1
    3c5c:	69 f7       	brne	.-38     	; 0x3c38 <__udivmodsi4_loop>
    3c5e:	60 95       	com	r22
    3c60:	70 95       	com	r23
    3c62:	80 95       	com	r24
    3c64:	90 95       	com	r25
    3c66:	9b 01       	movw	r18, r22
    3c68:	ac 01       	movw	r20, r24
    3c6a:	bd 01       	movw	r22, r26
    3c6c:	cf 01       	movw	r24, r30
    3c6e:	08 95       	ret

00003c70 <_exit>:
    3c70:	f8 94       	cli

00003c72 <__stop_program>:
    3c72:	ff cf       	rjmp	.-2      	; 0x3c72 <__stop_program>
