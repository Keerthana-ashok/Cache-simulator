
Search.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000054e  00800200  000038f4  00003988  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000038f4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000fbc  0080074e  0080074e  00003ed6  2**0
                  ALLOC
  3 .stab         0000366c  00000000  00000000  00003ed8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000a6c  00000000  00000000  00007544  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000e0  00000000  00000000  00007fb0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003271  00000000  00000000  00008090  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000004e0  00000000  00000000  0000b301  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000f33  00000000  00000000  0000b7e1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000b98  00000000  00000000  0000c714  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000008af  00000000  00000000  0000d2ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00003193  00000000  00000000  0000db5b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000058  00000000  00000000  00010cee  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 b3 00 	jmp	0x166	; 0x166 <__ctors_end>
       4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
       8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
       c:	0c 94 c7 06 	jmp	0xd8e	; 0xd8e <__vector_3>
      10:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      14:	0c 94 a0 03 	jmp	0x740	; 0x740 <__vector_5>
      18:	0c 94 7b 03 	jmp	0x6f6	; 0x6f6 <__vector_6>
      1c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      20:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      24:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      28:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      2c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      30:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      34:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      38:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      3c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      40:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      44:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      48:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      4c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      50:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      54:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      58:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      5c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      60:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      64:	0c 94 38 16 	jmp	0x2c70	; 0x2c70 <__vector_25>
      68:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      6c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      70:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      74:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      78:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      7c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      80:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      84:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      88:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      8c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      90:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      94:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      98:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      9c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      ac:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      bc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      cc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      dc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      e0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	lds	r29, 0x78
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	sts	0xb8, r17
      f2:	ba ab       	sts	0x5a, r27
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	sts	0x9b, r26
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	sts	0x5e, r27
     126:	aa aa       	sts	0x9a, r26
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	sts	0x41, r30
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <path_mm+0xca>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	17 e0       	ldi	r17, 0x07	; 7
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	e4 ef       	ldi	r30, 0xF4	; 244
     17e:	f8 e3       	ldi	r31, 0x38	; 56
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	ae 34       	cpi	r26, 0x4E	; 78
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	17 e1       	ldi	r17, 0x17	; 23
     192:	ae e4       	ldi	r26, 0x4E	; 78
     194:	b7 e0       	ldi	r27, 0x07	; 7
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	aa 30       	cpi	r26, 0x0A	; 10
     19c:	b1 07       	cpc	r27, r17
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	0e 94 2a 18 	call	0x3054	; 0x3054 <main>
     1a4:	0c 94 78 1c 	jmp	0x38f0	; 0x38f0 <_exit>

000001a8 <__bad_interrupt>:
     1a8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001ac <timer1_init>:
//prescale:256
// WGM: 7) PWM 10bit fast, TOP=0x03FF
// actual value: 52.25Hz 
void timer1_init(void)
{
 TCCR1B = 0x00; //stop
     1ac:	e1 e8       	ldi	r30, 0x81	; 129
     1ae:	f0 e0       	ldi	r31, 0x00	; 0
     1b0:	10 82       	st	Z, r1
 TCNT1H = 0xFC; //Counter high value to which OCR1xH value is to be compared with
     1b2:	8c ef       	ldi	r24, 0xFC	; 252
     1b4:	80 93 85 00 	sts	0x0085, r24
 TCNT1L = 0x01;	//Counter low value to which OCR1xH value is to be compared with
     1b8:	81 e0       	ldi	r24, 0x01	; 1
     1ba:	80 93 84 00 	sts	0x0084, r24
 OCR1AH = 0x03;	//Output compare Register high value for servo 1
     1be:	93 e0       	ldi	r25, 0x03	; 3
     1c0:	90 93 89 00 	sts	0x0089, r25
 OCR1AL = 0xFF;	//Output Compare Register low Value For servo 1
     1c4:	8f ef       	ldi	r24, 0xFF	; 255
     1c6:	80 93 88 00 	sts	0x0088, r24
 OCR1BH = 0x03;	//Output compare Register high value for servo 2
     1ca:	90 93 8b 00 	sts	0x008B, r25
 OCR1BL = 0xFF;	//Output Compare Register low Value For servo 2
     1ce:	80 93 8a 00 	sts	0x008A, r24
 OCR1CH = 0x03;	//Output compare Register high value for servo 3
     1d2:	90 93 8d 00 	sts	0x008D, r25
 OCR1CL = 0xFF;	//Output Compare Register low Value For servo 3
     1d6:	80 93 8c 00 	sts	0x008C, r24
 ICR1H  = 0x03;	
     1da:	90 93 87 00 	sts	0x0087, r25
 ICR1L  = 0xFF;
     1de:	80 93 86 00 	sts	0x0086, r24
 TCCR1A = 0xAB; /*{COM1A1=1, COM1A0=0; COM1B1=1, COM1B0=0; COM1C1=1 COM1C0=0}
     1e2:	8b ea       	ldi	r24, 0xAB	; 171
     1e4:	80 93 80 00 	sts	0x0080, r24
 					For Overriding normal port functionality to OCRnA outputs.
				  {WGM11=1, WGM10=1} Along With WGM12 in TCCR1B for Selecting FAST PWM Mode*/
 TCCR1C = 0x00;
     1e8:	10 92 82 00 	sts	0x0082, r1
 TCCR1B = 0x0C; //WGM12=1; CS12=1, CS11=0, CS10=0 (Prescaler=256)
     1ec:	8c e0       	ldi	r24, 0x0C	; 12
     1ee:	80 83       	st	Z, r24
}
     1f0:	08 95       	ret

000001f2 <color_sensor_scaling>:
//Color Sensing Scaling
void color_sensor_scaling()		//This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
{
	//Output Scaling 20% from datasheet
	//PORTD = PORTD & 0xEF;
	PORTD = PORTD | 0x10; //set S0 high
     1f2:	5c 9a       	sbi	0x0b, 4	; 11
	//PORTD = PORTD & 0xDF; //set S1 low
	PORTD = PORTD | 0x20; //set S1 high
     1f4:	5d 9a       	sbi	0x0b, 5	; 11
}
     1f6:	08 95       	ret

000001f8 <USART0_TX>:
	}	
}

void USART0_TX(unsigned char data)
{
	while(!(UCSR0A & (1<<UDRE0)))
     1f8:	e0 ec       	ldi	r30, 0xC0	; 192
     1fa:	f0 e0       	ldi	r31, 0x00	; 0
     1fc:	90 81       	ld	r25, Z
     1fe:	95 ff       	sbrs	r25, 5
     200:	fd cf       	rjmp	.-6      	; 0x1fc <USART0_TX+0x4>
		;
	UDR0 = data;
     202:	80 93 c6 00 	sts	0x00C6, r24
}
     206:	08 95       	ret

00000208 <send>:

void send(int a,int b,int c)
{
     208:	cf 93       	push	r28
     20a:	df 93       	push	r29
     20c:	d6 2f       	mov	r29, r22
     20e:	c4 2f       	mov	r28, r20
	USART0_TX(a);
     210:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <USART0_TX>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     214:	80 e7       	ldi	r24, 0x70	; 112
     216:	91 e0       	ldi	r25, 0x01	; 1
     218:	01 97       	sbiw	r24, 0x01	; 1
     21a:	f1 f7       	brne	.-4      	; 0x218 <send+0x10>
     21c:	00 c0       	rjmp	.+0      	; 0x21e <send+0x16>
	_delay_us(100);
	USART0_TX(b);
     21e:	8d 2f       	mov	r24, r29
     220:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <USART0_TX>
     224:	80 e7       	ldi	r24, 0x70	; 112
     226:	91 e0       	ldi	r25, 0x01	; 1
     228:	01 97       	sbiw	r24, 0x01	; 1
     22a:	f1 f7       	brne	.-4      	; 0x228 <send+0x20>
     22c:	00 c0       	rjmp	.+0      	; 0x22e <send+0x26>
	_delay_us(100);
	USART0_TX(c);
     22e:	8c 2f       	mov	r24, r28
     230:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <USART0_TX>
     234:	80 e7       	ldi	r24, 0x70	; 112
     236:	91 e0       	ldi	r25, 0x01	; 1
     238:	01 97       	sbiw	r24, 0x01	; 1
     23a:	f1 f7       	brne	.-4      	; 0x238 <send+0x30>
     23c:	00 c0       	rjmp	.+0      	; 0x23e <send+0x36>
	_delay_us(100);
}
     23e:	df 91       	pop	r29
     240:	cf 91       	pop	r28
     242:	08 95       	ret

00000244 <lcd_port_config>:
void lcd_line2();
void lcd_string(char*);

void lcd_port_config (void) 			//Function to configure LCD port
{
 	DDRC = DDRC | 0xF7; 		//all the LCD pin's direction set as output
     244:	87 b1       	in	r24, 0x07	; 7
     246:	87 6f       	ori	r24, 0xF7	; 247
     248:	87 b9       	out	0x07, r24	; 7
 	PORTC = PORTC & 0x80; 		// all the LCD pins are set to logic 0 except PORTC 7
     24a:	88 b1       	in	r24, 0x08	; 8
     24c:	80 78       	andi	r24, 0x80	; 128
     24e:	88 b9       	out	0x08, r24	; 8
}
     250:	08 95       	ret

00000252 <lcd_set_4bit>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     252:	86 e6       	ldi	r24, 0x66	; 102
     254:	9e e0       	ldi	r25, 0x0E	; 14
     256:	01 97       	sbiw	r24, 0x01	; 1
     258:	f1 f7       	brne	.-4      	; 0x256 <lcd_set_4bit+0x4>
     25a:	00 00       	nop

void lcd_set_4bit()				//Function to Reset LCD
{
	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     25c:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     25e:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     260:	80 e3       	ldi	r24, 0x30	; 48
     262:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     264:	42 9a       	sbi	0x08, 2	; 8
     266:	ef ef       	ldi	r30, 0xFF	; 255
     268:	f7 e4       	ldi	r31, 0x47	; 71
     26a:	31 97       	sbiw	r30, 0x01	; 1
     26c:	f1 f7       	brne	.-4      	; 0x26a <lcd_set_4bit+0x18>
     26e:	00 c0       	rjmp	.+0      	; 0x270 <lcd_set_4bit+0x1e>
     270:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     272:	42 98       	cbi	0x08, 2	; 8
     274:	e6 e6       	ldi	r30, 0x66	; 102
     276:	fe e0       	ldi	r31, 0x0E	; 14
     278:	31 97       	sbiw	r30, 0x01	; 1
     27a:	f1 f7       	brne	.-4      	; 0x278 <lcd_set_4bit+0x26>
     27c:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     27e:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     280:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     282:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     284:	42 9a       	sbi	0x08, 2	; 8
     286:	ef ef       	ldi	r30, 0xFF	; 255
     288:	f7 e4       	ldi	r31, 0x47	; 71
     28a:	31 97       	sbiw	r30, 0x01	; 1
     28c:	f1 f7       	brne	.-4      	; 0x28a <lcd_set_4bit+0x38>
     28e:	00 c0       	rjmp	.+0      	; 0x290 <lcd_set_4bit+0x3e>
     290:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     292:	42 98       	cbi	0x08, 2	; 8
     294:	e6 e6       	ldi	r30, 0x66	; 102
     296:	fe e0       	ldi	r31, 0x0E	; 14
     298:	31 97       	sbiw	r30, 0x01	; 1
     29a:	f1 f7       	brne	.-4      	; 0x298 <lcd_set_4bit+0x46>
     29c:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     29e:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     2a0:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     2a2:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     2a4:	42 9a       	sbi	0x08, 2	; 8
     2a6:	8f ef       	ldi	r24, 0xFF	; 255
     2a8:	97 e4       	ldi	r25, 0x47	; 71
     2aa:	01 97       	sbiw	r24, 0x01	; 1
     2ac:	f1 f7       	brne	.-4      	; 0x2aa <lcd_set_4bit+0x58>
     2ae:	00 c0       	rjmp	.+0      	; 0x2b0 <lcd_set_4bit+0x5e>
     2b0:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     2b2:	42 98       	cbi	0x08, 2	; 8
     2b4:	e6 e6       	ldi	r30, 0x66	; 102
     2b6:	fe e0       	ldi	r31, 0x0E	; 14
     2b8:	31 97       	sbiw	r30, 0x01	; 1
     2ba:	f1 f7       	brne	.-4      	; 0x2b8 <lcd_set_4bit+0x66>
     2bc:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     2be:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     2c0:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x20;				//Sending 2 to initialise LCD 4-bit mode
     2c2:	80 e2       	ldi	r24, 0x20	; 32
     2c4:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     2c6:	42 9a       	sbi	0x08, 2	; 8
     2c8:	8f ef       	ldi	r24, 0xFF	; 255
     2ca:	97 e4       	ldi	r25, 0x47	; 71
     2cc:	01 97       	sbiw	r24, 0x01	; 1
     2ce:	f1 f7       	brne	.-4      	; 0x2cc <lcd_set_4bit+0x7a>
     2d0:	00 c0       	rjmp	.+0      	; 0x2d2 <lcd_set_4bit+0x80>
     2d2:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     2d4:	42 98       	cbi	0x08, 2	; 8

	
}
     2d6:	08 95       	ret

000002d8 <lcd_wr_command>:
void lcd_wr_command(unsigned char cmd)		//Function to Write Command on LCD
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
	lcd_port &= 0x0F;
     2d8:	98 b1       	in	r25, 0x08	; 8
     2da:	9f 70       	andi	r25, 0x0F	; 15
     2dc:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
     2de:	98 b1       	in	r25, 0x08	; 8

void lcd_wr_command(unsigned char cmd)		//Function to Write Command on LCD
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
     2e0:	28 2f       	mov	r18, r24
     2e2:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     2e4:	92 2b       	or	r25, r18
     2e6:	98 b9       	out	0x08, r25	; 8
	cbit(lcd_port,RS);
     2e8:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     2ea:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     2ec:	42 9a       	sbi	0x08, 2	; 8
     2ee:	ef ef       	ldi	r30, 0xFF	; 255
     2f0:	f7 e4       	ldi	r31, 0x47	; 71
     2f2:	31 97       	sbiw	r30, 0x01	; 1
     2f4:	f1 f7       	brne	.-4      	; 0x2f2 <lcd_wr_command+0x1a>
     2f6:	00 c0       	rjmp	.+0      	; 0x2f8 <lcd_wr_command+0x20>
     2f8:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     2fa:	42 98       	cbi	0x08, 2	; 8
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
	lcd_port &= 0x0F;
     2fc:	98 b1       	in	r25, 0x08	; 8
     2fe:	9f 70       	andi	r25, 0x0F	; 15
     300:	98 b9       	out	0x08, r25	; 8
	lcd_port |= cmd;
     302:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
     304:	82 95       	swap	r24
     306:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= cmd;
     308:	89 2b       	or	r24, r25
     30a:	88 b9       	out	0x08, r24	; 8
	cbit(lcd_port,RS);
     30c:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     30e:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     310:	42 9a       	sbi	0x08, 2	; 8
     312:	8f ef       	ldi	r24, 0xFF	; 255
     314:	97 e4       	ldi	r25, 0x47	; 71
     316:	01 97       	sbiw	r24, 0x01	; 1
     318:	f1 f7       	brne	.-4      	; 0x316 <lcd_wr_command+0x3e>
     31a:	00 c0       	rjmp	.+0      	; 0x31c <lcd_wr_command+0x44>
     31c:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     31e:	42 98       	cbi	0x08, 2	; 8
}
     320:	08 95       	ret

00000322 <lcd_init>:
	
}

void lcd_init()					//Function to Initialize LCD
{
	lcd_set_4bit();
     322:	0e 94 29 01 	call	0x252	; 0x252 <lcd_set_4bit>
     326:	86 e6       	ldi	r24, 0x66	; 102
     328:	9e e0       	ldi	r25, 0x0E	; 14
     32a:	01 97       	sbiw	r24, 0x01	; 1
     32c:	f1 f7       	brne	.-4      	; 0x32a <lcd_init+0x8>
     32e:	00 00       	nop
	_delay_ms(1);

	lcd_wr_command(0x28);			//LCD 4-bit mode and 2 lines.
     330:	88 e2       	ldi	r24, 0x28	; 40
     332:	0e 94 6c 01 	call	0x2d8	; 0x2d8 <lcd_wr_command>
	lcd_wr_command(0x01);
     336:	81 e0       	ldi	r24, 0x01	; 1
     338:	0e 94 6c 01 	call	0x2d8	; 0x2d8 <lcd_wr_command>
	lcd_wr_command(0x06);
     33c:	86 e0       	ldi	r24, 0x06	; 6
     33e:	0e 94 6c 01 	call	0x2d8	; 0x2d8 <lcd_wr_command>
	lcd_wr_command(0x0E);
     342:	8e e0       	ldi	r24, 0x0E	; 14
     344:	0e 94 6c 01 	call	0x2d8	; 0x2d8 <lcd_wr_command>
	lcd_wr_command(0x80);
     348:	80 e8       	ldi	r24, 0x80	; 128
     34a:	0e 94 6c 01 	call	0x2d8	; 0x2d8 <lcd_wr_command>
		
}
     34e:	08 95       	ret

00000350 <lcd_wr_char>:
void lcd_wr_char(char letter)				//Function to Write Data on LCD
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
	lcd_port &= 0x0F;
     350:	98 b1       	in	r25, 0x08	; 8
     352:	9f 70       	andi	r25, 0x0F	; 15
     354:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
     356:	98 b1       	in	r25, 0x08	; 8

void lcd_wr_char(char letter)				//Function to Write Data on LCD
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
     358:	28 2f       	mov	r18, r24
     35a:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     35c:	92 2b       	or	r25, r18
     35e:	98 b9       	out	0x08, r25	; 8
	sbit(lcd_port,RS);
     360:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     362:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     364:	42 9a       	sbi	0x08, 2	; 8
     366:	ef ef       	ldi	r30, 0xFF	; 255
     368:	f7 e4       	ldi	r31, 0x47	; 71
     36a:	31 97       	sbiw	r30, 0x01	; 1
     36c:	f1 f7       	brne	.-4      	; 0x36a <lcd_wr_char+0x1a>
     36e:	00 c0       	rjmp	.+0      	; 0x370 <lcd_wr_char+0x20>
     370:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     372:	42 98       	cbi	0x08, 2	; 8

	letter = letter & 0x0F;
	letter = letter<<4;
	lcd_port &= 0x0F;
     374:	98 b1       	in	r25, 0x08	; 8
     376:	9f 70       	andi	r25, 0x0F	; 15
     378:	98 b9       	out	0x08, r25	; 8
	lcd_port |= letter;
     37a:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);

	letter = letter & 0x0F;
	letter = letter<<4;
     37c:	82 95       	swap	r24
     37e:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= letter;
     380:	89 2b       	or	r24, r25
     382:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,RS);
     384:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     386:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     388:	42 9a       	sbi	0x08, 2	; 8
     38a:	8f ef       	ldi	r24, 0xFF	; 255
     38c:	97 e4       	ldi	r25, 0x47	; 71
     38e:	01 97       	sbiw	r24, 0x01	; 1
     390:	f1 f7       	brne	.-4      	; 0x38e <lcd_wr_char+0x3e>
     392:	00 c0       	rjmp	.+0      	; 0x394 <lcd_wr_char+0x44>
     394:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     396:	42 98       	cbi	0x08, 2	; 8
}
     398:	08 95       	ret

0000039a <lcd_home>:

void lcd_home()					//Function to bring cursor at home position
{
	lcd_wr_command(0x80);
     39a:	80 e8       	ldi	r24, 0x80	; 128
     39c:	0e 94 6c 01 	call	0x2d8	; 0x2d8 <lcd_wr_command>
}
     3a0:	08 95       	ret

000003a2 <lcd_string>:

void lcd_string(char *str)				//Function to Print String on LCD
{
     3a2:	cf 93       	push	r28
     3a4:	df 93       	push	r29
     3a6:	ec 01       	movw	r28, r24
	while(*str != '\0')
     3a8:	88 81       	ld	r24, Y
     3aa:	88 23       	and	r24, r24
     3ac:	31 f0       	breq	.+12     	; 0x3ba <lcd_string+0x18>
void lcd_home()					//Function to bring cursor at home position
{
	lcd_wr_command(0x80);
}

void lcd_string(char *str)				//Function to Print String on LCD
     3ae:	21 96       	adiw	r28, 0x01	; 1
{
	while(*str != '\0')
	{
		lcd_wr_char(*str);
     3b0:	0e 94 a8 01 	call	0x350	; 0x350 <lcd_wr_char>
	lcd_wr_command(0x80);
}

void lcd_string(char *str)				//Function to Print String on LCD
{
	while(*str != '\0')
     3b4:	89 91       	ld	r24, Y+
     3b6:	88 23       	and	r24, r24
     3b8:	d9 f7       	brne	.-10     	; 0x3b0 <lcd_string+0xe>
	{
		lcd_wr_char(*str);
		str++;
	}
}
     3ba:	df 91       	pop	r29
     3bc:	cf 91       	pop	r28
     3be:	08 95       	ret

000003c0 <lcd_cursor>:

void lcd_cursor (char row, char column)			//Position the LCD cursor at "row", "column"
{
	switch (row) 
     3c0:	82 30       	cpi	r24, 0x02	; 2
     3c2:	79 f0       	breq	.+30     	; 0x3e2 <lcd_cursor+0x22>
     3c4:	83 30       	cpi	r24, 0x03	; 3
     3c6:	18 f4       	brcc	.+6      	; 0x3ce <lcd_cursor+0xe>
     3c8:	81 30       	cpi	r24, 0x01	; 1
     3ca:	c9 f4       	brne	.+50     	; 0x3fe <lcd_cursor+0x3e>
     3cc:	05 c0       	rjmp	.+10     	; 0x3d8 <lcd_cursor+0x18>
     3ce:	83 30       	cpi	r24, 0x03	; 3
     3d0:	69 f0       	breq	.+26     	; 0x3ec <lcd_cursor+0x2c>
     3d2:	84 30       	cpi	r24, 0x04	; 4
     3d4:	a1 f4       	brne	.+40     	; 0x3fe <lcd_cursor+0x3e>
     3d6:	0f c0       	rjmp	.+30     	; 0x3f6 <lcd_cursor+0x36>
	{
		case 1: lcd_wr_command (0x80 + column - 1); break;
     3d8:	86 2f       	mov	r24, r22
     3da:	81 58       	subi	r24, 0x81	; 129
     3dc:	0e 94 6c 01 	call	0x2d8	; 0x2d8 <lcd_wr_command>
     3e0:	08 95       	ret
		case 2: lcd_wr_command (0xc0 + column - 1); break;
     3e2:	86 2f       	mov	r24, r22
     3e4:	81 54       	subi	r24, 0x41	; 65
     3e6:	0e 94 6c 01 	call	0x2d8	; 0x2d8 <lcd_wr_command>
     3ea:	08 95       	ret
		case 3: lcd_wr_command (0x94 + column - 1); break;
     3ec:	86 2f       	mov	r24, r22
     3ee:	8d 56       	subi	r24, 0x6D	; 109
     3f0:	0e 94 6c 01 	call	0x2d8	; 0x2d8 <lcd_wr_command>
     3f4:	08 95       	ret
		case 4: lcd_wr_command (0xd4 + column - 1); break;
     3f6:	86 2f       	mov	r24, r22
     3f8:	8d 52       	subi	r24, 0x2D	; 45
     3fa:	0e 94 6c 01 	call	0x2d8	; 0x2d8 <lcd_wr_command>
     3fe:	08 95       	ret

00000400 <lcd_print>:
	}
}


void lcd_print (char row, char coloumn, unsigned int value, int digits)	//Function To Print Any input value upto the desired digit on LCD
{
     400:	0f 93       	push	r16
     402:	1f 93       	push	r17
     404:	cf 93       	push	r28
     406:	df 93       	push	r29
     408:	8a 01       	movw	r16, r20
     40a:	e9 01       	movw	r28, r18
	unsigned int temp,unit,tens,hundred,thousand,million;
	unsigned char flag=0;

	if(row == 0 || coloumn == 0)
     40c:	88 23       	and	r24, r24
     40e:	11 f0       	breq	.+4      	; 0x414 <lcd_print+0x14>
     410:	66 23       	and	r22, r22
     412:	19 f4       	brne	.+6      	; 0x41a <lcd_print+0x1a>
		lcd_home();
     414:	0e 94 cd 01 	call	0x39a	; 0x39a <lcd_home>
     418:	02 c0       	rjmp	.+4      	; 0x41e <lcd_print+0x1e>
	else
		lcd_cursor(row,coloumn);
     41a:	0e 94 e0 01 	call	0x3c0	; 0x3c0 <lcd_cursor>

	if(digits == 5 || flag == 1)
     41e:	c5 30       	cpi	r28, 0x05	; 5
     420:	d1 05       	cpc	r29, r1
     422:	51 f4       	brne	.+20     	; 0x438 <lcd_print+0x38>
	{
		million = value / 10000 + 48;
     424:	c8 01       	movw	r24, r16
     426:	60 e1       	ldi	r22, 0x10	; 16
     428:	77 e2       	ldi	r23, 0x27	; 39
     42a:	0e 94 2f 1c 	call	0x385e	; 0x385e <__udivmodhi4>
		lcd_wr_char(million);
     42e:	86 2f       	mov	r24, r22
     430:	80 5d       	subi	r24, 0xD0	; 208
     432:	0e 94 a8 01 	call	0x350	; 0x350 <lcd_wr_char>
     436:	03 c0       	rjmp	.+6      	; 0x43e <lcd_print+0x3e>
		flag=1;
	}

	if(digits == 4 || flag == 1)
     438:	c4 30       	cpi	r28, 0x04	; 4
     43a:	d1 05       	cpc	r29, r1
     43c:	79 f4       	brne	.+30     	; 0x45c <lcd_print+0x5c>
	{
		temp = value / 1000;
     43e:	c8 01       	movw	r24, r16
     440:	68 ee       	ldi	r22, 0xE8	; 232
     442:	73 e0       	ldi	r23, 0x03	; 3
     444:	0e 94 2f 1c 	call	0x385e	; 0x385e <__udivmodhi4>
     448:	cb 01       	movw	r24, r22
		thousand = temp % 10 + 48;
     44a:	6a e0       	ldi	r22, 0x0A	; 10
     44c:	70 e0       	ldi	r23, 0x00	; 0
     44e:	0e 94 2f 1c 	call	0x385e	; 0x385e <__udivmodhi4>
		lcd_wr_char(thousand);
     452:	80 5d       	subi	r24, 0xD0	; 208
     454:	0e 94 a8 01 	call	0x350	; 0x350 <lcd_wr_char>
		flag=1;
     458:	81 e0       	ldi	r24, 0x01	; 1
     45a:	01 c0       	rjmp	.+2      	; 0x45e <lcd_print+0x5e>


void lcd_print (char row, char coloumn, unsigned int value, int digits)	//Function To Print Any input value upto the desired digit on LCD
{
	unsigned int temp,unit,tens,hundred,thousand,million;
	unsigned char flag=0;
     45c:	80 e0       	ldi	r24, 0x00	; 0
		thousand = temp % 10 + 48;
		lcd_wr_char(thousand);
		flag=1;
	}
 
	if(digits == 3 || flag == 1)
     45e:	c3 30       	cpi	r28, 0x03	; 3
     460:	d1 05       	cpc	r29, r1
     462:	11 f0       	breq	.+4      	; 0x468 <lcd_print+0x68>
     464:	81 30       	cpi	r24, 0x01	; 1
     466:	71 f4       	brne	.+28     	; 0x484 <lcd_print+0x84>
	{
		temp = value / 100;
     468:	c8 01       	movw	r24, r16
     46a:	64 e6       	ldi	r22, 0x64	; 100
     46c:	70 e0       	ldi	r23, 0x00	; 0
     46e:	0e 94 2f 1c 	call	0x385e	; 0x385e <__udivmodhi4>
     472:	cb 01       	movw	r24, r22
		hundred = temp % 10 + 48;
     474:	6a e0       	ldi	r22, 0x0A	; 10
     476:	70 e0       	ldi	r23, 0x00	; 0
     478:	0e 94 2f 1c 	call	0x385e	; 0x385e <__udivmodhi4>
		lcd_wr_char(hundred);
     47c:	80 5d       	subi	r24, 0xD0	; 208
     47e:	0e 94 a8 01 	call	0x350	; 0x350 <lcd_wr_char>
		flag=1;
     482:	81 e0       	ldi	r24, 0x01	; 1
	}

	if(digits == 2 || flag == 1)
     484:	c2 30       	cpi	r28, 0x02	; 2
     486:	d1 05       	cpc	r29, r1
     488:	11 f0       	breq	.+4      	; 0x48e <lcd_print+0x8e>
     48a:	81 30       	cpi	r24, 0x01	; 1
     48c:	71 f4       	brne	.+28     	; 0x4aa <lcd_print+0xaa>
	{
		temp = value / 10;
     48e:	2a e0       	ldi	r18, 0x0A	; 10
     490:	30 e0       	ldi	r19, 0x00	; 0
     492:	c8 01       	movw	r24, r16
     494:	b9 01       	movw	r22, r18
     496:	0e 94 2f 1c 	call	0x385e	; 0x385e <__udivmodhi4>
     49a:	cb 01       	movw	r24, r22
		tens = temp % 10 + 48;
     49c:	b9 01       	movw	r22, r18
     49e:	0e 94 2f 1c 	call	0x385e	; 0x385e <__udivmodhi4>
		lcd_wr_char(tens);
     4a2:	80 5d       	subi	r24, 0xD0	; 208
     4a4:	0e 94 a8 01 	call	0x350	; 0x350 <lcd_wr_char>
		flag=1;
     4a8:	81 e0       	ldi	r24, 0x01	; 1
	}

	if(digits == 1 || flag == 1)
     4aa:	c1 30       	cpi	r28, 0x01	; 1
     4ac:	d1 05       	cpc	r29, r1
     4ae:	11 f0       	breq	.+4      	; 0x4b4 <lcd_print+0xb4>
     4b0:	81 30       	cpi	r24, 0x01	; 1
     4b2:	41 f4       	brne	.+16     	; 0x4c4 <lcd_print+0xc4>
	{
		unit = value % 10 + 48;
     4b4:	c8 01       	movw	r24, r16
     4b6:	6a e0       	ldi	r22, 0x0A	; 10
     4b8:	70 e0       	ldi	r23, 0x00	; 0
     4ba:	0e 94 2f 1c 	call	0x385e	; 0x385e <__udivmodhi4>
		lcd_wr_char(unit);
     4be:	80 5d       	subi	r24, 0xD0	; 208
     4c0:	0e 94 a8 01 	call	0x350	; 0x350 <lcd_wr_char>
	}

	if(digits > 5)
     4c4:	c6 30       	cpi	r28, 0x06	; 6
     4c6:	d1 05       	cpc	r29, r1
     4c8:	1c f0       	brlt	.+6      	; 0x4d0 <lcd_print+0xd0>
	{
		lcd_wr_char('E');
     4ca:	85 e4       	ldi	r24, 0x45	; 69
     4cc:	0e 94 a8 01 	call	0x350	; 0x350 <lcd_wr_char>
	}
	
}
     4d0:	df 91       	pop	r29
     4d2:	cf 91       	pop	r28
     4d4:	1f 91       	pop	r17
     4d6:	0f 91       	pop	r16
     4d8:	08 95       	ret

000004da <adc_pin_config>:
#ifndef SENSOR_H
#define SENSOR_H
#include "lcd.h"
void adc_pin_config (void)			//ADC pin configuration
{
 	DDRF = 0x00; //set PORTF direction as input
     4da:	10 ba       	out	0x10, r1	; 16
 	PORTF = 0x00; //set PORTF pins floating
     4dc:	11 ba       	out	0x11, r1	; 17
 	DDRK = 0x00; //set PORTK direction as input
     4de:	10 92 07 01 	sts	0x0107, r1
 	PORTK = 0x00; //set PORTK pins floating
     4e2:	10 92 08 01 	sts	0x0108, r1
}
     4e6:	08 95       	ret

000004e8 <adc_init>:

void adc_init()
{
	ADCSRA = 0x00;
     4e8:	ea e7       	ldi	r30, 0x7A	; 122
     4ea:	f0 e0       	ldi	r31, 0x00	; 0
     4ec:	10 82       	st	Z, r1
	ADCSRB = 0x00;		//MUX5 = 0
     4ee:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = 0x20;		//Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
     4f2:	80 e2       	ldi	r24, 0x20	; 32
     4f4:	80 93 7c 00 	sts	0x007C, r24
	ACSR = 0x80;
     4f8:	80 e8       	ldi	r24, 0x80	; 128
     4fa:	80 bf       	out	0x30, r24	; 48
	ADCSRA = 0x86;		//ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
     4fc:	86 e8       	ldi	r24, 0x86	; 134
     4fe:	80 83       	st	Z, r24
}
     500:	08 95       	ret

00000502 <ADC_Conversion>:

unsigned char ADC_Conversion(unsigned char Ch)		//This Function accepts the Channel Number and returns the corresponding Analog Value 
{
	unsigned char a;
	if(Ch>7)
     502:	88 30       	cpi	r24, 0x08	; 8
     504:	18 f0       	brcs	.+6      	; 0x50c <ADC_Conversion+0xa>
	{
		ADCSRB = 0x08;
     506:	98 e0       	ldi	r25, 0x08	; 8
     508:	90 93 7b 00 	sts	0x007B, r25
	}
	Ch = Ch & 0x07;  			
     50c:	87 70       	andi	r24, 0x07	; 7
	ADMUX= 0x20| Ch;	   		
     50e:	80 62       	ori	r24, 0x20	; 32
     510:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA = ADCSRA | 0x40;		//Set start conversion bit
     514:	ea e7       	ldi	r30, 0x7A	; 122
     516:	f0 e0       	ldi	r31, 0x00	; 0
     518:	80 81       	ld	r24, Z
     51a:	80 64       	ori	r24, 0x40	; 64
     51c:	80 83       	st	Z, r24
	while((ADCSRA&0x10)==0);	//Wait for ADC conversion to complete
     51e:	80 81       	ld	r24, Z
     520:	84 ff       	sbrs	r24, 4
     522:	fd cf       	rjmp	.-6      	; 0x51e <ADC_Conversion+0x1c>
	a=ADCH;
     524:	80 91 79 00 	lds	r24, 0x0079
	ADCSRA = ADCSRA|0x10; //clear ADIF (ADC Interrupt Flag) by writing 1 to it
     528:	ea e7       	ldi	r30, 0x7A	; 122
     52a:	f0 e0       	ldi	r31, 0x00	; 0
     52c:	90 81       	ld	r25, Z
     52e:	90 61       	ori	r25, 0x10	; 16
     530:	90 83       	st	Z, r25
	ADCSRB = 0x00;
     532:	10 92 7b 00 	sts	0x007B, r1
	return a;
}
     536:	08 95       	ret

00000538 <Sharp_GP2D12_estimation>:

// This Function calculates the actual distance in millimeters(mm) from the input
// analog value of Sharp Sensor. 
unsigned int Sharp_GP2D12_estimation(unsigned char adc_reading)
{
     538:	0f 93       	push	r16
     53a:	1f 93       	push	r17
	float distance;
	unsigned int distanceInt;
	distance = (int)(10.00*(2799.6*(1.00/(pow(adc_reading,1.1546)))));
     53c:	68 2f       	mov	r22, r24
     53e:	70 e0       	ldi	r23, 0x00	; 0
     540:	80 e0       	ldi	r24, 0x00	; 0
     542:	90 e0       	ldi	r25, 0x00	; 0
     544:	0e 94 b5 19 	call	0x336a	; 0x336a <__floatunsisf>
     548:	2f ee       	ldi	r18, 0xEF	; 239
     54a:	39 ec       	ldi	r19, 0xC9	; 201
     54c:	43 e9       	ldi	r20, 0x93	; 147
     54e:	5f e3       	ldi	r21, 0x3F	; 63
     550:	0e 94 ca 1a 	call	0x3594	; 0x3594 <pow>
     554:	b6 2f       	mov	r27, r22
     556:	a7 2f       	mov	r26, r23
     558:	38 2f       	mov	r19, r24
     55a:	29 2f       	mov	r18, r25
     55c:	60 e0       	ldi	r22, 0x00	; 0
     55e:	70 e0       	ldi	r23, 0x00	; 0
     560:	80 e8       	ldi	r24, 0x80	; 128
     562:	9f e3       	ldi	r25, 0x3F	; 63
     564:	42 2f       	mov	r20, r18
     566:	0b 2f       	mov	r16, r27
     568:	1a 2f       	mov	r17, r26
     56a:	23 2f       	mov	r18, r19
     56c:	34 2f       	mov	r19, r20
     56e:	a9 01       	movw	r20, r18
     570:	98 01       	movw	r18, r16
     572:	0e 94 1c 19 	call	0x3238	; 0x3238 <__divsf3>
     576:	2a e9       	ldi	r18, 0x9A	; 154
     578:	39 ef       	ldi	r19, 0xF9	; 249
     57a:	4e e2       	ldi	r20, 0x2E	; 46
     57c:	55 e4       	ldi	r21, 0x45	; 69
     57e:	0e 94 67 1a 	call	0x34ce	; 0x34ce <__mulsf3>
     582:	20 e0       	ldi	r18, 0x00	; 0
     584:	30 e0       	ldi	r19, 0x00	; 0
     586:	40 e2       	ldi	r20, 0x20	; 32
     588:	51 e4       	ldi	r21, 0x41	; 65
     58a:	0e 94 67 1a 	call	0x34ce	; 0x34ce <__mulsf3>
     58e:	0e 94 84 19 	call	0x3308	; 0x3308 <__fixsfsi>
     592:	88 27       	eor	r24, r24
     594:	77 fd       	sbrc	r23, 7
     596:	80 95       	com	r24
     598:	98 2f       	mov	r25, r24
     59a:	0e 94 b7 19 	call	0x336e	; 0x336e <__floatsisf>
	distanceInt = (int)distance;
     59e:	0e 94 84 19 	call	0x3308	; 0x3308 <__fixsfsi>
	if(distanceInt>800)
	{
		distanceInt=800;
	}
	return distanceInt;
     5a2:	86 2f       	mov	r24, r22
     5a4:	97 2f       	mov	r25, r23
     5a6:	23 e0       	ldi	r18, 0x03	; 3
     5a8:	81 32       	cpi	r24, 0x21	; 33
     5aa:	92 07       	cpc	r25, r18
     5ac:	10 f0       	brcs	.+4      	; 0x5b2 <Sharp_GP2D12_estimation+0x7a>
     5ae:	80 e2       	ldi	r24, 0x20	; 32
     5b0:	93 e0       	ldi	r25, 0x03	; 3
}
     5b2:	1f 91       	pop	r17
     5b4:	0f 91       	pop	r16
     5b6:	08 95       	ret

000005b8 <detect_obstacle>:

int detect_obstacle(int low, int high)			// To detect abstrucle present within the distance range low-high 
{
     5b8:	ef 92       	push	r14
     5ba:	ff 92       	push	r15
     5bc:	0f 93       	push	r16
     5be:	1f 93       	push	r17
     5c0:	cf 93       	push	r28
     5c2:	df 93       	push	r29
     5c4:	ec 01       	movw	r28, r24
     5c6:	7b 01       	movw	r14, r22
	unsigned char sharp = ADC_Conversion(11);						//Stores the Analog value of front sharp connected to ADC channel 11 into variable "sharp"
     5c8:	8b e0       	ldi	r24, 0x0B	; 11
     5ca:	0e 94 81 02 	call	0x502	; 0x502 <ADC_Conversion>
	int value = Sharp_GP2D12_estimation(sharp);				//Stores Distance calsulated in a variable "value".
     5ce:	0e 94 9c 02 	call	0x538	; 0x538 <Sharp_GP2D12_estimation>
     5d2:	48 2f       	mov	r20, r24
     5d4:	08 2f       	mov	r16, r24
     5d6:	19 2f       	mov	r17, r25
	
	lcd_print(1,1,value,3);
     5d8:	81 e0       	ldi	r24, 0x01	; 1
     5da:	61 e0       	ldi	r22, 0x01	; 1
     5dc:	59 2f       	mov	r21, r25
     5de:	23 e0       	ldi	r18, 0x03	; 3
     5e0:	30 e0       	ldi	r19, 0x00	; 0
     5e2:	0e 94 00 02 	call	0x400	; 0x400 <lcd_print>
	
	if(value>low && value <high)				// block detected
     5e6:	c0 17       	cp	r28, r16
     5e8:	d1 07       	cpc	r29, r17
     5ea:	44 f4       	brge	.+16     	; 0x5fc <detect_obstacle+0x44>
		distanceInt=800;
	}
	return distanceInt;
}

int detect_obstacle(int low, int high)			// To detect abstrucle present within the distance range low-high 
     5ec:	81 e0       	ldi	r24, 0x01	; 1
     5ee:	90 e0       	ldi	r25, 0x00	; 0
     5f0:	0e 15       	cp	r16, r14
     5f2:	1f 05       	cpc	r17, r15
     5f4:	2c f0       	brlt	.+10     	; 0x600 <detect_obstacle+0x48>
     5f6:	80 e0       	ldi	r24, 0x00	; 0
     5f8:	90 e0       	ldi	r25, 0x00	; 0
     5fa:	02 c0       	rjmp	.+4      	; 0x600 <detect_obstacle+0x48>
	lcd_print(1,1,value,3);
	
	if(value>low && value <high)				// block detected
		return 1;
	else
		return 0;
     5fc:	80 e0       	ldi	r24, 0x00	; 0
     5fe:	90 e0       	ldi	r25, 0x00	; 0
}
     600:	df 91       	pop	r29
     602:	cf 91       	pop	r28
     604:	1f 91       	pop	r17
     606:	0f 91       	pop	r16
     608:	ff 90       	pop	r15
     60a:	ef 90       	pop	r14
     60c:	08 95       	ret

0000060e <detect_white>:

int detect_white(int low, int high,unsigned char ch)			// To detect abstrucle present within the distance range low-high
{
     60e:	ef 92       	push	r14
     610:	ff 92       	push	r15
     612:	0f 93       	push	r16
     614:	1f 93       	push	r17
     616:	cf 93       	push	r28
     618:	df 93       	push	r29
     61a:	8c 01       	movw	r16, r24
     61c:	7b 01       	movw	r14, r22
     61e:	84 2f       	mov	r24, r20
	unsigned char sharp = ADC_Conversion(ch);						//Stores the Analog value of front sharp connected to ADC channel 11 into variable "sharp"
     620:	0e 94 81 02 	call	0x502	; 0x502 <ADC_Conversion>
	int value = Sharp_GP2D12_estimation(sharp);				//Stores Distance calsulated in a variable "value".
     624:	0e 94 9c 02 	call	0x538	; 0x538 <Sharp_GP2D12_estimation>
     628:	48 2f       	mov	r20, r24
     62a:	c8 2f       	mov	r28, r24
     62c:	d9 2f       	mov	r29, r25
	
	lcd_print(1,1,value,3);
     62e:	81 e0       	ldi	r24, 0x01	; 1
     630:	61 e0       	ldi	r22, 0x01	; 1
     632:	59 2f       	mov	r21, r25
     634:	23 e0       	ldi	r18, 0x03	; 3
     636:	30 e0       	ldi	r19, 0x00	; 0
     638:	0e 94 00 02 	call	0x400	; 0x400 <lcd_print>
	
	if(value>low && value <high)				// block detected
     63c:	0c 17       	cp	r16, r28
     63e:	1d 07       	cpc	r17, r29
     640:	44 f4       	brge	.+16     	; 0x652 <detect_white+0x44>
		return 1;
	else
		return 0;
}

int detect_white(int low, int high,unsigned char ch)			// To detect abstrucle present within the distance range low-high
     642:	81 e0       	ldi	r24, 0x01	; 1
     644:	90 e0       	ldi	r25, 0x00	; 0
     646:	ce 15       	cp	r28, r14
     648:	df 05       	cpc	r29, r15
     64a:	2c f0       	brlt	.+10     	; 0x656 <detect_white+0x48>
     64c:	80 e0       	ldi	r24, 0x00	; 0
     64e:	90 e0       	ldi	r25, 0x00	; 0
     650:	02 c0       	rjmp	.+4      	; 0x656 <detect_white+0x48>
	lcd_print(1,1,value,3);
	
	if(value>low && value <high)				// block detected
		return 1;
	else
		return 0;
     652:	80 e0       	ldi	r24, 0x00	; 0
     654:	90 e0       	ldi	r25, 0x00	; 0
}
     656:	df 91       	pop	r29
     658:	cf 91       	pop	r28
     65a:	1f 91       	pop	r17
     65c:	0f 91       	pop	r16
     65e:	ff 90       	pop	r15
     660:	ef 90       	pop	r14
     662:	08 95       	ret

00000664 <motion_pin_config>:
volatile unsigned int Degrees; //to accept angle in degrees for turning

//Function to configure ports to enable robot's motion
void motion_pin_config (void)
{
	DDRA = DDRA | 0x0F;
     664:	81 b1       	in	r24, 0x01	; 1
     666:	8f 60       	ori	r24, 0x0F	; 15
     668:	81 b9       	out	0x01, r24	; 1
	PORTA = PORTA & 0xF0;
     66a:	82 b1       	in	r24, 0x02	; 2
     66c:	80 7f       	andi	r24, 0xF0	; 240
     66e:	82 b9       	out	0x02, r24	; 2
	DDRL = DDRL | 0x18;   //Setting PL3 and PL4 pins as output for PWM generation
     670:	ea e0       	ldi	r30, 0x0A	; 10
     672:	f1 e0       	ldi	r31, 0x01	; 1
     674:	80 81       	ld	r24, Z
     676:	88 61       	ori	r24, 0x18	; 24
     678:	80 83       	st	Z, r24
	PORTL = PORTL | 0x18; //PL3 and PL4 pins are for velocity control using PWM.
     67a:	eb e0       	ldi	r30, 0x0B	; 11
     67c:	f1 e0       	ldi	r31, 0x01	; 1
     67e:	80 81       	ld	r24, Z
     680:	88 61       	ori	r24, 0x18	; 24
     682:	80 83       	st	Z, r24
}
     684:	08 95       	ret

00000686 <left_encoder_pin_config>:

//Function to configure INT4 (PORTE 4) pin as input for the left position encoder
void left_encoder_pin_config (void)
{
	DDRE  = DDRE & 0xEF;  //Set the direction of the PORTE 4 pin as input
     686:	6c 98       	cbi	0x0d, 4	; 13
	PORTE = PORTE | 0x10; //Enable internal pull-up for PORTE 4 pin
     688:	74 9a       	sbi	0x0e, 4	; 14
}
     68a:	08 95       	ret

0000068c <right_encoder_pin_config>:

//Function to configure INT5 (PORTE 5) pin as input for the right position encoder
void right_encoder_pin_config (void)
{
	DDRE  = DDRE & 0xDF;  //Set the direction of the PORTE 4 pin as input
     68c:	6d 98       	cbi	0x0d, 5	; 13
	PORTE = PORTE | 0x20; //Enable internal pull-up for PORTE 4 pin
     68e:	75 9a       	sbi	0x0e, 5	; 14
}
     690:	08 95       	ret

00000692 <left_position_encoder_interrupt_init>:

void left_position_encoder_interrupt_init (void) //Interrupt 4 enable
{
	cli();	//Clears the global interrupt
     692:	f8 94       	cli
	EICRB = EICRB | 0x02; // INT4 is set to trigger with falling edge
     694:	ea e6       	ldi	r30, 0x6A	; 106
     696:	f0 e0       	ldi	r31, 0x00	; 0
     698:	80 81       	ld	r24, Z
     69a:	82 60       	ori	r24, 0x02	; 2
     69c:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x10; // Enable Interrupt INT4 for left position encoder
     69e:	ec 9a       	sbi	0x1d, 4	; 29
	sei();   // Enables the global interrupt
     6a0:	78 94       	sei
}
     6a2:	08 95       	ret

000006a4 <right_position_encoder_interrupt_init>:

void right_position_encoder_interrupt_init (void) //Interrupt 5 enable
{
	cli(); //Clears the global interrupt
     6a4:	f8 94       	cli
	EICRB = EICRB | 0x08; // INT5 is set to trigger with falling edge
     6a6:	ea e6       	ldi	r30, 0x6A	; 106
     6a8:	f0 e0       	ldi	r31, 0x00	; 0
     6aa:	80 81       	ld	r24, Z
     6ac:	88 60       	ori	r24, 0x08	; 8
     6ae:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x20; // Enable Interrupt INT5 for right position encoder
     6b0:	ed 9a       	sbi	0x1d, 5	; 29
	sei();   // Enables the global interrupt
     6b2:	78 94       	sei
}
     6b4:	08 95       	ret

000006b6 <timer5_init>:
// Prescale:256
// PWM 8bit fast, TOP=0x00FF
// Timer Frequency:225.000Hz
void timer5_init()
{
	TCCR5B = 0x00;	//Stop
     6b6:	e1 e2       	ldi	r30, 0x21	; 33
     6b8:	f1 e0       	ldi	r31, 0x01	; 1
     6ba:	10 82       	st	Z, r1
	TCNT5H = 0xFF;	//Counter higher 8-bit value to which OCR5xH value is compared with
     6bc:	8f ef       	ldi	r24, 0xFF	; 255
     6be:	80 93 25 01 	sts	0x0125, r24
	TCNT5L = 0x01;	//Counter lower 8-bit value to which OCR5xH value is compared with
     6c2:	91 e0       	ldi	r25, 0x01	; 1
     6c4:	90 93 24 01 	sts	0x0124, r25
	OCR5AH = 0x00;	//Output compare register high value for Left Motor
     6c8:	10 92 29 01 	sts	0x0129, r1
	OCR5AL = 0xFF;	//Output compare register low value for Left Motor
     6cc:	80 93 28 01 	sts	0x0128, r24
	OCR5BH = 0x00;	//Output compare register high value for Right Motor
     6d0:	10 92 2b 01 	sts	0x012B, r1
	OCR5BL = 0xFF;	//Output compare register low value for Right Motor
     6d4:	80 93 2a 01 	sts	0x012A, r24
	OCR5CH = 0x00;	//Output compare register high value for Motor C1
     6d8:	10 92 2d 01 	sts	0x012D, r1
	OCR5CL = 0xFF;	//Output compare register low value for Motor C1
     6dc:	80 93 2c 01 	sts	0x012C, r24
	TCCR5A = 0xA9;	/*{COM5A1=1, COM5A0=0; COM5B1=1, COM5B0=0; COM5C1=1 COM5C0=0}
     6e0:	89 ea       	ldi	r24, 0xA9	; 169
     6e2:	80 93 20 01 	sts	0x0120, r24
 					  For Overriding normal port functionality to OCRnA outputs.
				  	  {WGM51=0, WGM50=1} Along With WGM52 in TCCR5B for Selecting FAST PWM 8-bit Mode*/	
	TCCR5B = 0x0B;	//WGM12=1; CS12=0, CS11=1, CS10=1 (Prescaler=64)
     6e6:	8b e0       	ldi	r24, 0x0B	; 11
     6e8:	80 83       	st	Z, r24
}
     6ea:	08 95       	ret

000006ec <velocity>:

void velocity (unsigned char left_motor, unsigned char right_motor)	// Function for robot velocity control
{
	OCR5AL = (unsigned char)left_motor;
     6ec:	80 93 28 01 	sts	0x0128, r24
	OCR5BL = (unsigned char)right_motor;
     6f0:	60 93 2a 01 	sts	0x012A, r22
}
     6f4:	08 95       	ret

000006f6 <__vector_6>:

//ISR for right position encoder
ISR(INT5_vect)
{
     6f6:	1f 92       	push	r1
     6f8:	0f 92       	push	r0
     6fa:	0f b6       	in	r0, 0x3f	; 63
     6fc:	0f 92       	push	r0
     6fe:	11 24       	eor	r1, r1
     700:	8f 93       	push	r24
     702:	9f 93       	push	r25
     704:	af 93       	push	r26
     706:	bf 93       	push	r27
	ShaftCountRight++;  //increment right shaft position count
     708:	80 91 c2 0c 	lds	r24, 0x0CC2
     70c:	90 91 c3 0c 	lds	r25, 0x0CC3
     710:	a0 91 c4 0c 	lds	r26, 0x0CC4
     714:	b0 91 c5 0c 	lds	r27, 0x0CC5
     718:	01 96       	adiw	r24, 0x01	; 1
     71a:	a1 1d       	adc	r26, r1
     71c:	b1 1d       	adc	r27, r1
     71e:	80 93 c2 0c 	sts	0x0CC2, r24
     722:	90 93 c3 0c 	sts	0x0CC3, r25
     726:	a0 93 c4 0c 	sts	0x0CC4, r26
     72a:	b0 93 c5 0c 	sts	0x0CC5, r27
}
     72e:	bf 91       	pop	r27
     730:	af 91       	pop	r26
     732:	9f 91       	pop	r25
     734:	8f 91       	pop	r24
     736:	0f 90       	pop	r0
     738:	0f be       	out	0x3f, r0	; 63
     73a:	0f 90       	pop	r0
     73c:	1f 90       	pop	r1
     73e:	18 95       	reti

00000740 <__vector_5>:


//ISR for left position encoder
ISR(INT4_vect)
{
     740:	1f 92       	push	r1
     742:	0f 92       	push	r0
     744:	0f b6       	in	r0, 0x3f	; 63
     746:	0f 92       	push	r0
     748:	11 24       	eor	r1, r1
     74a:	8f 93       	push	r24
     74c:	9f 93       	push	r25
     74e:	af 93       	push	r26
     750:	bf 93       	push	r27
	ShaftCountLeft++;  //increment left shaft position count
     752:	80 91 c6 0c 	lds	r24, 0x0CC6
     756:	90 91 c7 0c 	lds	r25, 0x0CC7
     75a:	a0 91 c8 0c 	lds	r26, 0x0CC8
     75e:	b0 91 c9 0c 	lds	r27, 0x0CC9
     762:	01 96       	adiw	r24, 0x01	; 1
     764:	a1 1d       	adc	r26, r1
     766:	b1 1d       	adc	r27, r1
     768:	80 93 c6 0c 	sts	0x0CC6, r24
     76c:	90 93 c7 0c 	sts	0x0CC7, r25
     770:	a0 93 c8 0c 	sts	0x0CC8, r26
     774:	b0 93 c9 0c 	sts	0x0CC9, r27
}
     778:	bf 91       	pop	r27
     77a:	af 91       	pop	r26
     77c:	9f 91       	pop	r25
     77e:	8f 91       	pop	r24
     780:	0f 90       	pop	r0
     782:	0f be       	out	0x3f, r0	; 63
     784:	0f 90       	pop	r0
     786:	1f 90       	pop	r1
     788:	18 95       	reti

0000078a <motion_set>:
void motion_set (unsigned char Direction)
{
	unsigned char PortARestore = 0;

	Direction &= 0x0F; 		// removing upper nibbel for the protection
	PortARestore = PORTA; 		// reading the PORTA original status
     78a:	92 b1       	in	r25, 0x02	; 2
	PortARestore &= 0xF0; 		// making lower direction nibbel to 0
     78c:	90 7f       	andi	r25, 0xF0	; 240
//Function used for setting motor's direction
void motion_set (unsigned char Direction)
{
	unsigned char PortARestore = 0;

	Direction &= 0x0F; 		// removing upper nibbel for the protection
     78e:	8f 70       	andi	r24, 0x0F	; 15
	PortARestore = PORTA; 		// reading the PORTA original status
	PortARestore &= 0xF0; 		// making lower direction nibbel to 0
	PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
     790:	98 2b       	or	r25, r24
	PORTA = PortARestore; 		// executing the command
     792:	92 b9       	out	0x02, r25	; 2
}
     794:	08 95       	ret

00000796 <forward>:

void forward (void) //both wheels forward
{
	motion_set(0x06);
     796:	86 e0       	ldi	r24, 0x06	; 6
     798:	0e 94 c5 03 	call	0x78a	; 0x78a <motion_set>
}
     79c:	08 95       	ret

0000079e <back>:

void back (void) //both wheels forward
{
	motion_set(0x09);
     79e:	89 e0       	ldi	r24, 0x09	; 9
     7a0:	0e 94 c5 03 	call	0x78a	; 0x78a <motion_set>
}
     7a4:	08 95       	ret

000007a6 <left>:

void left (void) //Left wheel backward, Right wheel forward
{
	motion_set(0x05);
     7a6:	85 e0       	ldi	r24, 0x05	; 5
     7a8:	0e 94 c5 03 	call	0x78a	; 0x78a <motion_set>
}
     7ac:	08 95       	ret

000007ae <right>:

void right (void) //Left wheel forward, Right wheel backward
{
	motion_set(0x0A);
     7ae:	8a e0       	ldi	r24, 0x0A	; 10
     7b0:	0e 94 c5 03 	call	0x78a	; 0x78a <motion_set>
}
     7b4:	08 95       	ret

000007b6 <stop>:

void stop (void)
{
	motion_set(0x00);
     7b6:	80 e0       	ldi	r24, 0x00	; 0
     7b8:	0e 94 c5 03 	call	0x78a	; 0x78a <motion_set>
}
     7bc:	08 95       	ret

000007be <angle_rotate>:

//Function used for turning robot by specified degrees
void angle_rotate(unsigned int Degrees)
{
     7be:	0f 93       	push	r16
     7c0:	1f 93       	push	r17
     7c2:	cf 93       	push	r28
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0;

	ReqdShaftCount = (float) Degrees/ 4.090; // division by resolution to get shaft count
     7c4:	bc 01       	movw	r22, r24
     7c6:	80 e0       	ldi	r24, 0x00	; 0
     7c8:	90 e0       	ldi	r25, 0x00	; 0
     7ca:	0e 94 b5 19 	call	0x336a	; 0x336a <__floatunsisf>
     7ce:	28 e4       	ldi	r18, 0x48	; 72
     7d0:	31 ee       	ldi	r19, 0xE1	; 225
     7d2:	42 e8       	ldi	r20, 0x82	; 130
     7d4:	50 e4       	ldi	r21, 0x40	; 64
     7d6:	0e 94 1c 19 	call	0x3238	; 0x3238 <__divsf3>
	ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
     7da:	0e 94 89 19 	call	0x3312	; 0x3312 <__fixunssfsi>
     7de:	dc 01       	movw	r26, r24
     7e0:	cb 01       	movw	r24, r22
     7e2:	a0 e0       	ldi	r26, 0x00	; 0
     7e4:	b0 e0       	ldi	r27, 0x00	; 0
	ShaftCountRight = 0;
     7e6:	10 92 c2 0c 	sts	0x0CC2, r1
     7ea:	10 92 c3 0c 	sts	0x0CC3, r1
     7ee:	10 92 c4 0c 	sts	0x0CC4, r1
     7f2:	10 92 c5 0c 	sts	0x0CC5, r1
	ShaftCountLeft = 0;
     7f6:	10 92 c6 0c 	sts	0x0CC6, r1
     7fa:	10 92 c7 0c 	sts	0x0CC7, r1
     7fe:	10 92 c8 0c 	sts	0x0CC8, r1
     802:	10 92 c9 0c 	sts	0x0CC9, r1

	while (1)
	{
		if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
     806:	f1 e0       	ldi	r31, 0x01	; 1
     808:	c0 e0       	ldi	r28, 0x00	; 0
     80a:	40 91 c2 0c 	lds	r20, 0x0CC2
     80e:	50 91 c3 0c 	lds	r21, 0x0CC3
     812:	60 91 c4 0c 	lds	r22, 0x0CC4
     816:	70 91 c5 0c 	lds	r23, 0x0CC5
     81a:	00 91 c6 0c 	lds	r16, 0x0CC6
     81e:	10 91 c7 0c 	lds	r17, 0x0CC7
     822:	20 91 c8 0c 	lds	r18, 0x0CC8
     826:	30 91 c9 0c 	lds	r19, 0x0CC9
     82a:	ef 2f       	mov	r30, r31
     82c:	48 17       	cp	r20, r24
     82e:	59 07       	cpc	r21, r25
     830:	6a 07       	cpc	r22, r26
     832:	7b 07       	cpc	r23, r27
     834:	08 f4       	brcc	.+2      	; 0x838 <angle_rotate+0x7a>
     836:	ec 2f       	mov	r30, r28
     838:	ee 23       	and	r30, r30
     83a:	49 f4       	brne	.+18     	; 0x84e <angle_rotate+0x90>
     83c:	4f 2f       	mov	r20, r31
     83e:	08 17       	cp	r16, r24
     840:	19 07       	cpc	r17, r25
     842:	2a 07       	cpc	r18, r26
     844:	3b 07       	cpc	r19, r27
     846:	08 f4       	brcc	.+2      	; 0x84a <angle_rotate+0x8c>
     848:	4c 2f       	mov	r20, r28
     84a:	44 23       	and	r20, r20
     84c:	f1 f2       	breq	.-68     	; 0x80a <angle_rotate+0x4c>
		break;
		
	}
	stop(); //Stop robot
     84e:	0e 94 db 03 	call	0x7b6	; 0x7b6 <stop>
}
     852:	cf 91       	pop	r28
     854:	1f 91       	pop	r17
     856:	0f 91       	pop	r16
     858:	08 95       	ret

0000085a <left_degrees>:

//Function used for moving robot forward by specified distance


void left_degrees(unsigned int Degrees)
{
     85a:	cf 93       	push	r28
     85c:	df 93       	push	r29
     85e:	ec 01       	movw	r28, r24
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	velocity(255,255);
     860:	8f ef       	ldi	r24, 0xFF	; 255
     862:	6f ef       	ldi	r22, 0xFF	; 255
     864:	0e 94 76 03 	call	0x6ec	; 0x6ec <velocity>
	left(); //Turn left
     868:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <left>
	angle_rotate(Degrees);
     86c:	ce 01       	movw	r24, r28
     86e:	0e 94 df 03 	call	0x7be	; 0x7be <angle_rotate>
}
     872:	df 91       	pop	r29
     874:	cf 91       	pop	r28
     876:	08 95       	ret

00000878 <right_degrees>:

void right_degrees(unsigned int Degrees)
{
     878:	cf 93       	push	r28
     87a:	df 93       	push	r29
     87c:	ec 01       	movw	r28, r24
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	velocity(255,255);
     87e:	8f ef       	ldi	r24, 0xFF	; 255
     880:	6f ef       	ldi	r22, 0xFF	; 255
     882:	0e 94 76 03 	call	0x6ec	; 0x6ec <velocity>
	right(); //Turn right
     886:	0e 94 d7 03 	call	0x7ae	; 0x7ae <right>
	angle_rotate(Degrees);
     88a:	ce 01       	movw	r24, r28
     88c:	0e 94 df 03 	call	0x7be	; 0x7be <angle_rotate>
}
     890:	df 91       	pop	r29
     892:	cf 91       	pop	r28
     894:	08 95       	ret

00000896 <path_mm>:

void path_mm (unsigned long int distance)		//Line following cowering a specified linear distance in mm
{
     896:	8f 92       	push	r8
     898:	9f 92       	push	r9
     89a:	af 92       	push	r10
     89c:	bf 92       	push	r11
     89e:	cf 92       	push	r12
     8a0:	df 92       	push	r13
     8a2:	ef 92       	push	r14
     8a4:	ff 92       	push	r15
     8a6:	cf 93       	push	r28
     8a8:	df 93       	push	r29
     8aa:	4b 01       	movw	r8, r22
     8ac:	5c 01       	movw	r10, r24
	unsigned char Left_white_line,Center_white_line,Right_white_line;
	unsigned long int dec=distance;
	ShaftCountRight=0;
     8ae:	10 92 c2 0c 	sts	0x0CC2, r1
     8b2:	10 92 c3 0c 	sts	0x0CC3, r1
     8b6:	10 92 c4 0c 	sts	0x0CC4, r1
     8ba:	10 92 c5 0c 	sts	0x0CC5, r1

	forward();
     8be:	0e 94 cb 03 	call	0x796	; 0x796 <forward>
	while((ShaftCountRight * 5.333)<dec)
     8c2:	25 c0       	rjmp	.+74     	; 0x90e <path_mm+0x78>
	{
		Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
     8c4:	83 e0       	ldi	r24, 0x03	; 3
     8c6:	0e 94 81 02 	call	0x502	; 0x502 <ADC_Conversion>
     8ca:	d8 2f       	mov	r29, r24
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
     8cc:	82 e0       	ldi	r24, 0x02	; 2
     8ce:	0e 94 81 02 	call	0x502	; 0x502 <ADC_Conversion>
     8d2:	c8 2f       	mov	r28, r24
		Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor
     8d4:	81 e0       	ldi	r24, 0x01	; 1
     8d6:	0e 94 81 02 	call	0x502	; 0x502 <ADC_Conversion>
		
		if(Center_white_line > 12 )
     8da:	cd 30       	cpi	r28, 0x0D	; 13
     8dc:	38 f0       	brcs	.+14     	; 0x8ec <path_mm+0x56>
		{
			forward();
     8de:	0e 94 cb 03 	call	0x796	; 0x796 <forward>
			velocity(255,255);
     8e2:	8f ef       	ldi	r24, 0xFF	; 255
     8e4:	6f ef       	ldi	r22, 0xFF	; 255
     8e6:	0e 94 76 03 	call	0x6ec	; 0x6ec <velocity>
     8ea:	11 c0       	rjmp	.+34     	; 0x90e <path_mm+0x78>
		}
		else if(Left_white_line > 12)
     8ec:	dd 30       	cpi	r29, 0x0D	; 13
     8ee:	38 f0       	brcs	.+14     	; 0x8fe <path_mm+0x68>
		{
			forward();
     8f0:	0e 94 cb 03 	call	0x796	; 0x796 <forward>
			velocity(100,255);
     8f4:	84 e6       	ldi	r24, 0x64	; 100
     8f6:	6f ef       	ldi	r22, 0xFF	; 255
     8f8:	0e 94 76 03 	call	0x6ec	; 0x6ec <velocity>
     8fc:	08 c0       	rjmp	.+16     	; 0x90e <path_mm+0x78>
		}
		else if(Right_white_line > 12)
     8fe:	8d 30       	cpi	r24, 0x0D	; 13
     900:	30 f0       	brcs	.+12     	; 0x90e <path_mm+0x78>
		{
			forward();
     902:	0e 94 cb 03 	call	0x796	; 0x796 <forward>
			velocity(255,100);
     906:	8f ef       	ldi	r24, 0xFF	; 255
     908:	64 e6       	ldi	r22, 0x64	; 100
     90a:	0e 94 76 03 	call	0x6ec	; 0x6ec <velocity>
	unsigned char Left_white_line,Center_white_line,Right_white_line;
	unsigned long int dec=distance;
	ShaftCountRight=0;

	forward();
	while((ShaftCountRight * 5.333)<dec)
     90e:	60 91 c2 0c 	lds	r22, 0x0CC2
     912:	70 91 c3 0c 	lds	r23, 0x0CC3
     916:	80 91 c4 0c 	lds	r24, 0x0CC4
     91a:	90 91 c5 0c 	lds	r25, 0x0CC5
     91e:	0e 94 b5 19 	call	0x336a	; 0x336a <__floatunsisf>
     922:	20 ef       	ldi	r18, 0xF0	; 240
     924:	37 ea       	ldi	r19, 0xA7	; 167
     926:	4a ea       	ldi	r20, 0xAA	; 170
     928:	50 e4       	ldi	r21, 0x40	; 64
     92a:	0e 94 67 1a 	call	0x34ce	; 0x34ce <__mulsf3>
     92e:	6b 01       	movw	r12, r22
     930:	7c 01       	movw	r14, r24
     932:	c5 01       	movw	r24, r10
     934:	b4 01       	movw	r22, r8
     936:	0e 94 b5 19 	call	0x336a	; 0x336a <__floatunsisf>
     93a:	9b 01       	movw	r18, r22
     93c:	ac 01       	movw	r20, r24
     93e:	c7 01       	movw	r24, r14
     940:	b6 01       	movw	r22, r12
     942:	0e 94 18 19 	call	0x3230	; 0x3230 <__cmpsf2>
     946:	88 23       	and	r24, r24
     948:	0c f4       	brge	.+2      	; 0x94c <path_mm+0xb6>
     94a:	bc cf       	rjmp	.-136    	; 0x8c4 <path_mm+0x2e>
			forward();
			velocity(255,100);
		}
		
	}
	stop();
     94c:	0e 94 db 03 	call	0x7b6	; 0x7b6 <stop>
     950:	83 e3       	ldi	r24, 0x33	; 51
     952:	93 e7       	ldi	r25, 0x73	; 115
     954:	01 97       	sbiw	r24, 0x01	; 1
     956:	f1 f7       	brne	.-4      	; 0x954 <path_mm+0xbe>
	_delay_ms(8);
}
     958:	df 91       	pop	r29
     95a:	cf 91       	pop	r28
     95c:	ff 90       	pop	r15
     95e:	ef 90       	pop	r14
     960:	df 90       	pop	r13
     962:	cf 90       	pop	r12
     964:	bf 90       	pop	r11
     966:	af 90       	pop	r10
     968:	9f 90       	pop	r9
     96a:	8f 90       	pop	r8
     96c:	08 95       	ret

0000096e <linear_mm>:


void linear_mm (unsigned long int distance)		//Line following cowering a specified linear distance in mm
{
     96e:	8f 92       	push	r8
     970:	9f 92       	push	r9
     972:	af 92       	push	r10
     974:	bf 92       	push	r11
     976:	cf 92       	push	r12
     978:	df 92       	push	r13
     97a:	ef 92       	push	r14
     97c:	ff 92       	push	r15
     97e:	4b 01       	movw	r8, r22
     980:	5c 01       	movw	r10, r24
	unsigned long int dec=distance;
	ShaftCountRight=0;
     982:	10 92 c2 0c 	sts	0x0CC2, r1
     986:	10 92 c3 0c 	sts	0x0CC3, r1
     98a:	10 92 c4 0c 	sts	0x0CC4, r1
     98e:	10 92 c5 0c 	sts	0x0CC5, r1

	//forward();
	while((ShaftCountRight * 5.333)<dec)
     992:	60 91 c2 0c 	lds	r22, 0x0CC2
     996:	70 91 c3 0c 	lds	r23, 0x0CC3
     99a:	80 91 c4 0c 	lds	r24, 0x0CC4
     99e:	90 91 c5 0c 	lds	r25, 0x0CC5
     9a2:	0e 94 b5 19 	call	0x336a	; 0x336a <__floatunsisf>
     9a6:	20 ef       	ldi	r18, 0xF0	; 240
     9a8:	37 ea       	ldi	r19, 0xA7	; 167
     9aa:	4a ea       	ldi	r20, 0xAA	; 170
     9ac:	50 e4       	ldi	r21, 0x40	; 64
     9ae:	0e 94 67 1a 	call	0x34ce	; 0x34ce <__mulsf3>
     9b2:	6b 01       	movw	r12, r22
     9b4:	7c 01       	movw	r14, r24
     9b6:	c5 01       	movw	r24, r10
     9b8:	b4 01       	movw	r22, r8
     9ba:	0e 94 b5 19 	call	0x336a	; 0x336a <__floatunsisf>
     9be:	9b 01       	movw	r18, r22
     9c0:	ac 01       	movw	r20, r24
     9c2:	c7 01       	movw	r24, r14
     9c4:	b6 01       	movw	r22, r12
     9c6:	0e 94 18 19 	call	0x3230	; 0x3230 <__cmpsf2>
     9ca:	88 23       	and	r24, r24
     9cc:	14 f3       	brlt	.-60     	; 0x992 <linear_mm+0x24>
	;
	stop();
     9ce:	0e 94 db 03 	call	0x7b6	; 0x7b6 <stop>
     9d2:	83 e3       	ldi	r24, 0x33	; 51
     9d4:	93 e7       	ldi	r25, 0x73	; 115
     9d6:	01 97       	sbiw	r24, 0x01	; 1
     9d8:	f1 f7       	brne	.-4      	; 0x9d6 <linear_mm+0x68>
	_delay_ms(8);
}
     9da:	ff 90       	pop	r15
     9dc:	ef 90       	pop	r14
     9de:	df 90       	pop	r13
     9e0:	cf 90       	pop	r12
     9e2:	bf 90       	pop	r11
     9e4:	af 90       	pop	r10
     9e6:	9f 90       	pop	r9
     9e8:	8f 90       	pop	r8
     9ea:	08 95       	ret

000009ec <path_node>:


void path_node (int n)			//Line following cowering a specified number of nodes
{
     9ec:	ef 92       	push	r14
     9ee:	ff 92       	push	r15
     9f0:	1f 93       	push	r17
     9f2:	cf 93       	push	r28
     9f4:	df 93       	push	r29
     9f6:	7c 01       	movw	r14, r24
	unsigned char Left_white_line,Center_white_line,Right_white_line,count = 0;
	
	forward();
     9f8:	0e 94 cb 03 	call	0x796	; 0x796 <forward>
	velocity(255,255);
     9fc:	8f ef       	ldi	r24, 0xFF	; 255
     9fe:	6f ef       	ldi	r22, 0xFF	; 255
     a00:	0e 94 76 03 	call	0x6ec	; 0x6ec <velocity>
}


void path_node (int n)			//Line following cowering a specified number of nodes
{
	unsigned char Left_white_line,Center_white_line,Right_white_line,count = 0;
     a04:	d0 e0       	ldi	r29, 0x00	; 0
	
	forward();
	velocity(255,255);

	while(count < n)
     a06:	37 c0       	rjmp	.+110    	; 0xa76 <path_node+0x8a>
	{
		Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
     a08:	83 e0       	ldi	r24, 0x03	; 3
     a0a:	0e 94 81 02 	call	0x502	; 0x502 <ADC_Conversion>
     a0e:	18 2f       	mov	r17, r24
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
     a10:	82 e0       	ldi	r24, 0x02	; 2
     a12:	0e 94 81 02 	call	0x502	; 0x502 <ADC_Conversion>
     a16:	c8 2f       	mov	r28, r24
		Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor	
     a18:	81 e0       	ldi	r24, 0x01	; 1
     a1a:	0e 94 81 02 	call	0x502	; 0x502 <ADC_Conversion>
		
		if(((Center_white_line>12 && Left_white_line>12) ||(Center_white_line>12 && Right_white_line>12)))// Node Detection
     a1e:	cd 30       	cpi	r28, 0x0D	; 13
     a20:	c8 f0       	brcs	.+50     	; 0xa54 <path_node+0x68>
     a22:	1d 30       	cpi	r17, 0x0D	; 13
     a24:	10 f4       	brcc	.+4      	; 0xa2a <path_node+0x3e>
     a26:	8d 30       	cpi	r24, 0x0D	; 13
     a28:	70 f0       	brcs	.+28     	; 0xa46 <path_node+0x5a>
		{
			
			count++;
     a2a:	df 5f       	subi	r29, 0xFF	; 255
			path_mm(90);
     a2c:	6a e5       	ldi	r22, 0x5A	; 90
     a2e:	70 e0       	ldi	r23, 0x00	; 0
     a30:	80 e0       	ldi	r24, 0x00	; 0
     a32:	90 e0       	ldi	r25, 0x00	; 0
     a34:	0e 94 4b 04 	call	0x896	; 0x896 <path_mm>
			forward();
     a38:	0e 94 cb 03 	call	0x796	; 0x796 <forward>
			velocity(255,255);			
     a3c:	8f ef       	ldi	r24, 0xFF	; 255
     a3e:	6f ef       	ldi	r22, 0xFF	; 255
     a40:	0e 94 76 03 	call	0x6ec	; 0x6ec <velocity>
     a44:	18 c0       	rjmp	.+48     	; 0xa76 <path_node+0x8a>
		}
		else
		{
			if(Center_white_line > 12 )
			{
				velocity(255,255);
     a46:	8f ef       	ldi	r24, 0xFF	; 255
     a48:	6f ef       	ldi	r22, 0xFF	; 255
     a4a:	0e 94 76 03 	call	0x6ec	; 0x6ec <velocity>
				forward();
     a4e:	0e 94 cb 03 	call	0x796	; 0x796 <forward>
     a52:	11 c0       	rjmp	.+34     	; 0xa76 <path_node+0x8a>
			}
			else if(Left_white_line > 12)
     a54:	1d 30       	cpi	r17, 0x0D	; 13
     a56:	38 f0       	brcs	.+14     	; 0xa66 <path_node+0x7a>
			{
				velocity(100,255);
     a58:	84 e6       	ldi	r24, 0x64	; 100
     a5a:	6f ef       	ldi	r22, 0xFF	; 255
     a5c:	0e 94 76 03 	call	0x6ec	; 0x6ec <velocity>
				forward();
     a60:	0e 94 cb 03 	call	0x796	; 0x796 <forward>
     a64:	08 c0       	rjmp	.+16     	; 0xa76 <path_node+0x8a>
			}
			else if(Right_white_line > 12)
     a66:	8d 30       	cpi	r24, 0x0D	; 13
     a68:	30 f0       	brcs	.+12     	; 0xa76 <path_node+0x8a>
			{
				velocity(255,100);
     a6a:	8f ef       	ldi	r24, 0xFF	; 255
     a6c:	64 e6       	ldi	r22, 0x64	; 100
     a6e:	0e 94 76 03 	call	0x6ec	; 0x6ec <velocity>
				forward();
     a72:	0e 94 cb 03 	call	0x796	; 0x796 <forward>
	unsigned char Left_white_line,Center_white_line,Right_white_line,count = 0;
	
	forward();
	velocity(255,255);

	while(count < n)
     a76:	8d 2f       	mov	r24, r29
     a78:	90 e0       	ldi	r25, 0x00	; 0
     a7a:	8e 15       	cp	r24, r14
     a7c:	9f 05       	cpc	r25, r15
     a7e:	24 f2       	brlt	.-120    	; 0xa08 <path_node+0x1c>
				forward();
			}
		}
	}
	
	stop();
     a80:	0e 94 db 03 	call	0x7b6	; 0x7b6 <stop>
     a84:	83 e3       	ldi	r24, 0x33	; 51
     a86:	93 e7       	ldi	r25, 0x73	; 115
     a88:	01 97       	sbiw	r24, 0x01	; 1
     a8a:	f1 f7       	brne	.-4      	; 0xa88 <path_node+0x9c>
	_delay_ms(8);
}
     a8c:	df 91       	pop	r29
     a8e:	cf 91       	pop	r28
     a90:	1f 91       	pop	r17
     a92:	ff 90       	pop	r15
     a94:	ef 90       	pop	r14
     a96:	08 95       	ret

00000a98 <path_node1>:

void path_node1 (int n)			//Line following cowering a specified number of nodes
{
     a98:	ef 92       	push	r14
     a9a:	ff 92       	push	r15
     a9c:	1f 93       	push	r17
     a9e:	cf 93       	push	r28
     aa0:	df 93       	push	r29
     aa2:	7c 01       	movw	r14, r24
	unsigned char Left_white_line,Center_white_line,Right_white_line,count = 0;
	
	forward();
     aa4:	0e 94 cb 03 	call	0x796	; 0x796 <forward>
	velocity(255,255);
     aa8:	8f ef       	ldi	r24, 0xFF	; 255
     aaa:	6f ef       	ldi	r22, 0xFF	; 255
     aac:	0e 94 76 03 	call	0x6ec	; 0x6ec <velocity>
	_delay_ms(8);
}

void path_node1 (int n)			//Line following cowering a specified number of nodes
{
	unsigned char Left_white_line,Center_white_line,Right_white_line,count = 0;
     ab0:	d0 e0       	ldi	r29, 0x00	; 0
	
	forward();
	velocity(255,255);

	while(count < n)
     ab2:	37 c0       	rjmp	.+110    	; 0xb22 <path_node1+0x8a>
	{
		Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
     ab4:	83 e0       	ldi	r24, 0x03	; 3
     ab6:	0e 94 81 02 	call	0x502	; 0x502 <ADC_Conversion>
     aba:	18 2f       	mov	r17, r24
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
     abc:	82 e0       	ldi	r24, 0x02	; 2
     abe:	0e 94 81 02 	call	0x502	; 0x502 <ADC_Conversion>
     ac2:	c8 2f       	mov	r28, r24
		Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor
     ac4:	81 e0       	ldi	r24, 0x01	; 1
     ac6:	0e 94 81 02 	call	0x502	; 0x502 <ADC_Conversion>
		
		if(((Center_white_line>12 && Left_white_line>12) ||(Center_white_line>12 && Right_white_line>12)))// Node Detection
     aca:	cd 30       	cpi	r28, 0x0D	; 13
     acc:	c8 f0       	brcs	.+50     	; 0xb00 <path_node1+0x68>
     ace:	1d 30       	cpi	r17, 0x0D	; 13
     ad0:	10 f4       	brcc	.+4      	; 0xad6 <path_node1+0x3e>
     ad2:	8d 30       	cpi	r24, 0x0D	; 13
     ad4:	70 f0       	brcs	.+28     	; 0xaf2 <path_node1+0x5a>
		{
			
			count++;
     ad6:	df 5f       	subi	r29, 0xFF	; 255
			path_mm(50);
     ad8:	62 e3       	ldi	r22, 0x32	; 50
     ada:	70 e0       	ldi	r23, 0x00	; 0
     adc:	80 e0       	ldi	r24, 0x00	; 0
     ade:	90 e0       	ldi	r25, 0x00	; 0
     ae0:	0e 94 4b 04 	call	0x896	; 0x896 <path_mm>
			forward();
     ae4:	0e 94 cb 03 	call	0x796	; 0x796 <forward>
			velocity(255,255);
     ae8:	8f ef       	ldi	r24, 0xFF	; 255
     aea:	6f ef       	ldi	r22, 0xFF	; 255
     aec:	0e 94 76 03 	call	0x6ec	; 0x6ec <velocity>
     af0:	18 c0       	rjmp	.+48     	; 0xb22 <path_node1+0x8a>
		}
		else
		{
			if(Center_white_line > 12 )
			{
				velocity(255,255);
     af2:	8f ef       	ldi	r24, 0xFF	; 255
     af4:	6f ef       	ldi	r22, 0xFF	; 255
     af6:	0e 94 76 03 	call	0x6ec	; 0x6ec <velocity>
				forward();
     afa:	0e 94 cb 03 	call	0x796	; 0x796 <forward>
     afe:	11 c0       	rjmp	.+34     	; 0xb22 <path_node1+0x8a>
			}
			else if(Left_white_line > 12)
     b00:	1d 30       	cpi	r17, 0x0D	; 13
     b02:	38 f0       	brcs	.+14     	; 0xb12 <path_node1+0x7a>
			{
				velocity(100,255);
     b04:	84 e6       	ldi	r24, 0x64	; 100
     b06:	6f ef       	ldi	r22, 0xFF	; 255
     b08:	0e 94 76 03 	call	0x6ec	; 0x6ec <velocity>
				forward();
     b0c:	0e 94 cb 03 	call	0x796	; 0x796 <forward>
     b10:	08 c0       	rjmp	.+16     	; 0xb22 <path_node1+0x8a>
			}
			else if(Right_white_line > 12)
     b12:	8d 30       	cpi	r24, 0x0D	; 13
     b14:	30 f0       	brcs	.+12     	; 0xb22 <path_node1+0x8a>
			{
				velocity(255,100);
     b16:	8f ef       	ldi	r24, 0xFF	; 255
     b18:	64 e6       	ldi	r22, 0x64	; 100
     b1a:	0e 94 76 03 	call	0x6ec	; 0x6ec <velocity>
				forward();
     b1e:	0e 94 cb 03 	call	0x796	; 0x796 <forward>
	unsigned char Left_white_line,Center_white_line,Right_white_line,count = 0;
	
	forward();
	velocity(255,255);

	while(count < n)
     b22:	8d 2f       	mov	r24, r29
     b24:	90 e0       	ldi	r25, 0x00	; 0
     b26:	8e 15       	cp	r24, r14
     b28:	9f 05       	cpc	r25, r15
     b2a:	24 f2       	brlt	.-120    	; 0xab4 <path_node1+0x1c>
				forward();
			}
		}
	}
	
	stop();
     b2c:	0e 94 db 03 	call	0x7b6	; 0x7b6 <stop>
     b30:	83 e3       	ldi	r24, 0x33	; 51
     b32:	93 e7       	ldi	r25, 0x73	; 115
     b34:	01 97       	sbiw	r24, 0x01	; 1
     b36:	f1 f7       	brne	.-4      	; 0xb34 <path_node1+0x9c>
	_delay_ms(8);
}
     b38:	df 91       	pop	r29
     b3a:	cf 91       	pop	r28
     b3c:	1f 91       	pop	r17
     b3e:	ff 90       	pop	r15
     b40:	ef 90       	pop	r14
     b42:	08 95       	ret

00000b44 <rotate_right>:

void rotate_right(int Deg)		// Rotate right with finding the black line
{
     b44:	cf 93       	push	r28
     b46:	df 93       	push	r29
     b48:	ec 01       	movw	r28, r24
	velocity(250,250);
     b4a:	8a ef       	ldi	r24, 0xFA	; 250
     b4c:	6a ef       	ldi	r22, 0xFA	; 250
     b4e:	0e 94 76 03 	call	0x6ec	; 0x6ec <velocity>
	right_degrees(Deg-20);
     b52:	ce 01       	movw	r24, r28
     b54:	44 97       	sbiw	r24, 0x14	; 20
     b56:	0e 94 3c 04 	call	0x878	; 0x878 <right_degrees>
	
	char i=3;
	while(ADC_Conversion(2)<12)// to detect balck line
     b5a:	04 c0       	rjmp	.+8      	; 0xb64 <rotate_right+0x20>
	{
		right_degrees(i); 
     b5c:	83 e0       	ldi	r24, 0x03	; 3
     b5e:	90 e0       	ldi	r25, 0x00	; 0
     b60:	0e 94 3c 04 	call	0x878	; 0x878 <right_degrees>
{
	velocity(250,250);
	right_degrees(Deg-20);
	
	char i=3;
	while(ADC_Conversion(2)<12)// to detect balck line
     b64:	82 e0       	ldi	r24, 0x02	; 2
     b66:	0e 94 81 02 	call	0x502	; 0x502 <ADC_Conversion>
     b6a:	8c 30       	cpi	r24, 0x0C	; 12
     b6c:	b8 f3       	brcs	.-18     	; 0xb5c <rotate_right+0x18>
	{
		right_degrees(i); 
	}
	stop();
     b6e:	0e 94 db 03 	call	0x7b6	; 0x7b6 <stop>
     b72:	83 e3       	ldi	r24, 0x33	; 51
     b74:	93 e7       	ldi	r25, 0x73	; 115
     b76:	01 97       	sbiw	r24, 0x01	; 1
     b78:	f1 f7       	brne	.-4      	; 0xb76 <rotate_right+0x32>
	_delay_ms(8);
}
     b7a:	df 91       	pop	r29
     b7c:	cf 91       	pop	r28
     b7e:	08 95       	ret

00000b80 <rotate_left>:

void rotate_left(int Deg)		// Rotate right with finding the black line
{
     b80:	cf 93       	push	r28
     b82:	df 93       	push	r29
     b84:	ec 01       	movw	r28, r24
	velocity(250,250);
     b86:	8a ef       	ldi	r24, 0xFA	; 250
     b88:	6a ef       	ldi	r22, 0xFA	; 250
     b8a:	0e 94 76 03 	call	0x6ec	; 0x6ec <velocity>
	left_degrees(Deg-20);	
     b8e:	ce 01       	movw	r24, r28
     b90:	44 97       	sbiw	r24, 0x14	; 20
     b92:	0e 94 2d 04 	call	0x85a	; 0x85a <left_degrees>
	
	char i=3;
	while(ADC_Conversion(2)<12)	// to detect balck line
     b96:	04 c0       	rjmp	.+8      	; 0xba0 <rotate_left+0x20>
	{
		left_degrees(i);
     b98:	83 e0       	ldi	r24, 0x03	; 3
     b9a:	90 e0       	ldi	r25, 0x00	; 0
     b9c:	0e 94 2d 04 	call	0x85a	; 0x85a <left_degrees>
{
	velocity(250,250);
	left_degrees(Deg-20);	
	
	char i=3;
	while(ADC_Conversion(2)<12)	// to detect balck line
     ba0:	82 e0       	ldi	r24, 0x02	; 2
     ba2:	0e 94 81 02 	call	0x502	; 0x502 <ADC_Conversion>
     ba6:	8c 30       	cpi	r24, 0x0C	; 12
     ba8:	b8 f3       	brcs	.-18     	; 0xb98 <rotate_left+0x18>
	{
		left_degrees(i);
	}
	stop();
     baa:	0e 94 db 03 	call	0x7b6	; 0x7b6 <stop>
     bae:	83 e3       	ldi	r24, 0x33	; 51
     bb0:	93 e7       	ldi	r25, 0x73	; 115
     bb2:	01 97       	sbiw	r24, 0x01	; 1
     bb4:	f1 f7       	brne	.-4      	; 0xbb2 <rotate_left+0x32>
	_delay_ms(8);
}
     bb6:	df 91       	pop	r29
     bb8:	cf 91       	pop	r28
     bba:	08 95       	ret

00000bbc <buzzer_pin_config>:
#ifndef BUZZER_H
#define BUZZER_H

void buzzer_pin_config (void)
{
 DDRC = DDRC | 0x08;		//Setting PORTC 3 as output
     bbc:	3b 9a       	sbi	0x07, 3	; 7
 PORTC = PORTC & 0xF7;		//Setting PORTC 3 logic low to turnoff buzzer
     bbe:	43 98       	cbi	0x08, 3	; 8
}
     bc0:	08 95       	ret

00000bc2 <buzzer_on>:

void buzzer_on (void)
{
 unsigned char port_restore = 0;
 port_restore = PINC;
     bc2:	86 b1       	in	r24, 0x06	; 6
 port_restore = port_restore | 0x08;
     bc4:	88 60       	ori	r24, 0x08	; 8
 PORTC = port_restore;
     bc6:	88 b9       	out	0x08, r24	; 8
}
     bc8:	08 95       	ret

00000bca <buzzer_off>:

void buzzer_off (void)
{
 unsigned char port_restore = 0;
 port_restore = PINC;
     bca:	86 b1       	in	r24, 0x06	; 6
 port_restore = port_restore & 0xF7;
     bcc:	87 7f       	andi	r24, 0xF7	; 247
 PORTC = port_restore;
     bce:	88 b9       	out	0x08, r24	; 8
}
     bd0:	08 95       	ret

00000bd2 <buzzer>:

void buzzer(int sec)	// To turn on buzzer for specified number of seconds
{
     bd2:	cf 93       	push	r28
     bd4:	df 93       	push	r29
     bd6:	ec 01       	movw	r28, r24
	buzzer_on();
     bd8:	0e 94 e1 05 	call	0xbc2	; 0xbc2 <buzzer_on>
	for(int i=0;i<sec;i++)
     bdc:	1c 16       	cp	r1, r28
     bde:	1d 06       	cpc	r1, r29
     be0:	7c f4       	brge	.+30     	; 0xc00 <buzzer+0x2e>
     be2:	80 e0       	ldi	r24, 0x00	; 0
     be4:	90 e0       	ldi	r25, 0x00	; 0
     be6:	2f ef       	ldi	r18, 0xFF	; 255
     be8:	3f ef       	ldi	r19, 0xFF	; 255
     bea:	4c e2       	ldi	r20, 0x2C	; 44
     bec:	21 50       	subi	r18, 0x01	; 1
     bee:	30 40       	sbci	r19, 0x00	; 0
     bf0:	40 40       	sbci	r20, 0x00	; 0
     bf2:	e1 f7       	brne	.-8      	; 0xbec <buzzer+0x1a>
     bf4:	00 c0       	rjmp	.+0      	; 0xbf6 <buzzer+0x24>
     bf6:	00 00       	nop
     bf8:	01 96       	adiw	r24, 0x01	; 1
     bfa:	8c 17       	cp	r24, r28
     bfc:	9d 07       	cpc	r25, r29
     bfe:	99 f7       	brne	.-26     	; 0xbe6 <buzzer+0x14>
		_delay_ms(1000);
	buzzer_off();
     c00:	0e 94 e5 05 	call	0xbca	; 0xbca <buzzer_off>
}
     c04:	df 91       	pop	r29
     c06:	cf 91       	pop	r28
     c08:	08 95       	ret

00000c0a <servo1_pin_config>:
int c_degrees=0;
//int first_aid_kit_cnt;
//Configure PORTB 5 pin for servo motor 1 operation
void servo1_pin_config (void)
{
	DDRB  = DDRB | 0x20;  //making PORTB 5 pin output
     c0a:	25 9a       	sbi	0x04, 5	; 4
	PORTB = PORTB | 0x20; //setting PORTB 5 pin to logic 1
     c0c:	2d 9a       	sbi	0x05, 5	; 5
}
     c0e:	08 95       	ret

00000c10 <servo2_pin_config>:

//Configure PORTB 6 pin for servo motor 2 operation
void servo2_pin_config (void)
{
	DDRB  = DDRB | 0x40;  //making PORTB 6 pin output
     c10:	26 9a       	sbi	0x04, 6	; 4
	PORTB = PORTB | 0x40; //setting PORTB 6 pin to logic 1
     c12:	2e 9a       	sbi	0x05, 6	; 5
}
     c14:	08 95       	ret

00000c16 <servo3_pin_config>:

//Configure PORTB 7 pin for servo motor 3 operation
void servo3_pin_config (void)
{
	DDRB  = DDRB | 0x80;  //making PORTB 7 pin output
     c16:	27 9a       	sbi	0x04, 7	; 4
	PORTB = PORTB | 0x80; //setting PORTB 7 pin to logic 1
     c18:	2f 9a       	sbi	0x05, 7	; 5
}
     c1a:	08 95       	ret

00000c1c <servo_init>:


//Initialize the ports
void servo_init(void)
{
	servo1_pin_config(); //Configure PORTB 5 pin for servo motor 1 operation
     c1c:	0e 94 05 06 	call	0xc0a	; 0xc0a <servo1_pin_config>
	servo2_pin_config(); //Configure PORTB 6 pin for servo motor 2 operation
     c20:	0e 94 08 06 	call	0xc10	; 0xc10 <servo2_pin_config>
	servo3_pin_config(); //Configure PORTB 7 pin for servo motor 3 operation
     c24:	0e 94 0b 06 	call	0xc16	; 0xc16 <servo3_pin_config>
	timer1_init();
     c28:	0e 94 d6 00 	call	0x1ac	; 0x1ac <timer1_init>
}
     c2c:	08 95       	ret

00000c2e <servo_1>:
//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)
{
	float PositionPanServo = 0;
	PositionPanServo = ((float)degrees / 1.86) + 35.0;
	OCR1AH = 0x00;
     c2e:	10 92 89 00 	sts	0x0089, r1

//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)
{
	float PositionPanServo = 0;
	PositionPanServo = ((float)degrees / 1.86) + 35.0;
     c32:	68 2f       	mov	r22, r24
     c34:	70 e0       	ldi	r23, 0x00	; 0
     c36:	80 e0       	ldi	r24, 0x00	; 0
     c38:	90 e0       	ldi	r25, 0x00	; 0
     c3a:	0e 94 b5 19 	call	0x336a	; 0x336a <__floatunsisf>
     c3e:	2b e7       	ldi	r18, 0x7B	; 123
     c40:	34 e1       	ldi	r19, 0x14	; 20
     c42:	4e ee       	ldi	r20, 0xEE	; 238
     c44:	5f e3       	ldi	r21, 0x3F	; 63
     c46:	0e 94 1c 19 	call	0x3238	; 0x3238 <__divsf3>
     c4a:	20 e0       	ldi	r18, 0x00	; 0
     c4c:	30 e0       	ldi	r19, 0x00	; 0
     c4e:	4c e0       	ldi	r20, 0x0C	; 12
     c50:	52 e4       	ldi	r21, 0x42	; 66
     c52:	0e 94 b4 18 	call	0x3168	; 0x3168 <__addsf3>
	OCR1AH = 0x00;
	OCR1AL = (unsigned char) PositionPanServo;
     c56:	0e 94 89 19 	call	0x3312	; 0x3312 <__fixunssfsi>
     c5a:	60 93 88 00 	sts	0x0088, r22
}
     c5e:	08 95       	ret

00000c60 <servo_2>:
//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
	OCR1BH = 0x00;
     c60:	10 92 8b 00 	sts	0x008B, r1

//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
     c64:	68 2f       	mov	r22, r24
     c66:	70 e0       	ldi	r23, 0x00	; 0
     c68:	80 e0       	ldi	r24, 0x00	; 0
     c6a:	90 e0       	ldi	r25, 0x00	; 0
     c6c:	0e 94 b5 19 	call	0x336a	; 0x336a <__floatunsisf>
     c70:	2b e7       	ldi	r18, 0x7B	; 123
     c72:	34 e1       	ldi	r19, 0x14	; 20
     c74:	4e ee       	ldi	r20, 0xEE	; 238
     c76:	5f e3       	ldi	r21, 0x3F	; 63
     c78:	0e 94 1c 19 	call	0x3238	; 0x3238 <__divsf3>
     c7c:	20 e0       	ldi	r18, 0x00	; 0
     c7e:	30 e0       	ldi	r19, 0x00	; 0
     c80:	4c e0       	ldi	r20, 0x0C	; 12
     c82:	52 e4       	ldi	r21, 0x42	; 66
     c84:	0e 94 b4 18 	call	0x3168	; 0x3168 <__addsf3>
	OCR1BH = 0x00;
	OCR1BL = (unsigned char) PositionTiltServo;
     c88:	0e 94 89 19 	call	0x3312	; 0x3312 <__fixunssfsi>
     c8c:	60 93 8a 00 	sts	0x008A, r22
}
     c90:	08 95       	ret

00000c92 <servo_3>:
//Function to rotate Servo 3 by a specified angle in the multiples of 1.86 degrees
void servo_3(unsigned char degrees)
{
	float PositionServo = 0;
	PositionServo = ((float)degrees / 1.86) + 35.0;
	OCR1CH = 0x00;
     c92:	10 92 8d 00 	sts	0x008D, r1

//Function to rotate Servo 3 by a specified angle in the multiples of 1.86 degrees
void servo_3(unsigned char degrees)
{
	float PositionServo = 0;
	PositionServo = ((float)degrees / 1.86) + 35.0;
     c96:	68 2f       	mov	r22, r24
     c98:	70 e0       	ldi	r23, 0x00	; 0
     c9a:	80 e0       	ldi	r24, 0x00	; 0
     c9c:	90 e0       	ldi	r25, 0x00	; 0
     c9e:	0e 94 b5 19 	call	0x336a	; 0x336a <__floatunsisf>
     ca2:	2b e7       	ldi	r18, 0x7B	; 123
     ca4:	34 e1       	ldi	r19, 0x14	; 20
     ca6:	4e ee       	ldi	r20, 0xEE	; 238
     ca8:	5f e3       	ldi	r21, 0x3F	; 63
     caa:	0e 94 1c 19 	call	0x3238	; 0x3238 <__divsf3>
     cae:	20 e0       	ldi	r18, 0x00	; 0
     cb0:	30 e0       	ldi	r19, 0x00	; 0
     cb2:	4c e0       	ldi	r20, 0x0C	; 12
     cb4:	52 e4       	ldi	r21, 0x42	; 66
     cb6:	0e 94 b4 18 	call	0x3168	; 0x3168 <__addsf3>
	OCR1CH = 0x00;
	OCR1CL = (unsigned char) PositionServo;
     cba:	0e 94 89 19 	call	0x3312	; 0x3312 <__fixunssfsi>
     cbe:	60 93 8c 00 	sts	0x008C, r22
}
     cc2:	08 95       	ret

00000cc4 <servo_1_free>:
//and make them free by giving 100% duty cycle at the PWM. This function can be used to
//reduce the power consumption of the motor if it is holding load against the gravity.

void servo_1_free (void) //makes servo 1 free rotating
{
	OCR1AH = 0x03;
     cc4:	83 e0       	ldi	r24, 0x03	; 3
     cc6:	80 93 89 00 	sts	0x0089, r24
	OCR1AL = 0xFF; //Servo 1 off
     cca:	8f ef       	ldi	r24, 0xFF	; 255
     ccc:	80 93 88 00 	sts	0x0088, r24
}
     cd0:	08 95       	ret

00000cd2 <servo_2_free>:

void servo_2_free (void) //makes servo 2 free rotating
{
	OCR1BH = 0x03;
     cd2:	83 e0       	ldi	r24, 0x03	; 3
     cd4:	80 93 8b 00 	sts	0x008B, r24
	OCR1BL = 0xFF; //Servo 2 off
     cd8:	8f ef       	ldi	r24, 0xFF	; 255
     cda:	80 93 8a 00 	sts	0x008A, r24
}
     cde:	08 95       	ret

00000ce0 <servo_3_free>:

void servo_3_free (void) //makes servo 3 free rotating
{
	OCR1CH = 0x03;
     ce0:	83 e0       	ldi	r24, 0x03	; 3
     ce2:	80 93 8d 00 	sts	0x008D, r24
	OCR1CL = 0xFF; //Servo 3 off
     ce6:	8f ef       	ldi	r24, 0xFF	; 255
     ce8:	80 93 8c 00 	sts	0x008C, r24
}
     cec:	08 95       	ret

00000cee <servo>:

void servo(int degrees)
{
     cee:	0f 93       	push	r16
     cf0:	1f 93       	push	r17
     cf2:	cf 93       	push	r28
     cf4:	df 93       	push	r29
     cf6:	8c 01       	movw	r16, r24
	int i;
	if(degrees > c_degrees)
     cf8:	c0 91 c0 0c 	lds	r28, 0x0CC0
     cfc:	d0 91 c1 0c 	lds	r29, 0x0CC1
     d00:	c8 17       	cp	r28, r24
     d02:	d9 07       	cpc	r29, r25
     d04:	24 f0       	brlt	.+8      	; 0xd0e <servo+0x20>
			servo_1(i);
			_delay_ms(20);
			c_degrees=i;
		}
	else
		for (i = c_degrees; i > degrees; i--)
     d06:	8c 17       	cp	r24, r28
     d08:	9d 07       	cpc	r25, r29
     d0a:	a4 f0       	brlt	.+40     	; 0xd34 <servo+0x46>
     d0c:	24 c0       	rjmp	.+72     	; 0xd56 <servo+0x68>
{
	int i;
	if(degrees > c_degrees)
		for (i = c_degrees; i <degrees; i++)
		{
			servo_1(i);
     d0e:	8c 2f       	mov	r24, r28
     d10:	0e 94 17 06 	call	0xc2e	; 0xc2e <servo_1>
     d14:	86 e6       	ldi	r24, 0x66	; 102
     d16:	96 ee       	ldi	r25, 0xE6	; 230
     d18:	a0 e0       	ldi	r26, 0x00	; 0
     d1a:	81 50       	subi	r24, 0x01	; 1
     d1c:	90 40       	sbci	r25, 0x00	; 0
     d1e:	a0 40       	sbci	r26, 0x00	; 0
     d20:	e1 f7       	brne	.-8      	; 0xd1a <servo+0x2c>
			_delay_ms(20);
			c_degrees=i;
     d22:	d0 93 c1 0c 	sts	0x0CC1, r29
     d26:	c0 93 c0 0c 	sts	0x0CC0, r28

void servo(int degrees)
{
	int i;
	if(degrees > c_degrees)
		for (i = c_degrees; i <degrees; i++)
     d2a:	21 96       	adiw	r28, 0x01	; 1
     d2c:	c0 17       	cp	r28, r16
     d2e:	d1 07       	cpc	r29, r17
     d30:	74 f3       	brlt	.-36     	; 0xd0e <servo+0x20>
     d32:	11 c0       	rjmp	.+34     	; 0xd56 <servo+0x68>
			c_degrees=i;
		}
	else
		for (i = c_degrees; i > degrees; i--)
		{
			servo_1(i);
     d34:	8c 2f       	mov	r24, r28
     d36:	0e 94 17 06 	call	0xc2e	; 0xc2e <servo_1>
     d3a:	af ef       	ldi	r26, 0xFF	; 255
     d3c:	bf e8       	ldi	r27, 0x8F	; 143
     d3e:	11 97       	sbiw	r26, 0x01	; 1
     d40:	f1 f7       	brne	.-4      	; 0xd3e <servo+0x50>
     d42:	00 c0       	rjmp	.+0      	; 0xd44 <servo+0x56>
     d44:	00 00       	nop
			_delay_ms(10);
			c_degrees=i;
     d46:	d0 93 c1 0c 	sts	0x0CC1, r29
     d4a:	c0 93 c0 0c 	sts	0x0CC0, r28
			servo_1(i);
			_delay_ms(20);
			c_degrees=i;
		}
	else
		for (i = c_degrees; i > degrees; i--)
     d4e:	21 97       	sbiw	r28, 0x01	; 1
     d50:	0c 17       	cp	r16, r28
     d52:	1d 07       	cpc	r17, r29
     d54:	7c f3       	brlt	.-34     	; 0xd34 <servo+0x46>
		{
			servo_1(i);
			_delay_ms(10);
			c_degrees=i;
		}
}
     d56:	df 91       	pop	r29
     d58:	cf 91       	pop	r28
     d5a:	1f 91       	pop	r17
     d5c:	0f 91       	pop	r16
     d5e:	08 95       	ret

00000d60 <color_sensor_pin_config>:
volatile unsigned long int no_ff;     // variable to store the pulse count when no_filter function is called


void color_sensor_pin_config(void)
{
	DDRD  = DDRD | 0xFB; //set PD0 as input for color sensor output
     d60:	8a b1       	in	r24, 0x0a	; 10
     d62:	8b 6f       	ori	r24, 0xFB	; 251
     d64:	8a b9       	out	0x0a, r24	; 10
	PORTD = PORTD | 0x04;//Enable internal pull-up for PORTD 0 pin
     d66:	5a 9a       	sbi	0x0b, 2	; 11
}
     d68:	08 95       	ret

00000d6a <rgb_led_pin_config>:

void rgb_led_pin_config(void)
{
	DDRJ  = DDRJ | 0xFF;
     d6a:	e4 e0       	ldi	r30, 0x04	; 4
     d6c:	f1 e0       	ldi	r31, 0x01	; 1
     d6e:	80 81       	ld	r24, Z
     d70:	8f ef       	ldi	r24, 0xFF	; 255
     d72:	80 83       	st	Z, r24
	PORTJ = PORTJ | 0x00;
     d74:	e5 e0       	ldi	r30, 0x05	; 5
     d76:	f1 e0       	ldi	r31, 0x01	; 1
     d78:	80 81       	ld	r24, Z
     d7a:	80 83       	st	Z, r24
}
     d7c:	08 95       	ret

00000d7e <color_sensor_pin_interrupt_init>:

void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
{
	cli(); //Clears the global interrupt
     d7e:	f8 94       	cli
	EICRA = EICRA | 0x20; // INT2 is set to trigger with falling edge
     d80:	e9 e6       	ldi	r30, 0x69	; 105
     d82:	f0 e0       	ldi	r31, 0x00	; 0
     d84:	80 81       	ld	r24, Z
     d86:	80 62       	ori	r24, 0x20	; 32
     d88:	80 83       	st	Z, r24
	//EIMSK = EIMSK | 0x04; // Enable Interrupt INT2 for color sensor
	sei(); // Enables the global interrupt
     d8a:	78 94       	sei
}
     d8c:	08 95       	ret

00000d8e <__vector_3>:

//ISR for color sensor
ISR(INT2_vect)
{
     d8e:	1f 92       	push	r1
     d90:	0f 92       	push	r0
     d92:	0f b6       	in	r0, 0x3f	; 63
     d94:	0f 92       	push	r0
     d96:	11 24       	eor	r1, r1
     d98:	8f 93       	push	r24
     d9a:	9f 93       	push	r25
     d9c:	af 93       	push	r26
     d9e:	bf 93       	push	r27
	pulse++; //increment on receiving pulse from the color sensor
     da0:	80 91 bc 0c 	lds	r24, 0x0CBC
     da4:	90 91 bd 0c 	lds	r25, 0x0CBD
     da8:	a0 91 be 0c 	lds	r26, 0x0CBE
     dac:	b0 91 bf 0c 	lds	r27, 0x0CBF
     db0:	01 96       	adiw	r24, 0x01	; 1
     db2:	a1 1d       	adc	r26, r1
     db4:	b1 1d       	adc	r27, r1
     db6:	80 93 bc 0c 	sts	0x0CBC, r24
     dba:	90 93 bd 0c 	sts	0x0CBD, r25
     dbe:	a0 93 be 0c 	sts	0x0CBE, r26
     dc2:	b0 93 bf 0c 	sts	0x0CBF, r27
}
     dc6:	bf 91       	pop	r27
     dc8:	af 91       	pop	r26
     dca:	9f 91       	pop	r25
     dcc:	8f 91       	pop	r24
     dce:	0f 90       	pop	r0
     dd0:	0f be       	out	0x3f, r0	; 63
     dd2:	0f 90       	pop	r0
     dd4:	1f 90       	pop	r1
     dd6:	18 95       	reti

00000dd8 <colour_init>:

void colour_init(void)
{
	color_sensor_pin_config();
     dd8:	0e 94 b0 06 	call	0xd60	; 0xd60 <color_sensor_pin_config>
	color_sensor_pin_interrupt_init();
     ddc:	0e 94 bf 06 	call	0xd7e	; 0xd7e <color_sensor_pin_interrupt_init>
	color_sensor_scaling();
     de0:	0e 94 f9 00 	call	0x1f2	; 0x1f2 <color_sensor_scaling>
	rgb_led_pin_config();
     de4:	0e 94 b5 06 	call	0xd6a	; 0xd6a <rgb_led_pin_config>
}
     de8:	08 95       	ret

00000dea <filter_red>:

//Filter Selection
void filter_red(void)    //Used to select red filter
{
	//Filter Select - red filter
	PORTD = PORTD & 0xBF; //set S2 low
     dea:	5e 98       	cbi	0x0b, 6	; 11
	PORTD = PORTD & 0x7F; //set S3 low
     dec:	5f 98       	cbi	0x0b, 7	; 11
}
     dee:	08 95       	ret

00000df0 <filter_green>:

void filter_green(void)	//Used to select green filter
{
	//Filter Select - green filter
	PORTD = PORTD | 0x40; //set S2 High
     df0:	5e 9a       	sbi	0x0b, 6	; 11
	PORTD = PORTD | 0x80; //set S3 High
     df2:	5f 9a       	sbi	0x0b, 7	; 11
}
     df4:	08 95       	ret

00000df6 <filter_blue>:

void filter_blue(void)	//Used to select blue filter
{
	//Filter Select - blue filter
	PORTD = PORTD & 0xBF; //set S2 low
     df6:	5e 98       	cbi	0x0b, 6	; 11
	PORTD = PORTD | 0x80; //set S3 High
     df8:	5f 9a       	sbi	0x0b, 7	; 11
}
     dfa:	08 95       	ret

00000dfc <filter_clear>:

void filter_clear(void)	//select no filter
{
	//Filter Select - no filter
	PORTD = PORTD | 0x40; //set S2 High
     dfc:	5e 9a       	sbi	0x0b, 6	; 11
	PORTD = PORTD & 0x7F; //set S3 Low
     dfe:	5f 98       	cbi	0x0b, 7	; 11
}
     e00:	08 95       	ret

00000e02 <red_read>:
}

void red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
	//Red
	filter_red(); //select red filter
     e02:	0e 94 f5 06 	call	0xdea	; 0xdea <filter_red>
	pulse=0; //reset the count to 0
     e06:	10 92 bc 0c 	sts	0x0CBC, r1
     e0a:	10 92 bd 0c 	sts	0x0CBD, r1
     e0e:	10 92 be 0c 	sts	0x0CBE, r1
     e12:	10 92 bf 0c 	sts	0x0CBF, r1
     e16:	8f ef       	ldi	r24, 0xFF	; 255
     e18:	9f e8       	ldi	r25, 0x8F	; 143
     e1a:	01 97       	sbiw	r24, 0x01	; 1
     e1c:	f1 f7       	brne	.-4      	; 0xe1a <red_read+0x18>
     e1e:	00 c0       	rjmp	.+0      	; 0xe20 <red_read+0x1e>
     e20:	00 00       	nop
	_delay_ms(10); //capture the pulses for 100 ms or 0.1 second
	red = pulse;  //store the count in variable called red
     e22:	80 91 bc 0c 	lds	r24, 0x0CBC
     e26:	90 91 bd 0c 	lds	r25, 0x0CBD
     e2a:	a0 91 be 0c 	lds	r26, 0x0CBE
     e2e:	b0 91 bf 0c 	lds	r27, 0x0CBF
     e32:	80 93 82 16 	sts	0x1682, r24
     e36:	90 93 83 16 	sts	0x1683, r25
     e3a:	a0 93 84 16 	sts	0x1684, r26
     e3e:	b0 93 85 16 	sts	0x1685, r27
	
}
     e42:	08 95       	ret

00000e44 <green_read>:

void green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
	//Green
	filter_green(); //select green filter
     e44:	0e 94 f8 06 	call	0xdf0	; 0xdf0 <filter_green>
	pulse=0; //reset the count to 0
     e48:	10 92 bc 0c 	sts	0x0CBC, r1
     e4c:	10 92 bd 0c 	sts	0x0CBD, r1
     e50:	10 92 be 0c 	sts	0x0CBE, r1
     e54:	10 92 bf 0c 	sts	0x0CBF, r1
     e58:	8f ef       	ldi	r24, 0xFF	; 255
     e5a:	9f e8       	ldi	r25, 0x8F	; 143
     e5c:	01 97       	sbiw	r24, 0x01	; 1
     e5e:	f1 f7       	brne	.-4      	; 0xe5c <green_read+0x18>
     e60:	00 c0       	rjmp	.+0      	; 0xe62 <green_read+0x1e>
     e62:	00 00       	nop
	_delay_ms(10); //capture the pulses for 100 ms or 0.1 second
	green = pulse;  //store the count in variable called green
     e64:	80 91 bc 0c 	lds	r24, 0x0CBC
     e68:	90 91 bd 0c 	lds	r25, 0x0CBD
     e6c:	a0 91 be 0c 	lds	r26, 0x0CBE
     e70:	b0 91 bf 0c 	lds	r27, 0x0CBF
     e74:	80 93 7e 16 	sts	0x167E, r24
     e78:	90 93 7f 16 	sts	0x167F, r25
     e7c:	a0 93 80 16 	sts	0x1680, r26
     e80:	b0 93 81 16 	sts	0x1681, r27
	
}
     e84:	08 95       	ret

00000e86 <blue_read>:

void blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
{
	//Blue
	filter_blue(); //select blue filter
     e86:	0e 94 fb 06 	call	0xdf6	; 0xdf6 <filter_blue>
	pulse=0; //reset the count to 0
     e8a:	10 92 bc 0c 	sts	0x0CBC, r1
     e8e:	10 92 bd 0c 	sts	0x0CBD, r1
     e92:	10 92 be 0c 	sts	0x0CBE, r1
     e96:	10 92 bf 0c 	sts	0x0CBF, r1
     e9a:	8f ef       	ldi	r24, 0xFF	; 255
     e9c:	9f e8       	ldi	r25, 0x8F	; 143
     e9e:	01 97       	sbiw	r24, 0x01	; 1
     ea0:	f1 f7       	brne	.-4      	; 0xe9e <blue_read+0x18>
     ea2:	00 c0       	rjmp	.+0      	; 0xea4 <blue_read+0x1e>
     ea4:	00 00       	nop
	_delay_ms(10); //capture the pulses for 100 ms or 0.1 second
	blue = pulse;  //store the count in variable called blue
     ea6:	80 91 bc 0c 	lds	r24, 0x0CBC
     eaa:	90 91 bd 0c 	lds	r25, 0x0CBD
     eae:	a0 91 be 0c 	lds	r26, 0x0CBE
     eb2:	b0 91 bf 0c 	lds	r27, 0x0CBF
     eb6:	80 93 26 11 	sts	0x1126, r24
     eba:	90 93 27 11 	sts	0x1127, r25
     ebe:	a0 93 28 11 	sts	0x1128, r26
     ec2:	b0 93 29 11 	sts	0x1129, r27
	
}
     ec6:	08 95       	ret

00000ec8 <no_filter>:

void no_filter()
{
	filter_clear(); //select clear filter
     ec8:	0e 94 fe 06 	call	0xdfc	; 0xdfc <filter_clear>
	pulse=0; //reset the count to 0
     ecc:	10 92 bc 0c 	sts	0x0CBC, r1
     ed0:	10 92 bd 0c 	sts	0x0CBD, r1
     ed4:	10 92 be 0c 	sts	0x0CBE, r1
     ed8:	10 92 bf 0c 	sts	0x0CBF, r1
     edc:	8f ef       	ldi	r24, 0xFF	; 255
     ede:	9f e7       	ldi	r25, 0x7F	; 127
     ee0:	a4 e0       	ldi	r26, 0x04	; 4
     ee2:	81 50       	subi	r24, 0x01	; 1
     ee4:	90 40       	sbci	r25, 0x00	; 0
     ee6:	a0 40       	sbci	r26, 0x00	; 0
     ee8:	e1 f7       	brne	.-8      	; 0xee2 <no_filter+0x1a>
     eea:	00 c0       	rjmp	.+0      	; 0xeec <no_filter+0x24>
     eec:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	no_ff = (pulse);  //store the count in variable called blue
     eee:	80 91 bc 0c 	lds	r24, 0x0CBC
     ef2:	90 91 bd 0c 	lds	r25, 0x0CBD
     ef6:	a0 91 be 0c 	lds	r26, 0x0CBE
     efa:	b0 91 bf 0c 	lds	r27, 0x0CBF
     efe:	80 93 2a 11 	sts	0x112A, r24
     f02:	90 93 2b 11 	sts	0x112B, r25
     f06:	a0 93 2c 11 	sts	0x112C, r26
     f0a:	b0 93 2d 11 	sts	0x112D, r27

}
     f0e:	08 95       	ret

00000f10 <get_colour>:

int get_colour(void)
{
     f10:	0f 93       	push	r16
     f12:	1f 93       	push	r17
	EIMSK = EIMSK | 0x04;
     f14:	ea 9a       	sbi	0x1d, 2	; 29

    red_read(); //display the pulse count when red filter is selected
     f16:	0e 94 01 07 	call	0xe02	; 0xe02 <red_read>
     f1a:	0f ef       	ldi	r16, 0xFF	; 255
     f1c:	1f e3       	ldi	r17, 0x3F	; 63
     f1e:	22 e0       	ldi	r18, 0x02	; 2
     f20:	01 50       	subi	r16, 0x01	; 1
     f22:	10 40       	sbci	r17, 0x00	; 0
     f24:	20 40       	sbci	r18, 0x00	; 0
     f26:	e1 f7       	brne	.-8      	; 0xf20 <get_colour+0x10>
     f28:	00 c0       	rjmp	.+0      	; 0xf2a <get_colour+0x1a>
     f2a:	00 00       	nop
	_delay_ms(50);
	//lcd_print(1,4,red,4);
	green_read(); //display the pulse count when green filter is selected
     f2c:	0e 94 22 07 	call	0xe44	; 0xe44 <green_read>
     f30:	8f ef       	ldi	r24, 0xFF	; 255
     f32:	9f e3       	ldi	r25, 0x3F	; 63
     f34:	a2 e0       	ldi	r26, 0x02	; 2
     f36:	81 50       	subi	r24, 0x01	; 1
     f38:	90 40       	sbci	r25, 0x00	; 0
     f3a:	a0 40       	sbci	r26, 0x00	; 0
     f3c:	e1 f7       	brne	.-8      	; 0xf36 <get_colour+0x26>
     f3e:	00 c0       	rjmp	.+0      	; 0xf40 <get_colour+0x30>
     f40:	00 00       	nop
	_delay_ms(50);
	//lcd_print(1,9,green,4);
	blue_read(); //display the pulse count when blue filter is selected
     f42:	0e 94 43 07 	call	0xe86	; 0xe86 <blue_read>
     f46:	0f ef       	ldi	r16, 0xFF	; 255
     f48:	1f e3       	ldi	r17, 0x3F	; 63
     f4a:	22 e0       	ldi	r18, 0x02	; 2
     f4c:	01 50       	subi	r16, 0x01	; 1
     f4e:	10 40       	sbci	r17, 0x00	; 0
     f50:	20 40       	sbci	r18, 0x00	; 0
     f52:	e1 f7       	brne	.-8      	; 0xf4c <get_colour+0x3c>
     f54:	00 c0       	rjmp	.+0      	; 0xf56 <get_colour+0x46>
     f56:	00 00       	nop
	_delay_ms(50); 
	//lcd_print(2,1,blue,4);
	no_filter();//display the pulse count when no filter is selected
     f58:	0e 94 64 07 	call	0xec8	; 0xec8 <no_filter>
     f5c:	8f ef       	ldi	r24, 0xFF	; 255
     f5e:	9f e3       	ldi	r25, 0x3F	; 63
     f60:	a2 e0       	ldi	r26, 0x02	; 2
     f62:	81 50       	subi	r24, 0x01	; 1
     f64:	90 40       	sbci	r25, 0x00	; 0
     f66:	a0 40       	sbci	r26, 0x00	; 0
     f68:	e1 f7       	brne	.-8      	; 0xf62 <get_colour+0x52>
     f6a:	00 c0       	rjmp	.+0      	; 0xf6c <get_colour+0x5c>
     f6c:	00 00       	nop
	_delay_ms(50);
	//lcd_print(2,6,red,4);
	EIMSK = EIMSK & 0xFB;
     f6e:	ea 98       	cbi	0x1d, 2	; 29
	int a=(red+blue+green)/3;
     f70:	40 91 82 16 	lds	r20, 0x1682
     f74:	50 91 83 16 	lds	r21, 0x1683
     f78:	60 91 84 16 	lds	r22, 0x1684
     f7c:	70 91 85 16 	lds	r23, 0x1685
     f80:	00 91 26 11 	lds	r16, 0x1126
     f84:	10 91 27 11 	lds	r17, 0x1127
     f88:	20 91 28 11 	lds	r18, 0x1128
     f8c:	30 91 29 11 	lds	r19, 0x1129
     f90:	80 91 7e 16 	lds	r24, 0x167E
     f94:	90 91 7f 16 	lds	r25, 0x167F
     f98:	a0 91 80 16 	lds	r26, 0x1680
     f9c:	b0 91 81 16 	lds	r27, 0x1681
     fa0:	40 0f       	add	r20, r16
     fa2:	51 1f       	adc	r21, r17
     fa4:	62 1f       	adc	r22, r18
     fa6:	73 1f       	adc	r23, r19
     fa8:	8a 01       	movw	r16, r20
     faa:	9b 01       	movw	r18, r22
     fac:	08 0f       	add	r16, r24
     fae:	19 1f       	adc	r17, r25
     fb0:	2a 1f       	adc	r18, r26
     fb2:	3b 1f       	adc	r19, r27
     fb4:	c9 01       	movw	r24, r18
     fb6:	b8 01       	movw	r22, r16
     fb8:	23 e0       	ldi	r18, 0x03	; 3
     fba:	30 e0       	ldi	r19, 0x00	; 0
     fbc:	40 e0       	ldi	r20, 0x00	; 0
     fbe:	50 e0       	ldi	r21, 0x00	; 0
     fc0:	0e 94 56 1c 	call	0x38ac	; 0x38ac <__udivmodsi4>
	   
	if(a<250)
     fc4:	2a 3f       	cpi	r18, 0xFA	; 250
     fc6:	31 05       	cpc	r19, r1
     fc8:	0c f4       	brge	.+2      	; 0xfcc <get_colour+0xbc>
     fca:	57 c0       	rjmp	.+174    	; 0x107a <get_colour+0x16a>
		return 3;
	else
	{
		if(red > blue && red > green)
     fcc:	40 91 82 16 	lds	r20, 0x1682
     fd0:	50 91 83 16 	lds	r21, 0x1683
     fd4:	60 91 84 16 	lds	r22, 0x1684
     fd8:	70 91 85 16 	lds	r23, 0x1685
     fdc:	80 91 26 11 	lds	r24, 0x1126
     fe0:	90 91 27 11 	lds	r25, 0x1127
     fe4:	a0 91 28 11 	lds	r26, 0x1128
     fe8:	b0 91 29 11 	lds	r27, 0x1129
     fec:	84 17       	cp	r24, r20
     fee:	95 07       	cpc	r25, r21
     ff0:	a6 07       	cpc	r26, r22
     ff2:	b7 07       	cpc	r27, r23
     ff4:	a8 f4       	brcc	.+42     	; 0x1020 <get_colour+0x110>
     ff6:	40 91 82 16 	lds	r20, 0x1682
     ffa:	50 91 83 16 	lds	r21, 0x1683
     ffe:	60 91 84 16 	lds	r22, 0x1684
    1002:	70 91 85 16 	lds	r23, 0x1685
    1006:	80 91 7e 16 	lds	r24, 0x167E
    100a:	90 91 7f 16 	lds	r25, 0x167F
    100e:	a0 91 80 16 	lds	r26, 0x1680
    1012:	b0 91 81 16 	lds	r27, 0x1681
    1016:	84 17       	cp	r24, r20
    1018:	95 07       	cpc	r25, r21
    101a:	a6 07       	cpc	r26, r22
    101c:	b7 07       	cpc	r27, r23
    101e:	80 f1       	brcs	.+96     	; 0x1080 <get_colour+0x170>
			return 0;
		else if(green > red && green > blue)
    1020:	40 91 7e 16 	lds	r20, 0x167E
    1024:	50 91 7f 16 	lds	r21, 0x167F
    1028:	60 91 80 16 	lds	r22, 0x1680
    102c:	70 91 81 16 	lds	r23, 0x1681
    1030:	80 91 82 16 	lds	r24, 0x1682
    1034:	90 91 83 16 	lds	r25, 0x1683
    1038:	a0 91 84 16 	lds	r26, 0x1684
    103c:	b0 91 85 16 	lds	r27, 0x1685
    1040:	84 17       	cp	r24, r20
    1042:	95 07       	cpc	r25, r21
    1044:	a6 07       	cpc	r26, r22
    1046:	b7 07       	cpc	r27, r23
    1048:	f0 f4       	brcc	.+60     	; 0x1086 <get_colour+0x176>
    104a:	40 91 7e 16 	lds	r20, 0x167E
    104e:	50 91 7f 16 	lds	r21, 0x167F
    1052:	60 91 80 16 	lds	r22, 0x1680
    1056:	70 91 81 16 	lds	r23, 0x1681
    105a:	80 91 26 11 	lds	r24, 0x1126
    105e:	90 91 27 11 	lds	r25, 0x1127
    1062:	a0 91 28 11 	lds	r26, 0x1128
    1066:	b0 91 29 11 	lds	r27, 0x1129
    106a:	84 17       	cp	r24, r20
    106c:	95 07       	cpc	r25, r21
    106e:	a6 07       	cpc	r26, r22
    1070:	b7 07       	cpc	r27, r23
    1072:	60 f0       	brcs	.+24     	; 0x108c <get_colour+0x17c>
			return 1;		
	}
	return 3;
    1074:	83 e0       	ldi	r24, 0x03	; 3
    1076:	90 e0       	ldi	r25, 0x00	; 0
    1078:	0b c0       	rjmp	.+22     	; 0x1090 <get_colour+0x180>
	//lcd_print(2,6,red,4);
	EIMSK = EIMSK & 0xFB;
	int a=(red+blue+green)/3;
	   
	if(a<250)
		return 3;
    107a:	83 e0       	ldi	r24, 0x03	; 3
    107c:	90 e0       	ldi	r25, 0x00	; 0
    107e:	08 c0       	rjmp	.+16     	; 0x1090 <get_colour+0x180>
	else
	{
		if(red > blue && red > green)
			return 0;
    1080:	80 e0       	ldi	r24, 0x00	; 0
    1082:	90 e0       	ldi	r25, 0x00	; 0
    1084:	05 c0       	rjmp	.+10     	; 0x1090 <get_colour+0x180>
		else if(green > red && green > blue)
			return 1;		
	}
	return 3;
    1086:	83 e0       	ldi	r24, 0x03	; 3
    1088:	90 e0       	ldi	r25, 0x00	; 0
    108a:	02 c0       	rjmp	.+4      	; 0x1090 <get_colour+0x180>
	else
	{
		if(red > blue && red > green)
			return 0;
		else if(green > red && green > blue)
			return 1;		
    108c:	81 e0       	ldi	r24, 0x01	; 1
    108e:	90 e0       	ldi	r25, 0x00	; 0
	}
	return 3;
}
    1090:	1f 91       	pop	r17
    1092:	0f 91       	pop	r16
    1094:	08 95       	ret

00001096 <clear_w_debis>:

int clear_w_debis(int debris_pos)
{
    1096:	cf 93       	push	r28
    1098:	df 93       	push	r29
    109a:	ec 01       	movw	r28, r24
	servo(105);
    109c:	89 e6       	ldi	r24, 0x69	; 105
    109e:	90 e0       	ldi	r25, 0x00	; 0
    10a0:	0e 94 77 06 	call	0xcee	; 0xcee <servo>
	servo(debris_pos);	//85
    10a4:	ce 01       	movw	r24, r28
    10a6:	0e 94 77 06 	call	0xcee	; 0xcee <servo>
    10aa:	8f ef       	ldi	r24, 0xFF	; 255
    10ac:	9f e3       	ldi	r25, 0x3F	; 63
    10ae:	a2 e0       	ldi	r26, 0x02	; 2
    10b0:	81 50       	subi	r24, 0x01	; 1
    10b2:	90 40       	sbci	r25, 0x00	; 0
    10b4:	a0 40       	sbci	r26, 0x00	; 0
    10b6:	e1 f7       	brne	.-8      	; 0x10b0 <clear_w_debis+0x1a>
    10b8:	00 c0       	rjmp	.+0      	; 0x10ba <clear_w_debis+0x24>
    10ba:	00 00       	nop
	_delay_ms(50);
	int a=get_colour();
    10bc:	0e 94 88 07 	call	0xf10	; 0xf10 <get_colour>
    10c0:	d8 2f       	mov	r29, r24
    10c2:	c9 2f       	mov	r28, r25
	servo(40);
    10c4:	88 e2       	ldi	r24, 0x28	; 40
    10c6:	90 e0       	ldi	r25, 0x00	; 0
    10c8:	0e 94 77 06 	call	0xcee	; 0xcee <servo>
	return a;
}
    10cc:	8d 2f       	mov	r24, r29
    10ce:	9c 2f       	mov	r25, r28
    10d0:	df 91       	pop	r29
    10d2:	cf 91       	pop	r28
    10d4:	08 95       	ret

000010d6 <display_colour>:

void display_colour(int c)
{
	//unsigned char a;
	
	switch(c)
    10d6:	81 30       	cpi	r24, 0x01	; 1
    10d8:	91 05       	cpc	r25, r1
    10da:	49 f0       	breq	.+18     	; 0x10ee <display_colour+0x18>
    10dc:	82 30       	cpi	r24, 0x02	; 2
    10de:	91 05       	cpc	r25, r1
    10e0:	51 f0       	breq	.+20     	; 0x10f6 <display_colour+0x20>
    10e2:	00 97       	sbiw	r24, 0x00	; 0
    10e4:	61 f4       	brne	.+24     	; 0x10fe <display_colour+0x28>
	{
		case 0:
		PORTJ = 0x01;break;
    10e6:	81 e0       	ldi	r24, 0x01	; 1
    10e8:	80 93 05 01 	sts	0x0105, r24
    10ec:	08 95       	ret
		
		case 1:
		PORTJ = 0x02;break;
    10ee:	82 e0       	ldi	r24, 0x02	; 2
    10f0:	80 93 05 01 	sts	0x0105, r24
    10f4:	08 95       	ret
		
		case 2:
		PORTJ = 0x04;break;
    10f6:	84 e0       	ldi	r24, 0x04	; 4
    10f8:	80 93 05 01 	sts	0x0105, r24
    10fc:	08 95       	ret
		
		default:
		case 3:
		PORTJ = 0x00;
    10fe:	10 92 05 01 	sts	0x0105, r1
    1102:	08 95       	ret

00001104 <dijsktra>:
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0}
};

int dijsktra(int source,int target)
{
    1104:	2f 92       	push	r2
    1106:	3f 92       	push	r3
    1108:	4f 92       	push	r4
    110a:	5f 92       	push	r5
    110c:	6f 92       	push	r6
    110e:	7f 92       	push	r7
    1110:	8f 92       	push	r8
    1112:	9f 92       	push	r9
    1114:	af 92       	push	r10
    1116:	bf 92       	push	r11
    1118:	cf 92       	push	r12
    111a:	df 92       	push	r13
    111c:	ef 92       	push	r14
    111e:	ff 92       	push	r15
    1120:	0f 93       	push	r16
    1122:	1f 93       	push	r17
    1124:	cf 93       	push	r28
    1126:	df 93       	push	r29
    1128:	cd b7       	in	r28, 0x3d	; 61
    112a:	de b7       	in	r29, 0x3e	; 62
    112c:	cc 5d       	subi	r28, 0xDC	; 220
    112e:	d0 40       	sbci	r29, 0x00	; 0
    1130:	0f b6       	in	r0, 0x3f	; 63
    1132:	f8 94       	cli
    1134:	de bf       	out	0x3e, r29	; 62
    1136:	0f be       	out	0x3f, r0	; 63
    1138:	cd bf       	out	0x3d, r28	; 61
    113a:	3c 01       	movw	r6, r24
    113c:	c7 52       	subi	r28, 0x27	; 39
    113e:	df 4f       	sbci	r29, 0xFF	; 255
    1140:	79 83       	std	Y+1, r23	; 0x01
    1142:	68 83       	st	Y, r22
    1144:	c9 5d       	subi	r28, 0xD9	; 217
    1146:	d0 40       	sbci	r29, 0x00	; 0
  int dist[N],prev[N],selected[N]={0},i,m,min,start,d,j;
    1148:	84 e3       	ldi	r24, 0x34	; 52
    114a:	fe 01       	movw	r30, r28
    114c:	e7 59       	subi	r30, 0x97	; 151
    114e:	ff 4f       	sbci	r31, 0xFF	; 255
    1150:	df 01       	movw	r26, r30
    1152:	1d 92       	st	X+, r1
    1154:	8a 95       	dec	r24
    1156:	e9 f7       	brne	.-6      	; 0x1152 <dijsktra+0x4e>
  int path[N];
  for(i=1;i< N;i++)
    1158:	a1 e0       	ldi	r26, 0x01	; 1
    115a:	b0 e0       	ldi	r27, 0x00	; 0
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0}
};

int dijsktra(int source,int target)
{
    115c:	01 e0       	ldi	r16, 0x01	; 1
    115e:	10 e0       	ldi	r17, 0x00	; 0
  int dist[N],prev[N],selected[N]={0},i,m,min,start,d,j;
  int path[N];
  for(i=1;i< N;i++)
    for(j=1;j< N;j++)
      if(cost[i][j] == 0)
    1160:	0f 2e       	mov	r0, r31
    1162:	fa e1       	ldi	r31, 0x1A	; 26
    1164:	ef 2e       	mov	r14, r31
    1166:	ff 24       	eor	r15, r15
    1168:	f0 2d       	mov	r31, r0
    116a:	60 e0       	ldi	r22, 0x00	; 0
    116c:	72 e0       	ldi	r23, 0x02	; 2
         cost[i][j]=IN;
    116e:	e3 e6       	ldi	r30, 0x63	; 99
    1170:	f0 e0       	ldi	r31, 0x00	; 0
    1172:	6d 01       	movw	r12, r26
    1174:	1c c0       	rjmp	.+56     	; 0x11ae <dijsktra+0xaa>
{
  int dist[N],prev[N],selected[N]={0},i,m,min,start,d,j;
  int path[N];
  for(i=1;i< N;i++)
    for(j=1;j< N;j++)
      if(cost[i][j] == 0)
    1176:	ca 01       	movw	r24, r20
    1178:	82 0f       	add	r24, r18
    117a:	93 1f       	adc	r25, r19
    117c:	88 0f       	add	r24, r24
    117e:	99 1f       	adc	r25, r25
    1180:	86 0f       	add	r24, r22
    1182:	97 1f       	adc	r25, r23
    1184:	dc 01       	movw	r26, r24
    1186:	8d 91       	ld	r24, X+
    1188:	9c 91       	ld	r25, X
    118a:	11 97       	sbiw	r26, 0x01	; 1
    118c:	00 97       	sbiw	r24, 0x00	; 0
    118e:	19 f4       	brne	.+6      	; 0x1196 <dijsktra+0x92>
         cost[i][j]=IN;
    1190:	11 96       	adiw	r26, 0x01	; 1
    1192:	fc 93       	st	X, r31
    1194:	ee 93       	st	-X, r30
int dijsktra(int source,int target)
{
  int dist[N],prev[N],selected[N]={0},i,m,min,start,d,j;
  int path[N];
  for(i=1;i< N;i++)
    for(j=1;j< N;j++)
    1196:	2f 5f       	subi	r18, 0xFF	; 255
    1198:	3f 4f       	sbci	r19, 0xFF	; 255
    119a:	2a 31       	cpi	r18, 0x1A	; 26
    119c:	31 05       	cpc	r19, r1
    119e:	59 f7       	brne	.-42     	; 0x1176 <dijsktra+0x72>

int dijsktra(int source,int target)
{
  int dist[N],prev[N],selected[N]={0},i,m,min,start,d,j;
  int path[N];
  for(i=1;i< N;i++)
    11a0:	08 94       	sec
    11a2:	c1 1c       	adc	r12, r1
    11a4:	d1 1c       	adc	r13, r1
    11a6:	ba e1       	ldi	r27, 0x1A	; 26
    11a8:	cb 16       	cp	r12, r27
    11aa:	d1 04       	cpc	r13, r1
    11ac:	49 f0       	breq	.+18     	; 0x11c0 <dijsktra+0xbc>
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0}
};

int dijsktra(int source,int target)
{
    11ae:	98 01       	movw	r18, r16
  int dist[N],prev[N],selected[N]={0},i,m,min,start,d,j;
  int path[N];
  for(i=1;i< N;i++)
    for(j=1;j< N;j++)
      if(cost[i][j] == 0)
    11b0:	ce 9c       	mul	r12, r14
    11b2:	a0 01       	movw	r20, r0
    11b4:	cf 9c       	mul	r12, r15
    11b6:	50 0d       	add	r21, r0
    11b8:	de 9c       	mul	r13, r14
    11ba:	50 0d       	add	r21, r0
    11bc:	11 24       	eor	r1, r1
    11be:	db cf       	rjmp	.-74     	; 0x1176 <dijsktra+0x72>

int dijsktra(int source,int target)
{
  int dist[N],prev[N],selected[N]={0},i,m,min,start,d,j;
  int path[N];
  for(i=1;i< N;i++)
    11c0:	8e 01       	movw	r16, r28
    11c2:	0d 5f       	subi	r16, 0xFD	; 253
    11c4:	1f 4f       	sbci	r17, 0xFF	; 255
    11c6:	be 01       	movw	r22, r28
    11c8:	69 5c       	subi	r22, 0xC9	; 201
    11ca:	7f 4f       	sbci	r23, 0xFF	; 255
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0}
};

int dijsktra(int source,int target)
    11cc:	ce 01       	movw	r24, r28
    11ce:	c5 96       	adiw	r24, 0x35	; 53
    11d0:	db 01       	movw	r26, r22
    11d2:	f8 01       	movw	r30, r16
      if(cost[i][j] == 0)
         cost[i][j]=IN;

  for(i=1;i< N;i++)
  {
    dist[i] = IN;
    11d4:	23 e6       	ldi	r18, 0x63	; 99
    11d6:	30 e0       	ldi	r19, 0x00	; 0
    prev[i] = -1;
    11d8:	4f ef       	ldi	r20, 0xFF	; 255
    11da:	5f ef       	ldi	r21, 0xFF	; 255
      if(cost[i][j] == 0)
         cost[i][j]=IN;

  for(i=1;i< N;i++)
  {
    dist[i] = IN;
    11dc:	21 93       	st	Z+, r18
    11de:	31 93       	st	Z+, r19
    prev[i] = -1;
    11e0:	4d 93       	st	X+, r20
    11e2:	5d 93       	st	X+, r21
  for(i=1;i< N;i++)
    for(j=1;j< N;j++)
      if(cost[i][j] == 0)
         cost[i][j]=IN;

  for(i=1;i< N;i++)
    11e4:	e8 17       	cp	r30, r24
    11e6:	f9 07       	cpc	r31, r25
    11e8:	c9 f7       	brne	.-14     	; 0x11dc <dijsktra+0xd8>
    dist[i] = IN;
    prev[i] = -1;
  }

  start = source;
  selected[start]=1;
    11ea:	c3 01       	movw	r24, r6
    11ec:	88 0f       	add	r24, r24
    11ee:	99 1f       	adc	r25, r25
    11f0:	e9 e6       	ldi	r30, 0x69	; 105
    11f2:	f0 e0       	ldi	r31, 0x00	; 0
    11f4:	ec 0f       	add	r30, r28
    11f6:	fd 1f       	adc	r31, r29
    11f8:	e8 0f       	add	r30, r24
    11fa:	f9 1f       	adc	r31, r25
    11fc:	21 e0       	ldi	r18, 0x01	; 1
    11fe:	30 e0       	ldi	r19, 0x00	; 0
    1200:	31 83       	std	Z+1, r19	; 0x01
    1202:	20 83       	st	Z, r18
  dist[start] = 0;
    1204:	8c 0f       	add	r24, r28
    1206:	9d 1f       	adc	r25, r29
    1208:	fc 01       	movw	r30, r24
    120a:	12 82       	std	Z+2, r1	; 0x02
    120c:	11 82       	std	Z+1, r1	; 0x01

  while(selected[target] == 0)
    120e:	c7 52       	subi	r28, 0x27	; 39
    1210:	df 4f       	sbci	r29, 0xFF	; 255
    1212:	e8 81       	ld	r30, Y
    1214:	f9 81       	ldd	r31, Y+1	; 0x01
    1216:	c9 5d       	subi	r28, 0xD9	; 217
    1218:	d0 40       	sbci	r29, 0x00	; 0
    121a:	ee 0f       	add	r30, r30
    121c:	ff 1f       	adc	r31, r31
    121e:	29 e6       	ldi	r18, 0x69	; 105
    1220:	30 e0       	ldi	r19, 0x00	; 0
    1222:	2c 0f       	add	r18, r28
    1224:	3d 1f       	adc	r19, r29
    1226:	e2 0f       	add	r30, r18
    1228:	f3 1f       	adc	r31, r19
    122a:	80 81       	ld	r24, Z
    122c:	91 81       	ldd	r25, Z+1	; 0x01
    122e:	00 97       	sbiw	r24, 0x00	; 0
    1230:	09 f4       	brne	.+2      	; 0x1234 <dijsktra+0x130>
    1232:	61 c0       	rjmp	.+194    	; 0x12f6 <dijsktra+0x1f2>
    1234:	d3 c0       	rjmp	.+422    	; 0x13dc <dijsktra+0x2d8>
  {
    min = IN;
    m = 0;
    for(i=1;i< N;i++)
    {
      d = dist[start] +cost[start][i];
    1236:	c6 01       	movw	r24, r12
    1238:	84 0f       	add	r24, r20
    123a:	95 1f       	adc	r25, r21
    123c:	88 0f       	add	r24, r24
    123e:	99 1f       	adc	r25, r25
    1240:	88 0d       	add	r24, r8
    1242:	99 1d       	adc	r25, r9
    1244:	dc 01       	movw	r26, r24
    1246:	8d 91       	ld	r24, X+
    1248:	9c 91       	ld	r25, X
    124a:	d5 01       	movw	r26, r10
    124c:	2d 91       	ld	r18, X+
    124e:	3c 91       	ld	r19, X
    1250:	11 97       	sbiw	r26, 0x01	; 1
    1252:	28 0f       	add	r18, r24
    1254:	39 1f       	adc	r19, r25
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0}
};

int dijsktra(int source,int target)
    1256:	c5 52       	subi	r28, 0x25	; 37
    1258:	df 4f       	sbci	r29, 0xFF	; 255
    125a:	f9 83       	std	Y+1, r31	; 0x01
    125c:	e8 83       	st	Y, r30
    125e:	cb 5d       	subi	r28, 0xDB	; 219
    1260:	d0 40       	sbci	r29, 0x00	; 0
    m = 0;
    for(i=1;i< N;i++)
    {
      d = dist[start] +cost[start][i];

      if(d< dist[i] && selected[i] == 0)
    1262:	80 81       	ld	r24, Z
    1264:	91 81       	ldd	r25, Z+1	; 0x01
    1266:	28 17       	cp	r18, r24
    1268:	39 07       	cpc	r19, r25
    126a:	5c f4       	brge	.+22     	; 0x1282 <dijsktra+0x17e>
    126c:	db 01       	movw	r26, r22
    126e:	8d 91       	ld	r24, X+
    1270:	9c 91       	ld	r25, X
    1272:	11 97       	sbiw	r26, 0x01	; 1
    1274:	00 97       	sbiw	r24, 0x00	; 0
    1276:	29 f4       	brne	.+10     	; 0x1282 <dijsktra+0x17e>
      {
        dist[i] = d;
    1278:	31 83       	std	Z+1, r19	; 0x01
    127a:	20 83       	st	Z, r18
        prev[i] = start;
    127c:	d8 01       	movw	r26, r16
    127e:	6d 92       	st	X+, r6
    1280:	7c 92       	st	X, r7
      }
      if(min>dist[i] && selected[i]==0)
    1282:	c5 52       	subi	r28, 0x25	; 37
    1284:	df 4f       	sbci	r29, 0xFF	; 255
    1286:	a8 81       	ld	r26, Y
    1288:	b9 81       	ldd	r27, Y+1	; 0x01
    128a:	cb 5d       	subi	r28, 0xDB	; 219
    128c:	d0 40       	sbci	r29, 0x00	; 0
    128e:	8d 91       	ld	r24, X+
    1290:	9c 91       	ld	r25, X
    1292:	11 97       	sbiw	r26, 0x01	; 1
    1294:	32 96       	adiw	r30, 0x02	; 2
    1296:	8e 15       	cp	r24, r14
    1298:	9f 05       	cpc	r25, r15
    129a:	4c f4       	brge	.+18     	; 0x12ae <dijsktra+0x1aa>
    129c:	db 01       	movw	r26, r22
    129e:	2d 91       	ld	r18, X+
    12a0:	3c 91       	ld	r19, X
    12a2:	11 97       	sbiw	r26, 0x01	; 1
    12a4:	21 15       	cp	r18, r1
    12a6:	31 05       	cpc	r19, r1
    12a8:	11 f4       	brne	.+4      	; 0x12ae <dijsktra+0x1aa>
      {
        min = dist[i];
    12aa:	7c 01       	movw	r14, r24
      if(d< dist[i] && selected[i] == 0)
      {
        dist[i] = d;
        prev[i] = start;
      }
      if(min>dist[i] && selected[i]==0)
    12ac:	2a 01       	movw	r4, r20

  while(selected[target] == 0)
  {
    min = IN;
    m = 0;
    for(i=1;i< N;i++)
    12ae:	4f 5f       	subi	r20, 0xFF	; 255
    12b0:	5f 4f       	sbci	r21, 0xFF	; 255
    12b2:	6e 5f       	subi	r22, 0xFE	; 254
    12b4:	7f 4f       	sbci	r23, 0xFF	; 255
    12b6:	0e 5f       	subi	r16, 0xFE	; 254
    12b8:	1f 4f       	sbci	r17, 0xFF	; 255
    12ba:	4a 31       	cpi	r20, 0x1A	; 26
    12bc:	51 05       	cpc	r21, r1
    12be:	09 f0       	breq	.+2      	; 0x12c2 <dijsktra+0x1be>
    12c0:	ba cf       	rjmp	.-140    	; 0x1236 <dijsktra+0x132>
        min = dist[i];
        m = i;
      }
    }
    start = m;
    selected[start] = 1;
    12c2:	c2 01       	movw	r24, r4
    12c4:	88 0f       	add	r24, r24
    12c6:	99 1f       	adc	r25, r25
    12c8:	e9 e6       	ldi	r30, 0x69	; 105
    12ca:	f0 e0       	ldi	r31, 0x00	; 0
    12cc:	ec 0f       	add	r30, r28
    12ce:	fd 1f       	adc	r31, r29
    12d0:	8e 0f       	add	r24, r30
    12d2:	9f 1f       	adc	r25, r31
    12d4:	dc 01       	movw	r26, r24
    12d6:	11 96       	adiw	r26, 0x01	; 1
    12d8:	3c 92       	st	X, r3
    12da:	2e 92       	st	-X, r2

  start = source;
  selected[start]=1;
  dist[start] = 0;

  while(selected[target] == 0)
    12dc:	cd 52       	subi	r28, 0x2D	; 45
    12de:	df 4f       	sbci	r29, 0xFF	; 255
    12e0:	e8 81       	ld	r30, Y
    12e2:	f9 81       	ldd	r31, Y+1	; 0x01
    12e4:	c3 5d       	subi	r28, 0xD3	; 211
    12e6:	d0 40       	sbci	r29, 0x00	; 0
    12e8:	80 81       	ld	r24, Z
    12ea:	91 81       	ldd	r25, Z+1	; 0x01
    12ec:	00 97       	sbiw	r24, 0x00	; 0
    12ee:	09 f0       	breq	.+2      	; 0x12f2 <dijsktra+0x1ee>
    12f0:	75 c0       	rjmp	.+234    	; 0x13dc <dijsktra+0x2d8>
      {
        min = dist[i];
        m = i;
      }
    }
    start = m;
    12f2:	32 01       	movw	r6, r4
    12f4:	3d c0       	rjmp	.+122    	; 0x1370 <dijsktra+0x26c>

  start = source;
  selected[start]=1;
  dist[start] = 0;

  while(selected[target] == 0)
    12f6:	29 e6       	ldi	r18, 0x69	; 105
    12f8:	30 e0       	ldi	r19, 0x00	; 0
    12fa:	2c 0f       	add	r18, r28
    12fc:	3d 1f       	adc	r19, r29
    12fe:	2e 5f       	subi	r18, 0xFE	; 254
    1300:	3f 4f       	sbci	r19, 0xFF	; 255
    1302:	cf 52       	subi	r28, 0x2F	; 47
    1304:	df 4f       	sbci	r29, 0xFF	; 255
    1306:	39 83       	std	Y+1, r19	; 0x01
    1308:	28 83       	st	Y, r18
    130a:	c1 5d       	subi	r28, 0xD1	; 209
    130c:	d0 40       	sbci	r29, 0x00	; 0
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0}
};

int dijsktra(int source,int target)
    130e:	cb 52       	subi	r28, 0x2B	; 43
    1310:	df 4f       	sbci	r29, 0xFF	; 255
    1312:	68 83       	st	Y, r22
    1314:	c5 5d       	subi	r28, 0xD5	; 213
    1316:	d0 40       	sbci	r29, 0x00	; 0
    1318:	ca 52       	subi	r28, 0x2A	; 42
    131a:	df 4f       	sbci	r29, 0xFF	; 255
    131c:	78 83       	st	Y, r23
    131e:	c6 5d       	subi	r28, 0xD6	; 214
    1320:	d0 40       	sbci	r29, 0x00	; 0
    1322:	c9 52       	subi	r28, 0x29	; 41
    1324:	df 4f       	sbci	r29, 0xFF	; 255
    1326:	08 83       	st	Y, r16
    1328:	c7 5d       	subi	r28, 0xD7	; 215
    132a:	d0 40       	sbci	r29, 0x00	; 0
    132c:	c8 52       	subi	r28, 0x28	; 40
    132e:	df 4f       	sbci	r29, 0xFF	; 255
    1330:	18 83       	st	Y, r17
    1332:	c8 5d       	subi	r28, 0xD8	; 216
    1334:	d0 40       	sbci	r29, 0x00	; 0
    1336:	22 24       	eor	r2, r2
    1338:	33 24       	eor	r3, r3
    133a:	23 94       	inc	r2
  {
    min = IN;
    m = 0;
    for(i=1;i< N;i++)
    {
      d = dist[start] +cost[start][i];
    133c:	0f 2e       	mov	r0, r31
    133e:	f0 e0       	ldi	r31, 0x00	; 0
    1340:	8f 2e       	mov	r8, r31
    1342:	f2 e0       	ldi	r31, 0x02	; 2
    1344:	9f 2e       	mov	r9, r31
    1346:	f0 2d       	mov	r31, r0

  start = source;
  selected[start]=1;
  dist[start] = 0;

  while(selected[target] == 0)
    1348:	c7 52       	subi	r28, 0x27	; 39
    134a:	df 4f       	sbci	r29, 0xFF	; 255
    134c:	88 81       	ld	r24, Y
    134e:	99 81       	ldd	r25, Y+1	; 0x01
    1350:	c9 5d       	subi	r28, 0xD9	; 217
    1352:	d0 40       	sbci	r29, 0x00	; 0
    1354:	88 0f       	add	r24, r24
    1356:	99 1f       	adc	r25, r25
    1358:	a9 e6       	ldi	r26, 0x69	; 105
    135a:	b0 e0       	ldi	r27, 0x00	; 0
    135c:	ac 0f       	add	r26, r28
    135e:	bd 1f       	adc	r27, r29
    1360:	a8 0f       	add	r26, r24
    1362:	b9 1f       	adc	r27, r25
    1364:	cd 52       	subi	r28, 0x2D	; 45
    1366:	df 4f       	sbci	r29, 0xFF	; 255
    1368:	b9 83       	std	Y+1, r27	; 0x01
    136a:	a8 83       	st	Y, r26
    136c:	c3 5d       	subi	r28, 0xD3	; 211
    136e:	d0 40       	sbci	r29, 0x00	; 0
    1370:	cf 52       	subi	r28, 0x2F	; 47
    1372:	df 4f       	sbci	r29, 0xFF	; 255
    1374:	68 81       	ld	r22, Y
    1376:	79 81       	ldd	r23, Y+1	; 0x01
    1378:	c1 5d       	subi	r28, 0xD1	; 209
    137a:	d0 40       	sbci	r29, 0x00	; 0
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0}
};

int dijsktra(int source,int target)
    137c:	cb 52       	subi	r28, 0x2B	; 43
    137e:	df 4f       	sbci	r29, 0xFF	; 255
    1380:	08 81       	ld	r16, Y
    1382:	c5 5d       	subi	r28, 0xD5	; 213
    1384:	d0 40       	sbci	r29, 0x00	; 0
    1386:	ca 52       	subi	r28, 0x2A	; 42
    1388:	df 4f       	sbci	r29, 0xFF	; 255
    138a:	18 81       	ld	r17, Y
    138c:	c6 5d       	subi	r28, 0xD6	; 214
    138e:	d0 40       	sbci	r29, 0x00	; 0
    1390:	c9 52       	subi	r28, 0x29	; 41
    1392:	df 4f       	sbci	r29, 0xFF	; 255
    1394:	e8 81       	ld	r30, Y
    1396:	c7 5d       	subi	r28, 0xD7	; 215
    1398:	d0 40       	sbci	r29, 0x00	; 0
    139a:	c8 52       	subi	r28, 0x28	; 40
    139c:	df 4f       	sbci	r29, 0xFF	; 255
    139e:	f8 81       	ld	r31, Y
    13a0:	c8 5d       	subi	r28, 0xD8	; 216
    13a2:	d0 40       	sbci	r29, 0x00	; 0
    13a4:	0f 2e       	mov	r0, r31
    13a6:	f3 e6       	ldi	r31, 0x63	; 99
    13a8:	ef 2e       	mov	r14, r31
    13aa:	ff 24       	eor	r15, r15
    13ac:	f0 2d       	mov	r31, r0
    13ae:	44 24       	eor	r4, r4
    13b0:	55 24       	eor	r5, r5
    13b2:	a1 01       	movw	r20, r2
  {
    min = IN;
    m = 0;
    for(i=1;i< N;i++)
    {
      d = dist[start] +cost[start][i];
    13b4:	2a e1       	ldi	r18, 0x1A	; 26
    13b6:	30 e0       	ldi	r19, 0x00	; 0
    13b8:	62 9e       	mul	r6, r18
    13ba:	60 01       	movw	r12, r0
    13bc:	63 9e       	mul	r6, r19
    13be:	d0 0c       	add	r13, r0
    13c0:	72 9e       	mul	r7, r18
    13c2:	d0 0c       	add	r13, r0
    13c4:	11 24       	eor	r1, r1
    13c6:	c3 01       	movw	r24, r6
    13c8:	88 0f       	add	r24, r24
    13ca:	99 1f       	adc	r25, r25
    13cc:	aa 24       	eor	r10, r10
    13ce:	bb 24       	eor	r11, r11
    13d0:	a3 94       	inc	r10
    13d2:	ac 0e       	add	r10, r28
    13d4:	bd 1e       	adc	r11, r29
    13d6:	a8 0e       	add	r10, r24
    13d8:	b9 1e       	adc	r11, r25
    13da:	2d cf       	rjmp	.-422    	; 0x1236 <dijsktra+0x132>
    selected[start] = 1;
  }
  start = target;
  j = 0;

  while(start != -1)
    13dc:	c7 52       	subi	r28, 0x27	; 39
    13de:	df 4f       	sbci	r29, 0xFF	; 255
    13e0:	88 81       	ld	r24, Y
    13e2:	99 81       	ldd	r25, Y+1	; 0x01
    13e4:	c9 5d       	subi	r28, 0xD9	; 217
    13e6:	d0 40       	sbci	r29, 0x00	; 0
    13e8:	af ef       	ldi	r26, 0xFF	; 255
    13ea:	8f 3f       	cpi	r24, 0xFF	; 255
    13ec:	9a 07       	cpc	r25, r26
    13ee:	d9 f0       	breq	.+54     	; 0x1426 <dijsktra+0x322>
    13f0:	fe 01       	movw	r30, r28
    13f2:	e3 56       	subi	r30, 0x63	; 99
    13f4:	ff 4f       	sbci	r31, 0xFF	; 255
    13f6:	40 e0       	ldi	r20, 0x00	; 0
    13f8:	50 e0       	ldi	r21, 0x00	; 0
  {
    path[j++] = start;
    13fa:	81 93       	st	Z+, r24
    13fc:	91 93       	st	Z+, r25
    13fe:	4f 5f       	subi	r20, 0xFF	; 255
    1400:	5f 4f       	sbci	r21, 0xFF	; 255
    start = prev[start];
    1402:	dc 01       	movw	r26, r24
    1404:	aa 0f       	add	r26, r26
    1406:	bb 1f       	adc	r27, r27
    1408:	21 e0       	ldi	r18, 0x01	; 1
    140a:	30 e0       	ldi	r19, 0x00	; 0
    140c:	2c 0f       	add	r18, r28
    140e:	3d 1f       	adc	r19, r29
    1410:	a2 0f       	add	r26, r18
    1412:	b3 1f       	adc	r27, r19
    1414:	d4 96       	adiw	r26, 0x34	; 52
    1416:	8d 91       	ld	r24, X+
    1418:	9c 91       	ld	r25, X
    141a:	d5 97       	sbiw	r26, 0x35	; 53
    selected[start] = 1;
  }
  start = target;
  j = 0;

  while(start != -1)
    141c:	3f ef       	ldi	r19, 0xFF	; 255
    141e:	8f 3f       	cpi	r24, 0xFF	; 255
    1420:	93 07       	cpc	r25, r19
    1422:	59 f7       	brne	.-42     	; 0x13fa <dijsktra+0x2f6>
    1424:	02 c0       	rjmp	.+4      	; 0x142a <dijsktra+0x326>
    1426:	40 e0       	ldi	r20, 0x00	; 0
    1428:	50 e0       	ldi	r21, 0x00	; 0
  {
    path[j++] = start;
    start = prev[start];
  }

    path[j]=0;
    142a:	fa 01       	movw	r30, r20
    142c:	ee 0f       	add	r30, r30
    142e:	ff 1f       	adc	r31, r31
    1430:	8d e9       	ldi	r24, 0x9D	; 157
    1432:	90 e0       	ldi	r25, 0x00	; 0
    1434:	8c 0f       	add	r24, r28
    1436:	9d 1f       	adc	r25, r29
    1438:	e8 0f       	add	r30, r24
    143a:	f9 1f       	adc	r31, r25
    143c:	11 82       	std	Z+1, r1	; 0x01
    143e:	10 82       	st	Z, r1
    1440:	a8 e8       	ldi	r26, 0x88	; 136
    1442:	b6 e1       	ldi	r27, 0x16	; 22
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0}
};

int dijsktra(int source,int target)
    1444:	9d 01       	movw	r18, r26
    1446:	cd 01       	movw	r24, r26
    1448:	c4 96       	adiw	r24, 0x34	; 52
    144a:	fd 01       	movw	r30, r26
  }

    path[j]=0;
    int k=0;
    for(i=0;i<N;i++)
        n_node[i]=0;
    144c:	11 92       	st	Z+, r1
    144e:	11 92       	st	Z+, r1
    start = prev[start];
  }

    path[j]=0;
    int k=0;
    for(i=0;i<N;i++)
    1450:	e8 17       	cp	r30, r24
    1452:	f9 07       	cpc	r31, r25
    1454:	d9 f7       	brne	.-10     	; 0x144c <dijsktra+0x348>
        n_node[i]=0;

    for(i=j-1;i>=0;i--)
    1456:	ca 01       	movw	r24, r20
    1458:	01 97       	sbiw	r24, 0x01	; 1
    145a:	92 f0       	brmi	.+36     	; 0x1480 <dijsktra+0x37c>
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1},
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0}
};

int dijsktra(int source,int target)
    145c:	ca 01       	movw	r24, r20
    145e:	88 0f       	add	r24, r24
    1460:	99 1f       	adc	r25, r25
    1462:	ed e9       	ldi	r30, 0x9D	; 157
    1464:	f0 e0       	ldi	r31, 0x00	; 0
    1466:	ec 0f       	add	r30, r28
    1468:	fd 1f       	adc	r31, r29
    146a:	e8 0f       	add	r30, r24
    146c:	f9 1f       	adc	r31, r25
    146e:	82 0f       	add	r24, r18
    1470:	93 1f       	adc	r25, r19
    int k=0;
    for(i=0;i<N;i++)
        n_node[i]=0;

    for(i=j-1;i>=0;i--)
        n_node[k++]=path[i];
    1472:	32 91       	ld	r19, -Z
    1474:	22 91       	ld	r18, -Z
    1476:	2d 93       	st	X+, r18
    1478:	3d 93       	st	X+, r19
    path[j]=0;
    int k=0;
    for(i=0;i<N;i++)
        n_node[i]=0;

    for(i=j-1;i>=0;i--)
    147a:	a8 17       	cp	r26, r24
    147c:	b9 07       	cpc	r27, r25
    147e:	c9 f7       	brne	.-14     	; 0x1472 <dijsktra+0x36e>
        n_node[k++]=path[i];

    return j;
}
    1480:	84 2f       	mov	r24, r20
    1482:	95 2f       	mov	r25, r21
    1484:	c4 52       	subi	r28, 0x24	; 36
    1486:	df 4f       	sbci	r29, 0xFF	; 255
    1488:	0f b6       	in	r0, 0x3f	; 63
    148a:	f8 94       	cli
    148c:	de bf       	out	0x3e, r29	; 62
    148e:	0f be       	out	0x3f, r0	; 63
    1490:	cd bf       	out	0x3d, r28	; 61
    1492:	df 91       	pop	r29
    1494:	cf 91       	pop	r28
    1496:	1f 91       	pop	r17
    1498:	0f 91       	pop	r16
    149a:	ff 90       	pop	r15
    149c:	ef 90       	pop	r14
    149e:	df 90       	pop	r13
    14a0:	cf 90       	pop	r12
    14a2:	bf 90       	pop	r11
    14a4:	af 90       	pop	r10
    14a6:	9f 90       	pop	r9
    14a8:	8f 90       	pop	r8
    14aa:	7f 90       	pop	r7
    14ac:	6f 90       	pop	r6
    14ae:	5f 90       	pop	r5
    14b0:	4f 90       	pop	r4
    14b2:	3f 90       	pop	r3
    14b4:	2f 90       	pop	r2
    14b6:	08 95       	ret

000014b8 <setp>:

struct node n[26];
struct plot b[17];

void setp(int start,int id)		// To initialize all 4 paths in a plot
{
    14b8:	dc 01       	movw	r26, r24
	b[id].st[1]=start;
    14ba:	fb 01       	movw	r30, r22
    14bc:	ee 0f       	add	r30, r30
    14be:	ff 1f       	adc	r31, r31
    14c0:	e2 95       	swap	r30
    14c2:	f2 95       	swap	r31
    14c4:	f0 7f       	andi	r31, 0xF0	; 240
    14c6:	fe 27       	eor	r31, r30
    14c8:	e0 7f       	andi	r30, 0xF0	; 240
    14ca:	fe 27       	eor	r31, r30
    14cc:	e6 53       	subi	r30, 0x36	; 54
    14ce:	f3 4f       	sbci	r31, 0xF3	; 243
    14d0:	93 83       	std	Z+3, r25	; 0x03
    14d2:	82 83       	std	Z+2, r24	; 0x02
	b[id].ed[1]=start+1;
    14d4:	01 96       	adiw	r24, 0x01	; 1
    14d6:	95 87       	std	Z+13, r25	; 0x0d
    14d8:	84 87       	std	Z+12, r24	; 0x0c
	b[id].st[2]=start+5;
    14da:	ad 01       	movw	r20, r26
    14dc:	4b 5f       	subi	r20, 0xFB	; 251
    14de:	5f 4f       	sbci	r21, 0xFF	; 255
    14e0:	55 83       	std	Z+5, r21	; 0x05
    14e2:	44 83       	std	Z+4, r20	; 0x04
	b[id].ed[2]=start+6;
    14e4:	9d 01       	movw	r18, r26
    14e6:	2a 5f       	subi	r18, 0xFA	; 250
    14e8:	3f 4f       	sbci	r19, 0xFF	; 255
    14ea:	37 87       	std	Z+15, r19	; 0x0f
    14ec:	26 87       	std	Z+14, r18	; 0x0e
	b[id].st[3]=start;
    14ee:	b7 83       	std	Z+7, r27	; 0x07
    14f0:	a6 83       	std	Z+6, r26	; 0x06
	b[id].ed[3]=start+5;
    14f2:	51 8b       	std	Z+17, r21	; 0x11
    14f4:	40 8b       	std	Z+16, r20	; 0x10
	b[id].st[4]=start+1;
    14f6:	91 87       	std	Z+9, r25	; 0x09
    14f8:	80 87       	std	Z+8, r24	; 0x08
	b[id].ed[4]=start+6;
    14fa:	33 8b       	std	Z+19, r19	; 0x13
    14fc:	22 8b       	std	Z+18, r18	; 0x12

	b[id].adj[1]=start;
    14fe:	b1 8f       	std	Z+25, r27	; 0x19
    1500:	a0 8f       	std	Z+24, r26	; 0x18
	b[id].adj[2]=start+1;
    1502:	93 8f       	std	Z+27, r25	; 0x1b
    1504:	82 8f       	std	Z+26, r24	; 0x1a
	b[id].adj[3]=start+6;
    1506:	35 8f       	std	Z+29, r19	; 0x1d
    1508:	24 8f       	std	Z+28, r18	; 0x1c
	b[id].adj[4]=start+5;
    150a:	57 8f       	std	Z+31, r21	; 0x1f
    150c:	46 8f       	std	Z+30, r20	; 0x1e
}
    150e:	08 95       	ret

00001510 <setPlot>:

void setPlot(void)				// To initalize all plots with their respective paths
{
    1510:	cf 93       	push	r28
    1512:	df 93       	push	r29
    int i;
	for(i=1;i<=16;i++)
    1514:	c1 e0       	ldi	r28, 0x01	; 1
    1516:	d0 e0       	ldi	r29, 0x00	; 0
	{
		if(i<=4)
    1518:	c5 30       	cpi	r28, 0x05	; 5
    151a:	d1 05       	cpc	r29, r1
    151c:	2c f4       	brge	.+10     	; 0x1528 <setPlot+0x18>
		{
			setp(i,i);
    151e:	ce 01       	movw	r24, r28
    1520:	be 01       	movw	r22, r28
    1522:	0e 94 5c 0a 	call	0x14b8	; 0x14b8 <setp>
    1526:	1a c0       	rjmp	.+52     	; 0x155c <setPlot+0x4c>
		}
		else if(i<=8)
    1528:	c9 30       	cpi	r28, 0x09	; 9
    152a:	d1 05       	cpc	r29, r1
    152c:	34 f4       	brge	.+12     	; 0x153a <setPlot+0x2a>
		{
			setp(i+1,i);
    152e:	ce 01       	movw	r24, r28
    1530:	01 96       	adiw	r24, 0x01	; 1
    1532:	be 01       	movw	r22, r28
    1534:	0e 94 5c 0a 	call	0x14b8	; 0x14b8 <setp>
    1538:	11 c0       	rjmp	.+34     	; 0x155c <setPlot+0x4c>
		}
		else if(i<=12)
    153a:	cd 30       	cpi	r28, 0x0D	; 13
    153c:	d1 05       	cpc	r29, r1
    153e:	34 f4       	brge	.+12     	; 0x154c <setPlot+0x3c>
		{
			setp(i+2,i);
    1540:	ce 01       	movw	r24, r28
    1542:	02 96       	adiw	r24, 0x02	; 2
    1544:	be 01       	movw	r22, r28
    1546:	0e 94 5c 0a 	call	0x14b8	; 0x14b8 <setp>
    154a:	08 c0       	rjmp	.+16     	; 0x155c <setPlot+0x4c>
		}
		else if(i<=16)
    154c:	c1 31       	cpi	r28, 0x11	; 17
    154e:	d1 05       	cpc	r29, r1
    1550:	2c f4       	brge	.+10     	; 0x155c <setPlot+0x4c>
		{
			setp(i+3,i);
    1552:	ce 01       	movw	r24, r28
    1554:	03 96       	adiw	r24, 0x03	; 3
    1556:	be 01       	movw	r22, r28
    1558:	0e 94 5c 0a 	call	0x14b8	; 0x14b8 <setp>
}

void setPlot(void)				// To initalize all plots with their respective paths
{
    int i;
	for(i=1;i<=16;i++)
    155c:	21 96       	adiw	r28, 0x01	; 1
    155e:	c1 31       	cpi	r28, 0x11	; 17
    1560:	d1 05       	cpc	r29, r1
    1562:	d1 f6       	brne	.-76     	; 0x1518 <setPlot+0x8>
		else if(i<=16)
		{
			setp(i+3,i);
		}
	}
}
    1564:	df 91       	pop	r29
    1566:	cf 91       	pop	r28
    1568:	08 95       	ret

0000156a <set_adj_Plots>:

void set_adj_Plots(void)		// To initialize adjacent plots of each node
{
    156a:	2f 92       	push	r2
    156c:	3f 92       	push	r3
    156e:	4f 92       	push	r4
    1570:	5f 92       	push	r5
    1572:	6f 92       	push	r6
    1574:	7f 92       	push	r7
    1576:	8f 92       	push	r8
    1578:	9f 92       	push	r9
    157a:	af 92       	push	r10
    157c:	bf 92       	push	r11
    157e:	cf 92       	push	r12
    1580:	df 92       	push	r13
    1582:	ef 92       	push	r14
    1584:	ff 92       	push	r15
    1586:	0f 93       	push	r16
    1588:	1f 93       	push	r17
    158a:	cf 93       	push	r28
    158c:	df 93       	push	r29
	int i;
	for(i=1;i<=25;i++)
    158e:	ec e0       	ldi	r30, 0x0C	; 12
    1590:	ff e0       	ldi	r31, 0x0F	; 15
		}
	}
}

void set_adj_Plots(void)		// To initialize adjacent plots of each node
{
    1592:	0f 2e       	mov	r0, r31
    1594:	fc ef       	ldi	r31, 0xFC	; 252
    1596:	cf 2e       	mov	r12, r31
    1598:	ff ef       	ldi	r31, 0xFF	; 255
    159a:	df 2e       	mov	r13, r31
    159c:	f0 2d       	mov	r31, r0
    159e:	0f 2e       	mov	r0, r31
    15a0:	f8 ef       	ldi	r31, 0xF8	; 248
    15a2:	2f 2e       	mov	r2, r31
    15a4:	ff ef       	ldi	r31, 0xFF	; 255
    15a6:	3f 2e       	mov	r3, r31
    15a8:	f0 2d       	mov	r31, r0
    15aa:	0f 2e       	mov	r0, r31
    15ac:	fd ef       	ldi	r31, 0xFD	; 253
    15ae:	4f 2e       	mov	r4, r31
    15b0:	ff ef       	ldi	r31, 0xFF	; 255
    15b2:	5f 2e       	mov	r5, r31
    15b4:	f0 2d       	mov	r31, r0
    15b6:	0f 2e       	mov	r0, r31
    15b8:	f9 ef       	ldi	r31, 0xF9	; 249
    15ba:	6f 2e       	mov	r6, r31
    15bc:	ff ef       	ldi	r31, 0xFF	; 255
    15be:	7f 2e       	mov	r7, r31
    15c0:	f0 2d       	mov	r31, r0
    15c2:	0f 2e       	mov	r0, r31
    15c4:	fe ef       	ldi	r31, 0xFE	; 254
    15c6:	af 2e       	mov	r10, r31
    15c8:	ff ef       	ldi	r31, 0xFF	; 255
    15ca:	bf 2e       	mov	r11, r31
    15cc:	f0 2d       	mov	r31, r0
    15ce:	0f 2e       	mov	r0, r31
    15d0:	fa ef       	ldi	r31, 0xFA	; 250
    15d2:	8f 2e       	mov	r8, r31
    15d4:	ff ef       	ldi	r31, 0xFF	; 255
    15d6:	9f 2e       	mov	r9, r31
    15d8:	f0 2d       	mov	r31, r0
    15da:	0b ef       	ldi	r16, 0xFB	; 251
    15dc:	1f ef       	ldi	r17, 0xFF	; 255
    15de:	ee 24       	eor	r14, r14
    15e0:	ea 94       	dec	r14
    15e2:	fe 2c       	mov	r15, r14
    15e4:	c0 e0       	ldi	r28, 0x00	; 0
    15e6:	d0 e0       	ldi	r29, 0x00	; 0
	int i;
	for(i=1;i<=25;i++)
    15e8:	21 e0       	ldi	r18, 0x01	; 1
    15ea:	30 e0       	ldi	r19, 0x00	; 0
	{
		if(i<=5)
    15ec:	26 30       	cpi	r18, 0x06	; 6
    15ee:	31 05       	cpc	r19, r1
    15f0:	ac f4       	brge	.+42     	; 0x161c <set_adj_Plots+0xb2>
		{
			if(i%5==1)
    15f2:	c9 01       	movw	r24, r18
    15f4:	65 e0       	ldi	r22, 0x05	; 5
    15f6:	70 e0       	ldi	r23, 0x00	; 0
    15f8:	0e 94 43 1c 	call	0x3886	; 0x3886 <__divmodhi4>
    15fc:	81 30       	cpi	r24, 0x01	; 1
    15fe:	91 05       	cpc	r25, r1
    1600:	19 f4       	brne	.+6      	; 0x1608 <set_adj_Plots+0x9e>
			{
				n[i].blk[2]=i;
    1602:	33 83       	std	Z+3, r19	; 0x03
    1604:	22 83       	std	Z+2, r18	; 0x02
    1606:	81 c0       	rjmp	.+258    	; 0x170a <set_adj_Plots+0x1a0>
			}
			else if(i%5==0)
    1608:	00 97       	sbiw	r24, 0x00	; 0
    160a:	19 f4       	brne	.+6      	; 0x1612 <set_adj_Plots+0xa8>
			{
				n[i].blk[1]=i-1;
    160c:	d1 83       	std	Z+1, r29	; 0x01
    160e:	c0 83       	st	Z, r28
    1610:	7c c0       	rjmp	.+248    	; 0x170a <set_adj_Plots+0x1a0>
			}
			else
			{
				n[i].blk[1]=i-1;
    1612:	d1 83       	std	Z+1, r29	; 0x01
    1614:	c0 83       	st	Z, r28
				n[i].blk[2]=i;
    1616:	33 83       	std	Z+3, r19	; 0x03
    1618:	22 83       	std	Z+2, r18	; 0x02
    161a:	77 c0       	rjmp	.+238    	; 0x170a <set_adj_Plots+0x1a0>
			}
		}
		else if(i<=10)
    161c:	2b 30       	cpi	r18, 0x0B	; 11
    161e:	31 05       	cpc	r19, r1
    1620:	ec f4       	brge	.+58     	; 0x165c <set_adj_Plots+0xf2>
		{
			if(i%5==1)
    1622:	c9 01       	movw	r24, r18
    1624:	65 e0       	ldi	r22, 0x05	; 5
    1626:	70 e0       	ldi	r23, 0x00	; 0
    1628:	0e 94 43 1c 	call	0x3886	; 0x3886 <__divmodhi4>
    162c:	81 30       	cpi	r24, 0x01	; 1
    162e:	91 05       	cpc	r25, r1
    1630:	29 f4       	brne	.+10     	; 0x163c <set_adj_Plots+0xd2>
			{
				n[i].blk[2]=i-1;
    1632:	d3 83       	std	Z+3, r29	; 0x03
    1634:	c2 83       	std	Z+2, r28	; 0x02
				n[i].blk[4]=i-5;
    1636:	d7 82       	std	Z+7, r13	; 0x07
    1638:	c6 82       	std	Z+6, r12	; 0x06
    163a:	67 c0       	rjmp	.+206    	; 0x170a <set_adj_Plots+0x1a0>
			}
			else if(i%5==0)
    163c:	00 97       	sbiw	r24, 0x00	; 0
    163e:	29 f4       	brne	.+10     	; 0x164a <set_adj_Plots+0xe0>
			{
				n[i].blk[1]=i-2;
    1640:	f1 82       	std	Z+1, r15	; 0x01
    1642:	e0 82       	st	Z, r14
				n[i].blk[3]=i-6;
    1644:	15 83       	std	Z+5, r17	; 0x05
    1646:	04 83       	std	Z+4, r16	; 0x04
    1648:	60 c0       	rjmp	.+192    	; 0x170a <set_adj_Plots+0x1a0>
			}
			else
			{
				n[i].blk[1]=i-2;
    164a:	f1 82       	std	Z+1, r15	; 0x01
    164c:	e0 82       	st	Z, r14
				n[i].blk[3]=i-6;
    164e:	15 83       	std	Z+5, r17	; 0x05
    1650:	04 83       	std	Z+4, r16	; 0x04
				n[i].blk[2]=i-1;
    1652:	d3 83       	std	Z+3, r29	; 0x03
    1654:	c2 83       	std	Z+2, r28	; 0x02
				n[i].blk[4]=i-5;
    1656:	d7 82       	std	Z+7, r13	; 0x07
    1658:	c6 82       	std	Z+6, r12	; 0x06
    165a:	57 c0       	rjmp	.+174    	; 0x170a <set_adj_Plots+0x1a0>
			}
		}
		else if(i<=15)
    165c:	20 31       	cpi	r18, 0x10	; 16
    165e:	31 05       	cpc	r19, r1
    1660:	ec f4       	brge	.+58     	; 0x169c <set_adj_Plots+0x132>
		{
			if(i%5==1)
    1662:	c9 01       	movw	r24, r18
    1664:	65 e0       	ldi	r22, 0x05	; 5
    1666:	70 e0       	ldi	r23, 0x00	; 0
    1668:	0e 94 43 1c 	call	0x3886	; 0x3886 <__divmodhi4>
    166c:	81 30       	cpi	r24, 0x01	; 1
    166e:	91 05       	cpc	r25, r1
    1670:	29 f4       	brne	.+10     	; 0x167c <set_adj_Plots+0x112>
			{
				n[i].blk[4]=i-6;
    1672:	17 83       	std	Z+7, r17	; 0x07
    1674:	06 83       	std	Z+6, r16	; 0x06
				n[i].blk[2]=i-2;
    1676:	f3 82       	std	Z+3, r15	; 0x03
    1678:	e2 82       	std	Z+2, r14	; 0x02
    167a:	47 c0       	rjmp	.+142    	; 0x170a <set_adj_Plots+0x1a0>
			}
			else if(i%5==0)
    167c:	00 97       	sbiw	r24, 0x00	; 0
    167e:	29 f4       	brne	.+10     	; 0x168a <set_adj_Plots+0x120>
			{
				n[i].blk[3]=i-7;
    1680:	95 82       	std	Z+5, r9	; 0x05
    1682:	84 82       	std	Z+4, r8	; 0x04
				n[i].blk[1]=i-3;
    1684:	b1 82       	std	Z+1, r11	; 0x01
    1686:	a0 82       	st	Z, r10
    1688:	40 c0       	rjmp	.+128    	; 0x170a <set_adj_Plots+0x1a0>
			}
			else
			{
				n[i].blk[4]=i-6;
    168a:	17 83       	std	Z+7, r17	; 0x07
    168c:	06 83       	std	Z+6, r16	; 0x06
				n[i].blk[2]=i-2;
    168e:	f3 82       	std	Z+3, r15	; 0x03
    1690:	e2 82       	std	Z+2, r14	; 0x02
				n[i].blk[3]=i-7;
    1692:	95 82       	std	Z+5, r9	; 0x05
    1694:	84 82       	std	Z+4, r8	; 0x04
				n[i].blk[1]=i-3;
    1696:	b1 82       	std	Z+1, r11	; 0x01
    1698:	a0 82       	st	Z, r10
    169a:	37 c0       	rjmp	.+110    	; 0x170a <set_adj_Plots+0x1a0>
			}
		}
		else if(i<=20)
    169c:	25 31       	cpi	r18, 0x15	; 21
    169e:	31 05       	cpc	r19, r1
    16a0:	ec f4       	brge	.+58     	; 0x16dc <set_adj_Plots+0x172>
		{
			if(i%5==1)
    16a2:	c9 01       	movw	r24, r18
    16a4:	65 e0       	ldi	r22, 0x05	; 5
    16a6:	70 e0       	ldi	r23, 0x00	; 0
    16a8:	0e 94 43 1c 	call	0x3886	; 0x3886 <__divmodhi4>
    16ac:	81 30       	cpi	r24, 0x01	; 1
    16ae:	91 05       	cpc	r25, r1
    16b0:	29 f4       	brne	.+10     	; 0x16bc <set_adj_Plots+0x152>
			{
				n[i].blk[4]=i-7;
    16b2:	97 82       	std	Z+7, r9	; 0x07
    16b4:	86 82       	std	Z+6, r8	; 0x06
				n[i].blk[2]=i-3;
    16b6:	b3 82       	std	Z+3, r11	; 0x03
    16b8:	a2 82       	std	Z+2, r10	; 0x02
    16ba:	27 c0       	rjmp	.+78     	; 0x170a <set_adj_Plots+0x1a0>
			}
			else if(i%5==0)
    16bc:	00 97       	sbiw	r24, 0x00	; 0
    16be:	29 f4       	brne	.+10     	; 0x16ca <set_adj_Plots+0x160>
			{
				n[i].blk[3]=i-8;
    16c0:	75 82       	std	Z+5, r7	; 0x05
    16c2:	64 82       	std	Z+4, r6	; 0x04
				n[i].blk[1]=i-4;
    16c4:	51 82       	std	Z+1, r5	; 0x01
    16c6:	40 82       	st	Z, r4
    16c8:	20 c0       	rjmp	.+64     	; 0x170a <set_adj_Plots+0x1a0>
			}
			else
			{
				n[i].blk[4]=i-7;
    16ca:	97 82       	std	Z+7, r9	; 0x07
    16cc:	86 82       	std	Z+6, r8	; 0x06
				n[i].blk[2]=i-3;
    16ce:	b3 82       	std	Z+3, r11	; 0x03
    16d0:	a2 82       	std	Z+2, r10	; 0x02
				n[i].blk[3]=i-8;
    16d2:	75 82       	std	Z+5, r7	; 0x05
    16d4:	64 82       	std	Z+4, r6	; 0x04
				n[i].blk[1]=i-4;
    16d6:	51 82       	std	Z+1, r5	; 0x01
    16d8:	40 82       	st	Z, r4
    16da:	17 c0       	rjmp	.+46     	; 0x170a <set_adj_Plots+0x1a0>
			}
		}
		else if(i<=25)
    16dc:	2a 31       	cpi	r18, 0x1A	; 26
    16de:	31 05       	cpc	r19, r1
    16e0:	a4 f4       	brge	.+40     	; 0x170a <set_adj_Plots+0x1a0>
		{
			if(i%5==1)
    16e2:	c9 01       	movw	r24, r18
    16e4:	65 e0       	ldi	r22, 0x05	; 5
    16e6:	70 e0       	ldi	r23, 0x00	; 0
    16e8:	0e 94 43 1c 	call	0x3886	; 0x3886 <__divmodhi4>
    16ec:	81 30       	cpi	r24, 0x01	; 1
    16ee:	91 05       	cpc	r25, r1
    16f0:	19 f4       	brne	.+6      	; 0x16f8 <set_adj_Plots+0x18e>
			{
				n[i].blk[4]=i-8;
    16f2:	77 82       	std	Z+7, r7	; 0x07
    16f4:	66 82       	std	Z+6, r6	; 0x06
    16f6:	09 c0       	rjmp	.+18     	; 0x170a <set_adj_Plots+0x1a0>
			}
			else if(i%5==0)
    16f8:	00 97       	sbiw	r24, 0x00	; 0
    16fa:	19 f4       	brne	.+6      	; 0x1702 <set_adj_Plots+0x198>
			{
				n[i].blk[3]=i-9;
    16fc:	35 82       	std	Z+5, r3	; 0x05
    16fe:	24 82       	std	Z+4, r2	; 0x04
    1700:	04 c0       	rjmp	.+8      	; 0x170a <set_adj_Plots+0x1a0>
			}
			else
			{
				n[i].blk[4]=i-8;
    1702:	77 82       	std	Z+7, r7	; 0x07
    1704:	66 82       	std	Z+6, r6	; 0x06
				n[i].blk[3]=i-9;
    1706:	35 82       	std	Z+5, r3	; 0x05
    1708:	24 82       	std	Z+4, r2	; 0x04
}

void set_adj_Plots(void)		// To initialize adjacent plots of each node
{
	int i;
	for(i=1;i<=25;i++)
    170a:	2f 5f       	subi	r18, 0xFF	; 255
    170c:	3f 4f       	sbci	r19, 0xFF	; 255
    170e:	21 96       	adiw	r28, 0x01	; 1
    1710:	76 96       	adiw	r30, 0x16	; 22
    1712:	08 94       	sec
    1714:	e1 1c       	adc	r14, r1
    1716:	f1 1c       	adc	r15, r1
    1718:	0f 5f       	subi	r16, 0xFF	; 255
    171a:	1f 4f       	sbci	r17, 0xFF	; 255
    171c:	08 94       	sec
    171e:	81 1c       	adc	r8, r1
    1720:	91 1c       	adc	r9, r1
    1722:	08 94       	sec
    1724:	a1 1c       	adc	r10, r1
    1726:	b1 1c       	adc	r11, r1
    1728:	08 94       	sec
    172a:	61 1c       	adc	r6, r1
    172c:	71 1c       	adc	r7, r1
    172e:	08 94       	sec
    1730:	41 1c       	adc	r4, r1
    1732:	51 1c       	adc	r5, r1
    1734:	08 94       	sec
    1736:	21 1c       	adc	r2, r1
    1738:	31 1c       	adc	r3, r1
    173a:	08 94       	sec
    173c:	c1 1c       	adc	r12, r1
    173e:	d1 1c       	adc	r13, r1
    1740:	2a 31       	cpi	r18, 0x1A	; 26
    1742:	31 05       	cpc	r19, r1
    1744:	09 f0       	breq	.+2      	; 0x1748 <set_adj_Plots+0x1de>
    1746:	52 cf       	rjmp	.-348    	; 0x15ec <set_adj_Plots+0x82>
				n[i].blk[4]=i-8;
				n[i].blk[3]=i-9;
			}
		}
	}
}
    1748:	df 91       	pop	r29
    174a:	cf 91       	pop	r28
    174c:	1f 91       	pop	r17
    174e:	0f 91       	pop	r16
    1750:	ff 90       	pop	r15
    1752:	ef 90       	pop	r14
    1754:	df 90       	pop	r13
    1756:	cf 90       	pop	r12
    1758:	bf 90       	pop	r11
    175a:	af 90       	pop	r10
    175c:	9f 90       	pop	r9
    175e:	8f 90       	pop	r8
    1760:	7f 90       	pop	r7
    1762:	6f 90       	pop	r6
    1764:	5f 90       	pop	r5
    1766:	4f 90       	pop	r4
    1768:	3f 90       	pop	r3
    176a:	2f 90       	pop	r2
    176c:	08 95       	ret

0000176e <set_adj_node>:

void set_adj_node(void)			// To initialize adjacent nodes of each node
{
    176e:	6f 92       	push	r6
    1770:	7f 92       	push	r7
    1772:	8f 92       	push	r8
    1774:	9f 92       	push	r9
    1776:	af 92       	push	r10
    1778:	bf 92       	push	r11
    177a:	cf 92       	push	r12
    177c:	df 92       	push	r13
    177e:	ef 92       	push	r14
    1780:	ff 92       	push	r15
    1782:	0f 93       	push	r16
    1784:	1f 93       	push	r17
    1786:	cf 93       	push	r28
    1788:	df 93       	push	r29
    178a:	0f 2e       	mov	r0, r31
    178c:	f2 ed       	ldi	r31, 0xD2	; 210
    178e:	af 2e       	mov	r10, r31
    1790:	f6 e1       	ldi	r31, 0x16	; 22
    1792:	bf 2e       	mov	r11, r31
    1794:	f0 2d       	mov	r31, r0
    1796:	0f 2e       	mov	r0, r31
    1798:	f4 e0       	ldi	r31, 0x04	; 4
    179a:	cf 2e       	mov	r12, r31
    179c:	ff e0       	ldi	r31, 0x0F	; 15
    179e:	df 2e       	mov	r13, r31
    17a0:	f0 2d       	mov	r31, r0
    17a2:	c2 e0       	ldi	r28, 0x02	; 2
    17a4:	d0 e0       	ldi	r29, 0x00	; 0
    17a6:	ee 24       	eor	r14, r14
    17a8:	ff 24       	eor	r15, r15
    17aa:	e3 94       	inc	r14
    17ac:	00 e0       	ldi	r16, 0x00	; 0
    17ae:	10 e0       	ldi	r17, 0x00	; 0
		}
		if(i<=20)
		{
			n[i].adjn[2]=i+5;
		}
		if((i%5 != 1) && ((i-1) > 0))
    17b0:	0f 2e       	mov	r0, r31
    17b2:	f5 e0       	ldi	r31, 0x05	; 5
    17b4:	8f 2e       	mov	r8, r31
    17b6:	99 24       	eor	r9, r9
    17b8:	f0 2d       	mov	r31, r0
    int i;
	for(i=1;i<=25;i++)
	{
		if(i>5)
		{
			n[i].adjn[1]=i-5;
    17ba:	0f 2e       	mov	r0, r31
    17bc:	fa ee       	ldi	r31, 0xEA	; 234
    17be:	6f 2e       	mov	r6, r31
    17c0:	fe e0       	ldi	r31, 0x0E	; 14
    17c2:	7f 2e       	mov	r7, r31
    17c4:	f0 2d       	mov	r31, r0
    17c6:	2a c0       	rjmp	.+84     	; 0x181c <set_adj_node+0xae>
void set_adj_node(void)			// To initialize adjacent nodes of each node
{
    int i;
	for(i=1;i<=25;i++)
	{
		if(i>5)
    17c8:	46 30       	cpi	r20, 0x06	; 6
    17ca:	51 05       	cpc	r21, r1
    17cc:	cc f0       	brlt	.+50     	; 0x1800 <set_adj_node+0x92>
		{
			n[i].adjn[1]=i-5;
    17ce:	ca 01       	movw	r24, r20
    17d0:	88 0f       	add	r24, r24
    17d2:	99 1f       	adc	r25, r25
    17d4:	84 0f       	add	r24, r20
    17d6:	95 1f       	adc	r25, r21
    17d8:	9c 01       	movw	r18, r24
    17da:	22 0f       	add	r18, r18
    17dc:	33 1f       	adc	r19, r19
    17de:	22 0f       	add	r18, r18
    17e0:	33 1f       	adc	r19, r19
    17e2:	22 0f       	add	r18, r18
    17e4:	33 1f       	adc	r19, r19
    17e6:	b9 01       	movw	r22, r18
    17e8:	68 1b       	sub	r22, r24
    17ea:	79 0b       	sbc	r23, r25
    17ec:	cb 01       	movw	r24, r22
    17ee:	84 0f       	add	r24, r20
    17f0:	95 1f       	adc	r25, r21
    17f2:	f3 01       	movw	r30, r6
    17f4:	e8 0f       	add	r30, r24
    17f6:	f9 1f       	adc	r31, r25
			}
		}
	}
}

void set_adj_node(void)			// To initialize adjacent nodes of each node
    17f8:	c8 01       	movw	r24, r16
    17fa:	03 97       	sbiw	r24, 0x03	; 3
    int i;
	for(i=1;i<=25;i++)
	{
		if(i>5)
		{
			n[i].adjn[1]=i-5;
    17fc:	93 83       	std	Z+3, r25	; 0x03
    17fe:	82 83       	std	Z+2, r24	; 0x02
    1800:	0f 5f       	subi	r16, 0xFF	; 255
    1802:	1f 4f       	sbci	r17, 0xFF	; 255
    1804:	08 94       	sec
    1806:	e1 1c       	adc	r14, r1
    1808:	f1 1c       	adc	r15, r1
    180a:	21 96       	adiw	r28, 0x01	; 1
    180c:	82 e0       	ldi	r24, 0x02	; 2
    180e:	90 e0       	ldi	r25, 0x00	; 0
    1810:	a8 0e       	add	r10, r24
    1812:	b9 1e       	adc	r11, r25
    1814:	e6 e1       	ldi	r30, 0x16	; 22
    1816:	f0 e0       	ldi	r31, 0x00	; 0
    1818:	ce 0e       	add	r12, r30
    181a:	df 1e       	adc	r13, r31
    181c:	97 01       	movw	r18, r14
		}
		if(i<=20)
    181e:	f5 e1       	ldi	r31, 0x15	; 21
    1820:	ef 16       	cp	r14, r31
    1822:	f1 04       	cpc	r15, r1
    1824:	2c f4       	brge	.+10     	; 0x1830 <set_adj_node+0xc2>
			}
		}
	}
}

void set_adj_node(void)			// To initialize adjacent nodes of each node
    1826:	c8 01       	movw	r24, r16
    1828:	06 96       	adiw	r24, 0x06	; 6
		{
			n[i].adjn[1]=i-5;
		}
		if(i<=20)
		{
			n[i].adjn[2]=i+5;
    182a:	f6 01       	movw	r30, r12
    182c:	91 83       	std	Z+1, r25	; 0x01
    182e:	80 83       	st	Z, r24
		}
		if((i%5 != 1) && ((i-1) > 0))
    1830:	c9 01       	movw	r24, r18
    1832:	b4 01       	movw	r22, r8
    1834:	0e 94 43 1c 	call	0x3886	; 0x3886 <__divmodhi4>
    1838:	81 30       	cpi	r24, 0x01	; 1
    183a:	91 05       	cpc	r25, r1
    183c:	41 f0       	breq	.+16     	; 0x184e <set_adj_node+0xe0>
    183e:	10 16       	cp	r1, r16
    1840:	11 06       	cpc	r1, r17
    1842:	1c f4       	brge	.+6      	; 0x184a <set_adj_node+0xdc>
		{
			n[i].adjn[3]=i-1;
    1844:	f6 01       	movw	r30, r12
    1846:	13 83       	std	Z+3, r17	; 0x03
    1848:	02 83       	std	Z+2, r16	; 0x02
		}
		if((i%5 != 0) && ((i+1) <= 25))
    184a:	00 97       	sbiw	r24, 0x00	; 0
    184c:	59 f0       	breq	.+22     	; 0x1864 <set_adj_node+0xf6>
    184e:	ae 01       	movw	r20, r28
    1850:	ca 31       	cpi	r28, 0x1A	; 26
    1852:	d1 05       	cpc	r29, r1
    1854:	84 f4       	brge	.+32     	; 0x1876 <set_adj_node+0x108>
		{
			n[i].adjn[4]=i+1;
    1856:	f6 01       	movw	r30, r12
    1858:	d5 83       	std	Z+5, r29	; 0x05
    185a:	c4 83       	std	Z+4, r28	; 0x04
		}
		v[i]=0;
    185c:	f5 01       	movw	r30, r10
    185e:	11 82       	std	Z+1, r1	; 0x01
    1860:	10 82       	st	Z, r1
    1862:	b2 cf       	rjmp	.-156    	; 0x17c8 <set_adj_node+0x5a>
    1864:	f5 01       	movw	r30, r10
    1866:	11 82       	std	Z+1, r1	; 0x01
    1868:	10 82       	st	Z, r1
}

void set_adj_node(void)			// To initialize adjacent nodes of each node
{
    int i;
	for(i=1;i<=25;i++)
    186a:	ae 01       	movw	r20, r28
    186c:	ca 31       	cpi	r28, 0x1A	; 26
    186e:	d1 05       	cpc	r29, r1
    1870:	0c f4       	brge	.+2      	; 0x1874 <set_adj_node+0x106>
    1872:	aa cf       	rjmp	.-172    	; 0x17c8 <set_adj_node+0x5a>
    1874:	07 c0       	rjmp	.+14     	; 0x1884 <set_adj_node+0x116>
		}
		if((i%5 != 0) && ((i+1) <= 25))
		{
			n[i].adjn[4]=i+1;
		}
		v[i]=0;
    1876:	f9 01       	movw	r30, r18
    1878:	ee 0f       	add	r30, r30
    187a:	ff 1f       	adc	r31, r31
    187c:	e0 53       	subi	r30, 0x30	; 48
    187e:	f9 4e       	sbci	r31, 0xE9	; 233
    1880:	11 82       	std	Z+1, r1	; 0x01
    1882:	10 82       	st	Z, r1
	}
}
    1884:	df 91       	pop	r29
    1886:	cf 91       	pop	r28
    1888:	1f 91       	pop	r17
    188a:	0f 91       	pop	r16
    188c:	ff 90       	pop	r15
    188e:	ef 90       	pop	r14
    1890:	df 90       	pop	r13
    1892:	cf 90       	pop	r12
    1894:	bf 90       	pop	r11
    1896:	af 90       	pop	r10
    1898:	9f 90       	pop	r9
    189a:	8f 90       	pop	r8
    189c:	7f 90       	pop	r7
    189e:	6f 90       	pop	r6
    18a0:	08 95       	ret

000018a2 <updatePlot>:

void updatePlot(void)			// To update the status of plot, whether it is visited or not
{
    18a2:	4f 92       	push	r4
    18a4:	5f 92       	push	r5
    18a6:	6f 92       	push	r6
    18a8:	7f 92       	push	r7
    18aa:	8f 92       	push	r8
    18ac:	9f 92       	push	r9
    18ae:	af 92       	push	r10
    18b0:	bf 92       	push	r11
    18b2:	cf 92       	push	r12
    18b4:	df 92       	push	r13
    18b6:	ef 92       	push	r14
    18b8:	ff 92       	push	r15
    18ba:	0f 93       	push	r16
    18bc:	1f 93       	push	r17
    18be:	cf 93       	push	r28
    18c0:	df 93       	push	r29
	int ar,br,res,i,j;
	
	for(i=1;i<=16;i++)
    18c2:	0e ef       	ldi	r16, 0xFE	; 254
    18c4:	1c e0       	ldi	r17, 0x0C	; 12
    18c6:	a1 e0       	ldi	r26, 0x01	; 1
    18c8:	b0 e0       	ldi	r27, 0x00	; 0
		}
		v[i]=0;
	}
}

void updatePlot(void)			// To update the status of plot, whether it is visited or not
    18ca:	ee 24       	eor	r14, r14
    18cc:	ff 24       	eor	r15, r15
    18ce:	68 94       	set
    18d0:	e2 f8       	bld	r14, 2
    18d2:	cc 24       	eor	r12, r12
    18d4:	dd 24       	eor	r13, r13
			ar=b[i].st[j];
			br=b[i].ed[j];

			if(ar != 0 && br != 0)
			{
				res += path[ar][br];
    18d6:	0f 2e       	mov	r0, r31
    18d8:	fa e1       	ldi	r31, 0x1A	; 26
    18da:	af 2e       	mov	r10, r31
    18dc:	bb 24       	eor	r11, r11
    18de:	f0 2d       	mov	r31, r0
    18e0:	0f 2e       	mov	r0, r31
    18e2:	f2 e7       	ldi	r31, 0x72	; 114
    18e4:	8f 2e       	mov	r8, r31
    18e6:	f7 e0       	ldi	r31, 0x07	; 7
    18e8:	9f 2e       	mov	r9, r31
    18ea:	f0 2d       	mov	r31, r0
			}
		}
		if(res >= 1)
		{
			b[i].pstatus=1;
    18ec:	66 24       	eor	r6, r6
    18ee:	77 24       	eor	r7, r7
    18f0:	63 94       	inc	r6
    18f2:	2b c0       	rjmp	.+86     	; 0x194a <updatePlot+0xa8>
	for(i=1;i<=16;i++)
	{
	    res=0;
		for(j=1;j<=4;j++)
		{
			ar=b[i].st[j];
    18f4:	81 91       	ld	r24, Z+
    18f6:	91 91       	ld	r25, Z+
			br=b[i].ed[j];
    18f8:	60 85       	ldd	r22, Z+8	; 0x08
    18fa:	71 85       	ldd	r23, Z+9	; 0x09

			if(ar != 0 && br != 0)
    18fc:	00 97       	sbiw	r24, 0x00	; 0
    18fe:	b1 f0       	breq	.+44     	; 0x192c <updatePlot+0x8a>
    1900:	61 15       	cp	r22, r1
    1902:	71 05       	cpc	r23, r1
    1904:	99 f0       	breq	.+38     	; 0x192c <updatePlot+0x8a>
			{
				res += path[ar][br];
    1906:	8a 9d       	mul	r24, r10
    1908:	90 01       	movw	r18, r0
    190a:	8b 9d       	mul	r24, r11
    190c:	30 0d       	add	r19, r0
    190e:	9a 9d       	mul	r25, r10
    1910:	30 0d       	add	r19, r0
    1912:	11 24       	eor	r1, r1
    1914:	c9 01       	movw	r24, r18
    1916:	86 0f       	add	r24, r22
    1918:	97 1f       	adc	r25, r23
    191a:	88 0f       	add	r24, r24
    191c:	99 1f       	adc	r25, r25
    191e:	88 0d       	add	r24, r8
    1920:	99 1d       	adc	r25, r9
    1922:	ec 01       	movw	r28, r24
    1924:	88 81       	ld	r24, Y
    1926:	99 81       	ldd	r25, Y+1	; 0x01
    1928:	48 0e       	add	r4, r24
    192a:	59 1e       	adc	r5, r25
    192c:	41 50       	subi	r20, 0x01	; 1
    192e:	50 40       	sbci	r21, 0x00	; 0
	int ar,br,res,i,j;
	
	for(i=1;i<=16;i++)
	{
	    res=0;
		for(j=1;j<=4;j++)
    1930:	09 f7       	brne	.-62     	; 0x18f4 <updatePlot+0x52>
			if(ar != 0 && br != 0)
			{
				res += path[ar][br];
			}
		}
		if(res >= 1)
    1932:	14 14       	cp	r1, r4
    1934:	15 04       	cpc	r1, r5
    1936:	1c f4       	brge	.+6      	; 0x193e <updatePlot+0x9c>
		{
			b[i].pstatus=1;
    1938:	f8 01       	movw	r30, r16
    193a:	71 82       	std	Z+1, r7	; 0x01
    193c:	60 82       	st	Z, r6

void updatePlot(void)			// To update the status of plot, whether it is visited or not
{
	int ar,br,res,i,j;
	
	for(i=1;i<=16;i++)
    193e:	11 96       	adiw	r26, 0x01	; 1
    1940:	00 5e       	subi	r16, 0xE0	; 224
    1942:	1f 4f       	sbci	r17, 0xFF	; 255
    1944:	a1 31       	cpi	r26, 0x11	; 17
    1946:	b1 05       	cpc	r27, r1
    1948:	79 f0       	breq	.+30     	; 0x1968 <updatePlot+0xc6>
		}
		v[i]=0;
	}
}

void updatePlot(void)			// To update the status of plot, whether it is visited or not
    194a:	cd 01       	movw	r24, r26
    194c:	88 0f       	add	r24, r24
    194e:	99 1f       	adc	r25, r25
    1950:	82 95       	swap	r24
    1952:	92 95       	swap	r25
    1954:	90 7f       	andi	r25, 0xF0	; 240
    1956:	98 27       	eor	r25, r24
    1958:	80 7f       	andi	r24, 0xF0	; 240
    195a:	98 27       	eor	r25, r24
    195c:	fc 01       	movw	r30, r24
    195e:	e4 53       	subi	r30, 0x34	; 52
    1960:	f3 4f       	sbci	r31, 0xF3	; 243
    1962:	a7 01       	movw	r20, r14
    1964:	26 01       	movw	r4, r12
    1966:	c6 cf       	rjmp	.-116    	; 0x18f4 <updatePlot+0x52>
		{
			b[i].pstatus=1;
			//plot[j]=1;
		}
	}
}
    1968:	df 91       	pop	r29
    196a:	cf 91       	pop	r28
    196c:	1f 91       	pop	r17
    196e:	0f 91       	pop	r16
    1970:	ff 90       	pop	r15
    1972:	ef 90       	pop	r14
    1974:	df 90       	pop	r13
    1976:	cf 90       	pop	r12
    1978:	bf 90       	pop	r11
    197a:	af 90       	pop	r10
    197c:	9f 90       	pop	r9
    197e:	8f 90       	pop	r8
    1980:	7f 90       	pop	r7
    1982:	6f 90       	pop	r6
    1984:	5f 90       	pop	r5
    1986:	4f 90       	pop	r4
    1988:	08 95       	ret

0000198a <update>:

void update(int an,int bn)		// Update the paths (midpoints) for visiting
{
    198a:	cf 93       	push	r28
    198c:	df 93       	push	r29
    198e:	9c 01       	movw	r18, r24
	prv_node=an;
    1990:	90 93 6f 07 	sts	0x076F, r25
    1994:	80 93 6e 07 	sts	0x076E, r24
	crt_node=bn;
    1998:	70 93 4d 07 	sts	0x074D, r23
    199c:	60 93 4c 07 	sts	0x074C, r22
	path[an][bn]=path[bn][an]=1;
    19a0:	aa e1       	ldi	r26, 0x1A	; 26
    19a2:	b0 e0       	ldi	r27, 0x00	; 0
    19a4:	6a 9f       	mul	r22, r26
    19a6:	f0 01       	movw	r30, r0
    19a8:	6b 9f       	mul	r22, r27
    19aa:	f0 0d       	add	r31, r0
    19ac:	7a 9f       	mul	r23, r26
    19ae:	f0 0d       	add	r31, r0
    19b0:	11 24       	eor	r1, r1
    19b2:	e8 0f       	add	r30, r24
    19b4:	f9 1f       	adc	r31, r25
    19b6:	c2 e7       	ldi	r28, 0x72	; 114
    19b8:	d7 e0       	ldi	r29, 0x07	; 7
    19ba:	ee 0f       	add	r30, r30
    19bc:	ff 1f       	adc	r31, r31
    19be:	ec 0f       	add	r30, r28
    19c0:	fd 1f       	adc	r31, r29
    19c2:	41 e0       	ldi	r20, 0x01	; 1
    19c4:	50 e0       	ldi	r21, 0x00	; 0
    19c6:	51 83       	std	Z+1, r21	; 0x01
    19c8:	40 83       	st	Z, r20
    19ca:	2a 9f       	mul	r18, r26
    19cc:	c0 01       	movw	r24, r0
    19ce:	2b 9f       	mul	r18, r27
    19d0:	90 0d       	add	r25, r0
    19d2:	3a 9f       	mul	r19, r26
    19d4:	90 0d       	add	r25, r0
    19d6:	11 24       	eor	r1, r1
    19d8:	86 0f       	add	r24, r22
    19da:	97 1f       	adc	r25, r23
    19dc:	88 0f       	add	r24, r24
    19de:	99 1f       	adc	r25, r25
    19e0:	c8 0f       	add	r28, r24
    19e2:	d9 1f       	adc	r29, r25
    19e4:	59 83       	std	Y+1, r21	; 0x01
    19e6:	48 83       	st	Y, r20
	updatePlot();
    19e8:	0e 94 51 0c 	call	0x18a2	; 0x18a2 <updatePlot>
}
    19ec:	df 91       	pop	r29
    19ee:	cf 91       	pop	r28
    19f0:	08 95       	ret

000019f2 <get_row>:

int get_row(int plot)
{
	if (plot % 4 == 0 )
    19f2:	9c 01       	movw	r18, r24
    19f4:	23 70       	andi	r18, 0x03	; 3
    19f6:	30 70       	andi	r19, 0x00	; 0
    19f8:	21 15       	cp	r18, r1
    19fa:	31 05       	cpc	r19, r1
    19fc:	59 f4       	brne	.+22     	; 0x1a14 <get_row+0x22>
		return (plot / 4);
    19fe:	9c 01       	movw	r18, r24
    1a00:	99 23       	and	r25, r25
    1a02:	14 f4       	brge	.+4      	; 0x1a08 <get_row+0x16>
    1a04:	2d 5f       	subi	r18, 0xFD	; 253
    1a06:	3f 4f       	sbci	r19, 0xFF	; 255
    1a08:	c9 01       	movw	r24, r18
    1a0a:	95 95       	asr	r25
    1a0c:	87 95       	ror	r24
    1a0e:	95 95       	asr	r25
    1a10:	87 95       	ror	r24
    1a12:	08 95       	ret
	else
		return ((plot / 4) + 1);
    1a14:	9c 01       	movw	r18, r24
    1a16:	99 23       	and	r25, r25
    1a18:	14 f4       	brge	.+4      	; 0x1a1e <get_row+0x2c>
    1a1a:	2d 5f       	subi	r18, 0xFD	; 253
    1a1c:	3f 4f       	sbci	r19, 0xFF	; 255
    1a1e:	c9 01       	movw	r24, r18
    1a20:	95 95       	asr	r25
    1a22:	87 95       	ror	r24
    1a24:	95 95       	asr	r25
    1a26:	87 95       	ror	r24
    1a28:	01 96       	adiw	r24, 0x01	; 1
}
    1a2a:	08 95       	ret

00001a2c <get_col>:

int get_col(int plot)
{
	unsigned char col = (plot % 4);
    1a2c:	64 e0       	ldi	r22, 0x04	; 4
    1a2e:	70 e0       	ldi	r23, 0x00	; 0
    1a30:	0e 94 43 1c 	call	0x3886	; 0x3886 <__divmodhi4>
	if(col == 0)
    1a34:	88 23       	and	r24, r24
    1a36:	09 f4       	brne	.+2      	; 0x1a3a <get_col+0xe>
		col = 4;
    1a38:	84 e0       	ldi	r24, 0x04	; 4

	return col;
}
    1a3a:	90 e0       	ldi	r25, 0x00	; 0
    1a3c:	08 95       	ret

00001a3e <get_dir>:

int get_dir(int cnode,int nnode) // To get the direction of nnode fron cnode
{
	switch(crrt_dir)
    1a3e:	20 91 4a 07 	lds	r18, 0x074A
    1a42:	30 91 4b 07 	lds	r19, 0x074B
    1a46:	22 30       	cpi	r18, 0x02	; 2
    1a48:	31 05       	cpc	r19, r1
    1a4a:	d1 f1       	breq	.+116    	; 0x1ac0 <get_dir+0x82>
    1a4c:	23 30       	cpi	r18, 0x03	; 3
    1a4e:	31 05       	cpc	r19, r1
    1a50:	2c f4       	brge	.+10     	; 0x1a5c <get_dir+0x1e>
    1a52:	21 30       	cpi	r18, 0x01	; 1
    1a54:	31 05       	cpc	r19, r1
    1a56:	09 f0       	breq	.+2      	; 0x1a5a <get_dir+0x1c>
    1a58:	ae c0       	rjmp	.+348    	; 0x1bb6 <get_dir+0x178>
    1a5a:	09 c0       	rjmp	.+18     	; 0x1a6e <get_dir+0x30>
    1a5c:	23 30       	cpi	r18, 0x03	; 3
    1a5e:	31 05       	cpc	r19, r1
    1a60:	09 f4       	brne	.+2      	; 0x1a64 <get_dir+0x26>
    1a62:	57 c0       	rjmp	.+174    	; 0x1b12 <get_dir+0xd4>
    1a64:	24 30       	cpi	r18, 0x04	; 4
    1a66:	31 05       	cpc	r19, r1
    1a68:	09 f0       	breq	.+2      	; 0x1a6c <get_dir+0x2e>
    1a6a:	a5 c0       	rjmp	.+330    	; 0x1bb6 <get_dir+0x178>
    1a6c:	7c c0       	rjmp	.+248    	; 0x1b66 <get_dir+0x128>
	{
		case 1:
		switch(cnode-nnode)
    1a6e:	86 1b       	sub	r24, r22
    1a70:	97 0b       	sbc	r25, r23
    1a72:	2f ef       	ldi	r18, 0xFF	; 255
    1a74:	8f 3f       	cpi	r24, 0xFF	; 255
    1a76:	92 07       	cpc	r25, r18
    1a78:	d1 f0       	breq	.+52     	; 0x1aae <get_dir+0x70>
    1a7a:	81 30       	cpi	r24, 0x01	; 1
    1a7c:	91 05       	cpc	r25, r1
    1a7e:	71 f0       	breq	.+28     	; 0x1a9c <get_dir+0x5e>
    1a80:	2f ef       	ldi	r18, 0xFF	; 255
    1a82:	8b 3f       	cpi	r24, 0xFB	; 251
    1a84:	92 07       	cpc	r25, r18
    1a86:	09 f0       	breq	.+2      	; 0x1a8a <get_dir+0x4c>
    1a88:	99 c0       	rjmp	.+306    	; 0x1bbc <get_dir+0x17e>
		{
			case 5:return 0;
			break;
			case -5:crrt_dir = 2;return 180;
    1a8a:	82 e0       	ldi	r24, 0x02	; 2
    1a8c:	90 e0       	ldi	r25, 0x00	; 0
    1a8e:	90 93 4b 07 	sts	0x074B, r25
    1a92:	80 93 4a 07 	sts	0x074A, r24
    1a96:	84 eb       	ldi	r24, 0xB4	; 180
    1a98:	90 e0       	ldi	r25, 0x00	; 0
    1a9a:	08 95       	ret
			break;
			case 1:crrt_dir = 3;return 270;
    1a9c:	83 e0       	ldi	r24, 0x03	; 3
    1a9e:	90 e0       	ldi	r25, 0x00	; 0
    1aa0:	90 93 4b 07 	sts	0x074B, r25
    1aa4:	80 93 4a 07 	sts	0x074A, r24
    1aa8:	8e e0       	ldi	r24, 0x0E	; 14
    1aaa:	91 e0       	ldi	r25, 0x01	; 1
    1aac:	08 95       	ret
			break;
			case -1:crrt_dir = 4;return 90;
    1aae:	84 e0       	ldi	r24, 0x04	; 4
    1ab0:	90 e0       	ldi	r25, 0x00	; 0
    1ab2:	90 93 4b 07 	sts	0x074B, r25
    1ab6:	80 93 4a 07 	sts	0x074A, r24
    1aba:	8a e5       	ldi	r24, 0x5A	; 90
    1abc:	90 e0       	ldi	r25, 0x00	; 0
    1abe:	08 95       	ret
			break;
			default:return 0;
		}
		break;
		case 2:
		switch(cnode-nnode)
    1ac0:	86 1b       	sub	r24, r22
    1ac2:	97 0b       	sbc	r25, r23
    1ac4:	81 30       	cpi	r24, 0x01	; 1
    1ac6:	91 05       	cpc	r25, r1
    1ac8:	91 f0       	breq	.+36     	; 0x1aee <get_dir+0xb0>
    1aca:	85 30       	cpi	r24, 0x05	; 5
    1acc:	91 05       	cpc	r25, r1
    1ace:	31 f0       	breq	.+12     	; 0x1adc <get_dir+0x9e>
    1ad0:	2f ef       	ldi	r18, 0xFF	; 255
    1ad2:	8f 3f       	cpi	r24, 0xFF	; 255
    1ad4:	92 07       	cpc	r25, r18
    1ad6:	09 f0       	breq	.+2      	; 0x1ada <get_dir+0x9c>
    1ad8:	74 c0       	rjmp	.+232    	; 0x1bc2 <get_dir+0x184>
    1ada:	12 c0       	rjmp	.+36     	; 0x1b00 <get_dir+0xc2>
		{
			case 5:crrt_dir = 1;return 180;
    1adc:	81 e0       	ldi	r24, 0x01	; 1
    1ade:	90 e0       	ldi	r25, 0x00	; 0
    1ae0:	90 93 4b 07 	sts	0x074B, r25
    1ae4:	80 93 4a 07 	sts	0x074A, r24
    1ae8:	84 eb       	ldi	r24, 0xB4	; 180
    1aea:	90 e0       	ldi	r25, 0x00	; 0
    1aec:	08 95       	ret
			break;
			case -5:return 0;
			break;
			case 1:crrt_dir = 3;return 90;
    1aee:	83 e0       	ldi	r24, 0x03	; 3
    1af0:	90 e0       	ldi	r25, 0x00	; 0
    1af2:	90 93 4b 07 	sts	0x074B, r25
    1af6:	80 93 4a 07 	sts	0x074A, r24
    1afa:	8a e5       	ldi	r24, 0x5A	; 90
    1afc:	90 e0       	ldi	r25, 0x00	; 0
    1afe:	08 95       	ret
			break;
			case -1:crrt_dir = 4;return 270;
    1b00:	84 e0       	ldi	r24, 0x04	; 4
    1b02:	90 e0       	ldi	r25, 0x00	; 0
    1b04:	90 93 4b 07 	sts	0x074B, r25
    1b08:	80 93 4a 07 	sts	0x074A, r24
    1b0c:	8e e0       	ldi	r24, 0x0E	; 14
    1b0e:	91 e0       	ldi	r25, 0x01	; 1
    1b10:	08 95       	ret
			break;
			default:return 0;
		}
		break;
		case 3:
		switch(cnode-nnode)
    1b12:	86 1b       	sub	r24, r22
    1b14:	97 0b       	sbc	r25, r23
    1b16:	2f ef       	ldi	r18, 0xFF	; 255
    1b18:	8f 3f       	cpi	r24, 0xFF	; 255
    1b1a:	92 07       	cpc	r25, r18
    1b1c:	d9 f0       	breq	.+54     	; 0x1b54 <get_dir+0x116>
    1b1e:	85 30       	cpi	r24, 0x05	; 5
    1b20:	91 05       	cpc	r25, r1
    1b22:	31 f0       	breq	.+12     	; 0x1b30 <get_dir+0xf2>
    1b24:	2f ef       	ldi	r18, 0xFF	; 255
    1b26:	8b 3f       	cpi	r24, 0xFB	; 251
    1b28:	92 07       	cpc	r25, r18
    1b2a:	09 f0       	breq	.+2      	; 0x1b2e <get_dir+0xf0>
    1b2c:	4d c0       	rjmp	.+154    	; 0x1bc8 <get_dir+0x18a>
    1b2e:	09 c0       	rjmp	.+18     	; 0x1b42 <get_dir+0x104>
		{
			case 5:crrt_dir = 1;return 90;
    1b30:	81 e0       	ldi	r24, 0x01	; 1
    1b32:	90 e0       	ldi	r25, 0x00	; 0
    1b34:	90 93 4b 07 	sts	0x074B, r25
    1b38:	80 93 4a 07 	sts	0x074A, r24
    1b3c:	8a e5       	ldi	r24, 0x5A	; 90
    1b3e:	90 e0       	ldi	r25, 0x00	; 0
    1b40:	08 95       	ret
			break;
			case -5:crrt_dir = 2;return 270;
    1b42:	82 e0       	ldi	r24, 0x02	; 2
    1b44:	90 e0       	ldi	r25, 0x00	; 0
    1b46:	90 93 4b 07 	sts	0x074B, r25
    1b4a:	80 93 4a 07 	sts	0x074A, r24
    1b4e:	8e e0       	ldi	r24, 0x0E	; 14
    1b50:	91 e0       	ldi	r25, 0x01	; 1
    1b52:	08 95       	ret
			break;
			case 1:return 0;
			break;
			case -1:crrt_dir = 4;return 180;
    1b54:	84 e0       	ldi	r24, 0x04	; 4
    1b56:	90 e0       	ldi	r25, 0x00	; 0
    1b58:	90 93 4b 07 	sts	0x074B, r25
    1b5c:	80 93 4a 07 	sts	0x074A, r24
    1b60:	84 eb       	ldi	r24, 0xB4	; 180
    1b62:	90 e0       	ldi	r25, 0x00	; 0
    1b64:	08 95       	ret
			break;
			default:return 0;
		}
		break;
		case 4:
		switch(cnode-nnode)
    1b66:	86 1b       	sub	r24, r22
    1b68:	97 0b       	sbc	r25, r23
    1b6a:	81 30       	cpi	r24, 0x01	; 1
    1b6c:	91 05       	cpc	r25, r1
    1b6e:	d1 f0       	breq	.+52     	; 0x1ba4 <get_dir+0x166>
    1b70:	85 30       	cpi	r24, 0x05	; 5
    1b72:	91 05       	cpc	r25, r1
    1b74:	29 f0       	breq	.+10     	; 0x1b80 <get_dir+0x142>
    1b76:	2f ef       	ldi	r18, 0xFF	; 255
    1b78:	8b 3f       	cpi	r24, 0xFB	; 251
    1b7a:	92 07       	cpc	r25, r18
    1b7c:	41 f5       	brne	.+80     	; 0x1bce <get_dir+0x190>
    1b7e:	09 c0       	rjmp	.+18     	; 0x1b92 <get_dir+0x154>
		{
			case 5:crrt_dir = 1;return 270;
    1b80:	81 e0       	ldi	r24, 0x01	; 1
    1b82:	90 e0       	ldi	r25, 0x00	; 0
    1b84:	90 93 4b 07 	sts	0x074B, r25
    1b88:	80 93 4a 07 	sts	0x074A, r24
    1b8c:	8e e0       	ldi	r24, 0x0E	; 14
    1b8e:	91 e0       	ldi	r25, 0x01	; 1
    1b90:	08 95       	ret
			break;
			case -5:crrt_dir = 2;return 90;
    1b92:	82 e0       	ldi	r24, 0x02	; 2
    1b94:	90 e0       	ldi	r25, 0x00	; 0
    1b96:	90 93 4b 07 	sts	0x074B, r25
    1b9a:	80 93 4a 07 	sts	0x074A, r24
    1b9e:	8a e5       	ldi	r24, 0x5A	; 90
    1ba0:	90 e0       	ldi	r25, 0x00	; 0
    1ba2:	08 95       	ret
			break;
			case 1:crrt_dir = 3;return 180;
    1ba4:	83 e0       	ldi	r24, 0x03	; 3
    1ba6:	90 e0       	ldi	r25, 0x00	; 0
    1ba8:	90 93 4b 07 	sts	0x074B, r25
    1bac:	80 93 4a 07 	sts	0x074A, r24
    1bb0:	84 eb       	ldi	r24, 0xB4	; 180
    1bb2:	90 e0       	ldi	r25, 0x00	; 0
    1bb4:	08 95       	ret
		break;
		default:
		break;
	}
	
	return 0;
    1bb6:	80 e0       	ldi	r24, 0x00	; 0
    1bb8:	90 e0       	ldi	r25, 0x00	; 0
    1bba:	08 95       	ret
	switch(crrt_dir)
	{
		case 1:
		switch(cnode-nnode)
		{
			case 5:return 0;
    1bbc:	80 e0       	ldi	r24, 0x00	; 0
    1bbe:	90 e0       	ldi	r25, 0x00	; 0
    1bc0:	08 95       	ret
		case 2:
		switch(cnode-nnode)
		{
			case 5:crrt_dir = 1;return 180;
			break;
			case -5:return 0;
    1bc2:	80 e0       	ldi	r24, 0x00	; 0
    1bc4:	90 e0       	ldi	r25, 0x00	; 0
    1bc6:	08 95       	ret
		{
			case 5:crrt_dir = 1;return 90;
			break;
			case -5:crrt_dir = 2;return 270;
			break;
			case 1:return 0;
    1bc8:	80 e0       	ldi	r24, 0x00	; 0
    1bca:	90 e0       	ldi	r25, 0x00	; 0
    1bcc:	08 95       	ret
			break;
			case -5:crrt_dir = 2;return 90;
			break;
			case 1:crrt_dir = 3;return 180;
			break;
			case -1:return 0;
    1bce:	80 e0       	ldi	r24, 0x00	; 0
    1bd0:	90 e0       	ldi	r25, 0x00	; 0
		default:
		break;
	}
	
	return 0;
}
    1bd2:	08 95       	ret

00001bd4 <turn>:

void turn(int crtnode,int nxtnode)		//to turn the bot towards nxtnode from crtnode
{
	int deg = get_dir(crtnode,nxtnode);
    1bd4:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <get_dir>

	switch(deg)
    1bd8:	84 3b       	cpi	r24, 0xB4	; 180
    1bda:	91 05       	cpc	r25, r1
    1bdc:	61 f0       	breq	.+24     	; 0x1bf6 <turn+0x22>
    1bde:	21 e0       	ldi	r18, 0x01	; 1
    1be0:	8e 30       	cpi	r24, 0x0E	; 14
    1be2:	92 07       	cpc	r25, r18
    1be4:	69 f0       	breq	.+26     	; 0x1c00 <turn+0x2c>
    1be6:	8a 35       	cpi	r24, 0x5A	; 90
    1be8:	91 05       	cpc	r25, r1
    1bea:	71 f4       	brne	.+28     	; 0x1c08 <turn+0x34>
	{
		case 0:
		break;
		case 90:
		rotate_right(90);
    1bec:	8a e5       	ldi	r24, 0x5A	; 90
    1bee:	90 e0       	ldi	r25, 0x00	; 0
    1bf0:	0e 94 a2 05 	call	0xb44	; 0xb44 <rotate_right>
		break;
    1bf4:	08 95       	ret
		case 180:
		rotate_right(180);
    1bf6:	84 eb       	ldi	r24, 0xB4	; 180
    1bf8:	90 e0       	ldi	r25, 0x00	; 0
    1bfa:	0e 94 a2 05 	call	0xb44	; 0xb44 <rotate_right>
		break;
    1bfe:	08 95       	ret
		case 270:
		rotate_left(90);
    1c00:	8a e5       	ldi	r24, 0x5A	; 90
    1c02:	90 e0       	ldi	r25, 0x00	; 0
    1c04:	0e 94 c0 05 	call	0xb80	; 0xb80 <rotate_left>
    1c08:	08 95       	ret

00001c0a <get_n_u_plot>:
		break;
	}
}

int get_n_u_plot(void)
{
    1c0a:	2f 92       	push	r2
    1c0c:	3f 92       	push	r3
    1c0e:	4f 92       	push	r4
    1c10:	5f 92       	push	r5
    1c12:	6f 92       	push	r6
    1c14:	7f 92       	push	r7
    1c16:	8f 92       	push	r8
    1c18:	9f 92       	push	r9
    1c1a:	af 92       	push	r10
    1c1c:	bf 92       	push	r11
    1c1e:	cf 92       	push	r12
    1c20:	df 92       	push	r13
    1c22:	ef 92       	push	r14
    1c24:	ff 92       	push	r15
    1c26:	0f 93       	push	r16
    1c28:	1f 93       	push	r17
    1c2a:	cf 93       	push	r28
    1c2c:	df 93       	push	r29
    1c2e:	cd b7       	in	r28, 0x3d	; 61
    1c30:	de b7       	in	r29, 0x3e	; 62
    1c32:	a4 97       	sbiw	r28, 0x24	; 36
    1c34:	0f b6       	in	r0, 0x3f	; 63
    1c36:	f8 94       	cli
    1c38:	de bf       	out	0x3e, r29	; 62
    1c3a:	0f be       	out	0x3f, r0	; 63
    1c3c:	cd bf       	out	0x3d, r28	; 61

	for(i=1;i<=16;i++)
		res+=b[i].pstatus;

	if(res>=16)
		return -1;
    1c3e:	0f 2e       	mov	r0, r31
    1c40:	fe ef       	ldi	r31, 0xFE	; 254
    1c42:	4f 2e       	mov	r4, r31
    1c44:	fc e0       	ldi	r31, 0x0C	; 12
    1c46:	5f 2e       	mov	r5, r31
    1c48:	f0 2d       	mov	r31, r0
		rotate_left(90);
		break;
	}
}

int get_n_u_plot(void)
    1c4a:	0f 2e       	mov	r0, r31
    1c4c:	fe ef       	ldi	r31, 0xFE	; 254
    1c4e:	6f 2e       	mov	r6, r31
    1c50:	fe e0       	ldi	r31, 0x0E	; 14
    1c52:	7f 2e       	mov	r7, r31
    1c54:	f0 2d       	mov	r31, r0
    1c56:	f2 01       	movw	r30, r4
{
	int res=0,i;
    1c58:	80 e0       	ldi	r24, 0x00	; 0
    1c5a:	90 e0       	ldi	r25, 0x00	; 0

	for(i=1;i<=16;i++)
		res+=b[i].pstatus;
    1c5c:	20 81       	ld	r18, Z
    1c5e:	31 81       	ldd	r19, Z+1	; 0x01
    1c60:	82 0f       	add	r24, r18
    1c62:	93 1f       	adc	r25, r19
    1c64:	b0 96       	adiw	r30, 0x20	; 32

int get_n_u_plot(void)
{
	int res=0,i;

	for(i=1;i<=16;i++)
    1c66:	e6 15       	cp	r30, r6
    1c68:	f7 05       	cpc	r31, r7
    1c6a:	c1 f7       	brne	.-16     	; 0x1c5c <get_n_u_plot+0x52>
		res+=b[i].pstatus;

	if(res>=16)
    1c6c:	80 31       	cpi	r24, 0x10	; 16
    1c6e:	91 05       	cpc	r25, r1
    1c70:	0c f0       	brlt	.+2      	; 0x1c74 <get_n_u_plot+0x6a>
    1c72:	d8 c0       	rjmp	.+432    	; 0x1e24 <get_n_u_plot+0x21a>
		return -1;

	for(i=1;i<=4;i++)
		if(n[crt_node].blk[i] != 0)
    1c74:	40 91 4c 07 	lds	r20, 0x074C
    1c78:	50 91 4d 07 	lds	r21, 0x074D
    1c7c:	ca 01       	movw	r24, r20
    1c7e:	88 0f       	add	r24, r24
    1c80:	99 1f       	adc	r25, r25
    1c82:	84 0f       	add	r24, r20
    1c84:	95 1f       	adc	r25, r21
    1c86:	9c 01       	movw	r18, r24
    1c88:	22 0f       	add	r18, r18
    1c8a:	33 1f       	adc	r19, r19
    1c8c:	22 0f       	add	r18, r18
    1c8e:	33 1f       	adc	r19, r19
    1c90:	22 0f       	add	r18, r18
    1c92:	33 1f       	adc	r19, r19
    1c94:	f9 01       	movw	r30, r18
    1c96:	e8 1b       	sub	r30, r24
    1c98:	f9 0b       	sbc	r31, r25
    1c9a:	e4 0f       	add	r30, r20
    1c9c:	f5 1f       	adc	r31, r21
    1c9e:	e6 51       	subi	r30, 0x16	; 22
    1ca0:	f1 4f       	sbci	r31, 0xF1	; 241
    1ca2:	84 85       	ldd	r24, Z+12	; 0x0c
    1ca4:	95 85       	ldd	r25, Z+13	; 0x0d
    1ca6:	00 97       	sbiw	r24, 0x00	; 0
    1ca8:	09 f0       	breq	.+2      	; 0x1cac <get_n_u_plot+0xa2>
    1caa:	45 c0       	rjmp	.+138    	; 0x1d36 <get_n_u_plot+0x12c>
    1cac:	ca 01       	movw	r24, r20
    1cae:	88 0f       	add	r24, r24
    1cb0:	99 1f       	adc	r25, r25
    1cb2:	84 0f       	add	r24, r20
    1cb4:	95 1f       	adc	r25, r21
    1cb6:	9c 01       	movw	r18, r24
    1cb8:	22 0f       	add	r18, r18
    1cba:	33 1f       	adc	r19, r19
    1cbc:	22 0f       	add	r18, r18
    1cbe:	33 1f       	adc	r19, r19
    1cc0:	22 0f       	add	r18, r18
    1cc2:	33 1f       	adc	r19, r19
    1cc4:	f9 01       	movw	r30, r18
    1cc6:	e8 1b       	sub	r30, r24
    1cc8:	f9 0b       	sbc	r31, r25
    1cca:	e4 0f       	add	r30, r20
    1ccc:	f5 1f       	adc	r31, r21
    1cce:	e6 51       	subi	r30, 0x16	; 22
    1cd0:	f1 4f       	sbci	r31, 0xF1	; 241
    1cd2:	86 85       	ldd	r24, Z+14	; 0x0e
    1cd4:	97 85       	ldd	r25, Z+15	; 0x0f
    1cd6:	00 97       	sbiw	r24, 0x00	; 0
    1cd8:	71 f5       	brne	.+92     	; 0x1d36 <get_n_u_plot+0x12c>
    1cda:	ca 01       	movw	r24, r20
    1cdc:	88 0f       	add	r24, r24
    1cde:	99 1f       	adc	r25, r25
    1ce0:	84 0f       	add	r24, r20
    1ce2:	95 1f       	adc	r25, r21
    1ce4:	9c 01       	movw	r18, r24
    1ce6:	22 0f       	add	r18, r18
    1ce8:	33 1f       	adc	r19, r19
    1cea:	22 0f       	add	r18, r18
    1cec:	33 1f       	adc	r19, r19
    1cee:	22 0f       	add	r18, r18
    1cf0:	33 1f       	adc	r19, r19
    1cf2:	f9 01       	movw	r30, r18
    1cf4:	e8 1b       	sub	r30, r24
    1cf6:	f9 0b       	sbc	r31, r25
    1cf8:	e4 0f       	add	r30, r20
    1cfa:	f5 1f       	adc	r31, r21
    1cfc:	e6 51       	subi	r30, 0x16	; 22
    1cfe:	f1 4f       	sbci	r31, 0xF1	; 241
    1d00:	80 89       	ldd	r24, Z+16	; 0x10
    1d02:	91 89       	ldd	r25, Z+17	; 0x11
    1d04:	00 97       	sbiw	r24, 0x00	; 0
    1d06:	b9 f4       	brne	.+46     	; 0x1d36 <get_n_u_plot+0x12c>
    1d08:	ca 01       	movw	r24, r20
    1d0a:	88 0f       	add	r24, r24
    1d0c:	99 1f       	adc	r25, r25
    1d0e:	84 0f       	add	r24, r20
    1d10:	95 1f       	adc	r25, r21
    1d12:	9c 01       	movw	r18, r24
    1d14:	22 0f       	add	r18, r18
    1d16:	33 1f       	adc	r19, r19
    1d18:	22 0f       	add	r18, r18
    1d1a:	33 1f       	adc	r19, r19
    1d1c:	22 0f       	add	r18, r18
    1d1e:	33 1f       	adc	r19, r19
    1d20:	28 1b       	sub	r18, r24
    1d22:	39 0b       	sbc	r19, r25
    1d24:	24 0f       	add	r18, r20
    1d26:	35 1f       	adc	r19, r21
    1d28:	f9 01       	movw	r30, r18
    1d2a:	e6 51       	subi	r30, 0x16	; 22
    1d2c:	f1 4f       	sbci	r31, 0xF1	; 241
    1d2e:	82 89       	ldd	r24, Z+18	; 0x12
    1d30:	93 89       	ldd	r25, Z+19	; 0x13
    1d32:	00 97       	sbiw	r24, 0x00	; 0
    1d34:	21 f0       	breq	.+8      	; 0x1d3e <get_n_u_plot+0x134>
		{
			c_plot = n[crt_node].blk[i];			
    1d36:	90 93 49 07 	sts	0x0749, r25
    1d3a:	80 93 48 07 	sts	0x0748, r24
			break;
		}

	int d[17],min=IN;
	int r=get_row(c_plot),c=get_col(c_plot);
    1d3e:	00 91 48 07 	lds	r16, 0x0748
    1d42:	10 91 49 07 	lds	r17, 0x0749
    1d46:	c8 01       	movw	r24, r16
    1d48:	0e 94 f9 0c 	call	0x19f2	; 0x19f2 <get_row>
    1d4c:	9c a3       	lds	r25, 0x5c
    1d4e:	8b a3       	lds	r24, 0x5b
    1d50:	c8 01       	movw	r24, r16
    1d52:	0e 94 16 0d 	call	0x1a2c	; 0x1a2c <get_col>
    1d56:	1c 01       	movw	r2, r24
    1d58:	0f 2e       	mov	r0, r31
    1d5a:	f3 e0       	ldi	r31, 0x03	; 3
    1d5c:	8f 2e       	mov	r8, r31
    1d5e:	99 24       	eor	r9, r9
    1d60:	f0 2d       	mov	r31, r0
    1d62:	8c 0e       	add	r8, r28
    1d64:	9d 1e       	adc	r9, r29
    1d66:	54 01       	movw	r10, r8
    1d68:	62 01       	movw	r12, r4

	for(i=1;i<17;i++)
    1d6a:	ee 24       	eor	r14, r14
    1d6c:	ff 24       	eor	r15, r15
    1d6e:	e3 94       	inc	r14
	{
		if(b[i].pstatus == 0)
    1d70:	f6 01       	movw	r30, r12
    1d72:	80 81       	ld	r24, Z
    1d74:	91 81       	ldd	r25, Z+1	; 0x01
    1d76:	00 97       	sbiw	r24, 0x00	; 0
    1d78:	d1 f4       	brne	.+52     	; 0x1dae <get_n_u_plot+0x1a4>
		{
			int r1=get_row(i),c1=get_col(i);
    1d7a:	c7 01       	movw	r24, r14
    1d7c:	0e 94 f9 0c 	call	0x19f2	; 0x19f2 <get_row>
    1d80:	8c 01       	movw	r16, r24
    1d82:	c7 01       	movw	r24, r14
    1d84:	0e 94 16 0d 	call	0x1a2c	; 0x1a2c <get_col>
			d[i]=abs(r1-r)+abs(c1-c);
    1d88:	2b a1       	lds	r18, 0x4b
    1d8a:	3c a1       	lds	r19, 0x4c
    1d8c:	02 1b       	sub	r16, r18
    1d8e:	13 0b       	sbc	r17, r19
    1d90:	1a f4       	brpl	.+6      	; 0x1d98 <get_n_u_plot+0x18e>
    1d92:	10 95       	com	r17
    1d94:	01 95       	neg	r16
    1d96:	1f 4f       	sbci	r17, 0xFF	; 255
    1d98:	82 19       	sub	r24, r2
    1d9a:	93 09       	sbc	r25, r3
    1d9c:	1a f4       	brpl	.+6      	; 0x1da4 <get_n_u_plot+0x19a>
    1d9e:	90 95       	com	r25
    1da0:	81 95       	neg	r24
    1da2:	9f 4f       	sbci	r25, 0xFF	; 255
    1da4:	80 0f       	add	r24, r16
    1da6:	91 1f       	adc	r25, r17
    1da8:	f5 01       	movw	r30, r10
    1daa:	91 83       	std	Z+1, r25	; 0x01
    1dac:	80 83       	st	Z, r24
		}

	int d[17],min=IN;
	int r=get_row(c_plot),c=get_col(c_plot);

	for(i=1;i<17;i++)
    1dae:	08 94       	sec
    1db0:	e1 1c       	adc	r14, r1
    1db2:	f1 1c       	adc	r15, r1
    1db4:	20 e2       	ldi	r18, 0x20	; 32
    1db6:	30 e0       	ldi	r19, 0x00	; 0
    1db8:	c2 0e       	add	r12, r18
    1dba:	d3 1e       	adc	r13, r19
    1dbc:	82 e0       	ldi	r24, 0x02	; 2
    1dbe:	90 e0       	ldi	r25, 0x00	; 0
    1dc0:	a8 0e       	add	r10, r24
    1dc2:	b9 1e       	adc	r11, r25
    1dc4:	91 e1       	ldi	r25, 0x11	; 17
    1dc6:	e9 16       	cp	r14, r25
    1dc8:	f1 04       	cpc	r15, r1
    1dca:	91 f6       	brne	.-92     	; 0x1d70 <get_n_u_plot+0x166>
    1dcc:	d4 01       	movw	r26, r8
    1dce:	f2 01       	movw	r30, r4
    1dd0:	43 e6       	ldi	r20, 0x63	; 99
    1dd2:	50 e0       	ldi	r21, 0x00	; 0
			d[i]=abs(r1-r)+abs(c1-c);
		}
	}
	for(i=1;i<17;i++)
	{
		if(b[i].pstatus==0)
    1dd4:	80 81       	ld	r24, Z
    1dd6:	91 81       	ldd	r25, Z+1	; 0x01
    1dd8:	00 97       	sbiw	r24, 0x00	; 0
    1dda:	39 f4       	brne	.+14     	; 0x1dea <get_n_u_plot+0x1e0>
    1ddc:	8d 91       	ld	r24, X+
    1dde:	9c 91       	ld	r25, X
    1de0:	11 97       	sbiw	r26, 0x01	; 1
    1de2:	84 17       	cp	r24, r20
    1de4:	95 07       	cpc	r25, r21
    1de6:	0c f4       	brge	.+2      	; 0x1dea <get_n_u_plot+0x1e0>
    1de8:	ac 01       	movw	r20, r24
    1dea:	b0 96       	adiw	r30, 0x20	; 32
    1dec:	12 96       	adiw	r26, 0x02	; 2
		{
			int r1=get_row(i),c1=get_col(i);
			d[i]=abs(r1-r)+abs(c1-c);
		}
	}
	for(i=1;i<17;i++)
    1dee:	e6 15       	cp	r30, r6
    1df0:	f7 05       	cpc	r31, r7
    1df2:	81 f7       	brne	.-32     	; 0x1dd4 <get_n_u_plot+0x1ca>
    1df4:	21 e0       	ldi	r18, 0x01	; 1
    1df6:	30 e0       	ldi	r19, 0x00	; 0
				min=d[i];
		}
	}
	
	for(i=1;i<17;i++)
		if((d[i] == min) && b[i].pstatus == 0)
    1df8:	f4 01       	movw	r30, r8
    1dfa:	81 91       	ld	r24, Z+
    1dfc:	91 91       	ld	r25, Z+
    1dfe:	4f 01       	movw	r8, r30
    1e00:	84 17       	cp	r24, r20
    1e02:	95 07       	cpc	r25, r21
    1e04:	29 f4       	brne	.+10     	; 0x1e10 <get_n_u_plot+0x206>
    1e06:	f2 01       	movw	r30, r4
    1e08:	80 81       	ld	r24, Z
    1e0a:	91 81       	ldd	r25, Z+1	; 0x01
    1e0c:	00 97       	sbiw	r24, 0x00	; 0
    1e0e:	61 f0       	breq	.+24     	; 0x1e28 <get_n_u_plot+0x21e>
			if(d[i] < min)
				min=d[i];
		}
	}
	
	for(i=1;i<17;i++)
    1e10:	2f 5f       	subi	r18, 0xFF	; 255
    1e12:	3f 4f       	sbci	r19, 0xFF	; 255
    1e14:	80 e2       	ldi	r24, 0x20	; 32
    1e16:	90 e0       	ldi	r25, 0x00	; 0
    1e18:	48 0e       	add	r4, r24
    1e1a:	59 1e       	adc	r5, r25
    1e1c:	21 31       	cpi	r18, 0x11	; 17
    1e1e:	31 05       	cpc	r19, r1
    1e20:	59 f7       	brne	.-42     	; 0x1df8 <get_n_u_plot+0x1ee>
    1e22:	02 c0       	rjmp	.+4      	; 0x1e28 <get_n_u_plot+0x21e>

	for(i=1;i<=16;i++)
		res+=b[i].pstatus;

	if(res>=16)
		return -1;
    1e24:	2f ef       	ldi	r18, 0xFF	; 255
    1e26:	3f ef       	ldi	r19, 0xFF	; 255
	
	for(i=1;i<17;i++)
		if((d[i] == min) && b[i].pstatus == 0)
			break;
	return i;
}
    1e28:	82 2f       	mov	r24, r18
    1e2a:	93 2f       	mov	r25, r19
    1e2c:	a4 96       	adiw	r28, 0x24	; 36
    1e2e:	0f b6       	in	r0, 0x3f	; 63
    1e30:	f8 94       	cli
    1e32:	de bf       	out	0x3e, r29	; 62
    1e34:	0f be       	out	0x3f, r0	; 63
    1e36:	cd bf       	out	0x3d, r28	; 61
    1e38:	df 91       	pop	r29
    1e3a:	cf 91       	pop	r28
    1e3c:	1f 91       	pop	r17
    1e3e:	0f 91       	pop	r16
    1e40:	ff 90       	pop	r15
    1e42:	ef 90       	pop	r14
    1e44:	df 90       	pop	r13
    1e46:	cf 90       	pop	r12
    1e48:	bf 90       	pop	r11
    1e4a:	af 90       	pop	r10
    1e4c:	9f 90       	pop	r9
    1e4e:	8f 90       	pop	r8
    1e50:	7f 90       	pop	r7
    1e52:	6f 90       	pop	r6
    1e54:	5f 90       	pop	r5
    1e56:	4f 90       	pop	r4
    1e58:	3f 90       	pop	r3
    1e5a:	2f 90       	pop	r2
    1e5c:	08 95       	ret

00001e5e <detect_block>:

int detect_block(int c_node,int n_node)		// To detect black debris and updating the midpoint(ob)
{
    1e5e:	ef 92       	push	r14
    1e60:	ff 92       	push	r15
    1e62:	0f 93       	push	r16
    1e64:	1f 93       	push	r17
    1e66:	cf 93       	push	r28
    1e68:	df 93       	push	r29
    1e6a:	8c 01       	movw	r16, r24
    1e6c:	eb 01       	movw	r28, r22
	int retv=0;
	int temp = detect_obstacle(80,200);
    1e6e:	80 e5       	ldi	r24, 0x50	; 80
    1e70:	90 e0       	ldi	r25, 0x00	; 0
    1e72:	68 ec       	ldi	r22, 0xC8	; 200
    1e74:	70 e0       	ldi	r23, 0x00	; 0
    1e76:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <detect_obstacle>
	
	if(temp)
    1e7a:	00 97       	sbiw	r24, 0x00	; 0
    1e7c:	09 f4       	brne	.+2      	; 0x1e80 <detect_block+0x22>
    1e7e:	5c c0       	rjmp	.+184    	; 0x1f38 <detect_block+0xda>
	{
		cost[c_node][n_node]=IN;
    1e80:	2a e1       	ldi	r18, 0x1A	; 26
    1e82:	30 e0       	ldi	r19, 0x00	; 0
    1e84:	02 9f       	mul	r16, r18
    1e86:	f0 01       	movw	r30, r0
    1e88:	03 9f       	mul	r16, r19
    1e8a:	f0 0d       	add	r31, r0
    1e8c:	12 9f       	mul	r17, r18
    1e8e:	f0 0d       	add	r31, r0
    1e90:	11 24       	eor	r1, r1
    1e92:	ec 0f       	add	r30, r28
    1e94:	fd 1f       	adc	r31, r29
    1e96:	60 e0       	ldi	r22, 0x00	; 0
    1e98:	72 e0       	ldi	r23, 0x02	; 2
    1e9a:	ee 0f       	add	r30, r30
    1e9c:	ff 1f       	adc	r31, r31
    1e9e:	e6 0f       	add	r30, r22
    1ea0:	f7 1f       	adc	r31, r23
    1ea2:	43 e6       	ldi	r20, 0x63	; 99
    1ea4:	50 e0       	ldi	r21, 0x00	; 0
    1ea6:	51 83       	std	Z+1, r21	; 0x01
    1ea8:	40 83       	st	Z, r20
		cost[n_node][c_node]=IN;
    1eaa:	c2 9f       	mul	r28, r18
    1eac:	c0 01       	movw	r24, r0
    1eae:	c3 9f       	mul	r28, r19
    1eb0:	90 0d       	add	r25, r0
    1eb2:	d2 9f       	mul	r29, r18
    1eb4:	90 0d       	add	r25, r0
    1eb6:	11 24       	eor	r1, r1
    1eb8:	80 0f       	add	r24, r16
    1eba:	91 1f       	adc	r25, r17
    1ebc:	88 0f       	add	r24, r24
    1ebe:	99 1f       	adc	r25, r25
    1ec0:	86 0f       	add	r24, r22
    1ec2:	97 1f       	adc	r25, r23
    1ec4:	fc 01       	movw	r30, r24
    1ec6:	51 83       	std	Z+1, r21	; 0x01
    1ec8:	40 83       	st	Z, r20
		ACK=0;
    1eca:	10 92 5b 07 	sts	0x075B, r1
    1ece:	10 92 5a 07 	sts	0x075A, r1
		send(30,c_node,n_node);
    1ed2:	0f 2e       	mov	r0, r31
    1ed4:	f4 e0       	ldi	r31, 0x04	; 4
    1ed6:	ef 2e       	mov	r14, r31
    1ed8:	f1 e0       	ldi	r31, 0x01	; 1
    1eda:	ff 2e       	mov	r15, r31
    1edc:	f0 2d       	mov	r31, r0
    1ede:	8e e1       	ldi	r24, 0x1E	; 30
    1ee0:	90 e0       	ldi	r25, 0x00	; 0
    1ee2:	b8 01       	movw	r22, r16
    1ee4:	ae 01       	movw	r20, r28
    1ee6:	f7 01       	movw	r30, r14
    1ee8:	19 95       	eicall
		if (ACK != 1)
    1eea:	80 91 5a 07 	lds	r24, 0x075A
    1eee:	90 91 5b 07 	lds	r25, 0x075B
    1ef2:	81 30       	cpi	r24, 0x01	; 1
    1ef4:	91 05       	cpc	r25, r1
    1ef6:	c9 f0       	breq	.+50     	; 0x1f2a <detect_block+0xcc>
		{
			while(ACK !=1)
    1ef8:	80 91 5a 07 	lds	r24, 0x075A
    1efc:	90 91 5b 07 	lds	r25, 0x075B
    1f00:	81 30       	cpi	r24, 0x01	; 1
    1f02:	91 05       	cpc	r25, r1
    1f04:	91 f0       	breq	.+36     	; 0x1f2a <detect_block+0xcc>
			{
				send(30,c_node,n_node);
    1f06:	8e e1       	ldi	r24, 0x1E	; 30
    1f08:	90 e0       	ldi	r25, 0x00	; 0
    1f0a:	b8 01       	movw	r22, r16
    1f0c:	ae 01       	movw	r20, r28
    1f0e:	f7 01       	movw	r30, r14
    1f10:	19 95       	eicall
    1f12:	86 e6       	ldi	r24, 0x66	; 102
    1f14:	9e e0       	ldi	r25, 0x0E	; 14
    1f16:	01 97       	sbiw	r24, 0x01	; 1
    1f18:	f1 f7       	brne	.-4      	; 0x1f16 <detect_block+0xb8>
    1f1a:	00 00       	nop
		cost[n_node][c_node]=IN;
		ACK=0;
		send(30,c_node,n_node);
		if (ACK != 1)
		{
			while(ACK !=1)
    1f1c:	80 91 5a 07 	lds	r24, 0x075A
    1f20:	90 91 5b 07 	lds	r25, 0x075B
    1f24:	81 30       	cpi	r24, 0x01	; 1
    1f26:	91 05       	cpc	r25, r1
    1f28:	71 f7       	brne	.-36     	; 0x1f06 <detect_block+0xa8>
			{
				send(30,c_node,n_node);
				_delay_ms(1);
			}
		}
		ACK = 0;
    1f2a:	10 92 5b 07 	sts	0x075B, r1
    1f2e:	10 92 5a 07 	sts	0x075A, r1
			
		retv=1;
    1f32:	81 e0       	ldi	r24, 0x01	; 1
    1f34:	90 e0       	ldi	r25, 0x00	; 0
    1f36:	02 c0       	rjmp	.+4      	; 0x1f3c <detect_block+0xde>
	return i;
}

int detect_block(int c_node,int n_node)		// To detect black debris and updating the midpoint(ob)
{
	int retv=0;
    1f38:	80 e0       	ldi	r24, 0x00	; 0
    1f3a:	90 e0       	ldi	r25, 0x00	; 0
			
		retv=1;
	}
	
	return retv;
}
    1f3c:	df 91       	pop	r29
    1f3e:	cf 91       	pop	r28
    1f40:	1f 91       	pop	r17
    1f42:	0f 91       	pop	r16
    1f44:	ff 90       	pop	r15
    1f46:	ef 90       	pop	r14
    1f48:	08 95       	ret

00001f4a <plot_scan>:

void plot_scan(int crtid,int nxtid)		//To scan the plots for white debris
{
    1f4a:	8f 92       	push	r8
    1f4c:	9f 92       	push	r9
    1f4e:	af 92       	push	r10
    1f50:	bf 92       	push	r11
    1f52:	cf 92       	push	r12
    1f54:	df 92       	push	r13
    1f56:	ef 92       	push	r14
    1f58:	ff 92       	push	r15
    1f5a:	0f 93       	push	r16
    1f5c:	1f 93       	push	r17
    1f5e:	cf 93       	push	r28
    1f60:	df 93       	push	r29
    1f62:	7c 01       	movw	r14, r24
    1f64:	5b 01       	movw	r10, r22
	int l=0,r=0,c=3;
	switch(crtid - nxtid)
    1f66:	86 1b       	sub	r24, r22
    1f68:	97 0b       	sbc	r25, r23
    1f6a:	2f ef       	ldi	r18, 0xFF	; 255
    1f6c:	8f 3f       	cpi	r24, 0xFF	; 255
    1f6e:	92 07       	cpc	r25, r18
    1f70:	51 f1       	breq	.+84     	; 0x1fc6 <plot_scan+0x7c>
    1f72:	af ef       	ldi	r26, 0xFF	; 255
    1f74:	8f 3f       	cpi	r24, 0xFF	; 255
    1f76:	9a 07       	cpc	r25, r26
    1f78:	09 f0       	breq	.+2      	; 0x1f7c <plot_scan+0x32>
    1f7a:	34 f4       	brge	.+12     	; 0x1f88 <plot_scan+0x3e>
    1f7c:	bf ef       	ldi	r27, 0xFF	; 255
    1f7e:	8b 3f       	cpi	r24, 0xFB	; 251
    1f80:	9b 07       	cpc	r25, r27
    1f82:	09 f0       	breq	.+2      	; 0x1f86 <plot_scan+0x3c>
    1f84:	65 c0       	rjmp	.+202    	; 0x2050 <plot_scan+0x106>
    1f86:	4d c0       	rjmp	.+154    	; 0x2022 <plot_scan+0xd8>
    1f88:	81 30       	cpi	r24, 0x01	; 1
    1f8a:	91 05       	cpc	r25, r1
    1f8c:	29 f0       	breq	.+10     	; 0x1f98 <plot_scan+0x4e>
    1f8e:	85 30       	cpi	r24, 0x05	; 5
    1f90:	91 05       	cpc	r25, r1
    1f92:	09 f0       	breq	.+2      	; 0x1f96 <plot_scan+0x4c>
    1f94:	5d c0       	rjmp	.+186    	; 0x2050 <plot_scan+0x106>
    1f96:	2e c0       	rjmp	.+92     	; 0x1ff4 <plot_scan+0xaa>
	{
		case 1:
		l=n[crtid].blk[1];
    1f98:	c7 01       	movw	r24, r14
    1f9a:	88 0f       	add	r24, r24
    1f9c:	99 1f       	adc	r25, r25
    1f9e:	8e 0d       	add	r24, r14
    1fa0:	9f 1d       	adc	r25, r15
    1fa2:	fc 01       	movw	r30, r24
    1fa4:	ee 0f       	add	r30, r30
    1fa6:	ff 1f       	adc	r31, r31
    1fa8:	ee 0f       	add	r30, r30
    1faa:	ff 1f       	adc	r31, r31
    1fac:	ee 0f       	add	r30, r30
    1fae:	ff 1f       	adc	r31, r31
    1fb0:	e8 1b       	sub	r30, r24
    1fb2:	f9 0b       	sbc	r31, r25
    1fb4:	ee 0d       	add	r30, r14
    1fb6:	ff 1d       	adc	r31, r15
    1fb8:	e6 51       	subi	r30, 0x16	; 22
    1fba:	f1 4f       	sbci	r31, 0xF1	; 241
    1fbc:	04 85       	ldd	r16, Z+12	; 0x0c
    1fbe:	15 85       	ldd	r17, Z+13	; 0x0d
		r=n[crtid].blk[3];
    1fc0:	c0 89       	ldd	r28, Z+16	; 0x10
    1fc2:	d1 89       	ldd	r29, Z+17	; 0x11
		break;
    1fc4:	49 c0       	rjmp	.+146    	; 0x2058 <plot_scan+0x10e>
		
		case -1:
		l=n[crtid].blk[4];
    1fc6:	c7 01       	movw	r24, r14
    1fc8:	88 0f       	add	r24, r24
    1fca:	99 1f       	adc	r25, r25
    1fcc:	8e 0d       	add	r24, r14
    1fce:	9f 1d       	adc	r25, r15
    1fd0:	fc 01       	movw	r30, r24
    1fd2:	ee 0f       	add	r30, r30
    1fd4:	ff 1f       	adc	r31, r31
    1fd6:	ee 0f       	add	r30, r30
    1fd8:	ff 1f       	adc	r31, r31
    1fda:	ee 0f       	add	r30, r30
    1fdc:	ff 1f       	adc	r31, r31
    1fde:	e8 1b       	sub	r30, r24
    1fe0:	f9 0b       	sbc	r31, r25
    1fe2:	ee 0d       	add	r30, r14
    1fe4:	ff 1d       	adc	r31, r15
    1fe6:	e6 51       	subi	r30, 0x16	; 22
    1fe8:	f1 4f       	sbci	r31, 0xF1	; 241
    1fea:	02 89       	ldd	r16, Z+18	; 0x12
    1fec:	13 89       	ldd	r17, Z+19	; 0x13
		r=n[crtid].blk[2];
    1fee:	c6 85       	ldd	r28, Z+14	; 0x0e
    1ff0:	d7 85       	ldd	r29, Z+15	; 0x0f
		break;
    1ff2:	32 c0       	rjmp	.+100    	; 0x2058 <plot_scan+0x10e>
		
		case 5:
		l=n[crtid].blk[3];
    1ff4:	c7 01       	movw	r24, r14
    1ff6:	88 0f       	add	r24, r24
    1ff8:	99 1f       	adc	r25, r25
    1ffa:	8e 0d       	add	r24, r14
    1ffc:	9f 1d       	adc	r25, r15
    1ffe:	fc 01       	movw	r30, r24
    2000:	ee 0f       	add	r30, r30
    2002:	ff 1f       	adc	r31, r31
    2004:	ee 0f       	add	r30, r30
    2006:	ff 1f       	adc	r31, r31
    2008:	ee 0f       	add	r30, r30
    200a:	ff 1f       	adc	r31, r31
    200c:	e8 1b       	sub	r30, r24
    200e:	f9 0b       	sbc	r31, r25
    2010:	ee 0d       	add	r30, r14
    2012:	ff 1d       	adc	r31, r15
    2014:	e6 51       	subi	r30, 0x16	; 22
    2016:	f1 4f       	sbci	r31, 0xF1	; 241
    2018:	00 89       	ldd	r16, Z+16	; 0x10
    201a:	11 89       	ldd	r17, Z+17	; 0x11
		r=n[crtid].blk[4];
    201c:	c2 89       	ldd	r28, Z+18	; 0x12
    201e:	d3 89       	ldd	r29, Z+19	; 0x13
		break;
    2020:	1b c0       	rjmp	.+54     	; 0x2058 <plot_scan+0x10e>
		
		case -5:
		l=n[crtid].blk[2];
    2022:	c7 01       	movw	r24, r14
    2024:	88 0f       	add	r24, r24
    2026:	99 1f       	adc	r25, r25
    2028:	8e 0d       	add	r24, r14
    202a:	9f 1d       	adc	r25, r15
    202c:	fc 01       	movw	r30, r24
    202e:	ee 0f       	add	r30, r30
    2030:	ff 1f       	adc	r31, r31
    2032:	ee 0f       	add	r30, r30
    2034:	ff 1f       	adc	r31, r31
    2036:	ee 0f       	add	r30, r30
    2038:	ff 1f       	adc	r31, r31
    203a:	e8 1b       	sub	r30, r24
    203c:	f9 0b       	sbc	r31, r25
    203e:	ee 0d       	add	r30, r14
    2040:	ff 1d       	adc	r31, r15
    2042:	e6 51       	subi	r30, 0x16	; 22
    2044:	f1 4f       	sbci	r31, 0xF1	; 241
    2046:	06 85       	ldd	r16, Z+14	; 0x0e
    2048:	17 85       	ldd	r17, Z+15	; 0x0f
		r=n[crtid].blk[1];
    204a:	c4 85       	ldd	r28, Z+12	; 0x0c
    204c:	d5 85       	ldd	r29, Z+13	; 0x0d
		break;
    204e:	04 c0       	rjmp	.+8      	; 0x2058 <plot_scan+0x10e>
	return retv;
}

void plot_scan(int crtid,int nxtid)		//To scan the plots for white debris
{
	int l=0,r=0,c=3;
    2050:	c0 e0       	ldi	r28, 0x00	; 0
    2052:	d0 e0       	ldi	r29, 0x00	; 0
    2054:	00 e0       	ldi	r16, 0x00	; 0
    2056:	10 e0       	ldi	r17, 0x00	; 0
		break;
		
		default: break;
	}
	
	if(r!=0 && b[r].pstatus!=1)
    2058:	20 97       	sbiw	r28, 0x00	; 0
    205a:	09 f4       	brne	.+2      	; 0x205e <plot_scan+0x114>
    205c:	f5 c0       	rjmp	.+490    	; 0x2248 <__stack+0x49>
    205e:	fe 01       	movw	r30, r28
    2060:	ee 0f       	add	r30, r30
    2062:	ff 1f       	adc	r31, r31
    2064:	e2 95       	swap	r30
    2066:	f2 95       	swap	r31
    2068:	f0 7f       	andi	r31, 0xF0	; 240
    206a:	fe 27       	eor	r31, r30
    206c:	e0 7f       	andi	r30, 0xF0	; 240
    206e:	fe 27       	eor	r31, r30
    2070:	e6 53       	subi	r30, 0x36	; 54
    2072:	f3 4f       	sbci	r31, 0xF3	; 243
    2074:	84 89       	ldd	r24, Z+20	; 0x14
    2076:	95 89       	ldd	r25, Z+21	; 0x15
    2078:	81 30       	cpi	r24, 0x01	; 1
    207a:	91 05       	cpc	r25, r1
    207c:	09 f4       	brne	.+2      	; 0x2080 <plot_scan+0x136>
    207e:	e4 c0       	rjmp	.+456    	; 0x2248 <__stack+0x49>
	{
		//_delay_ms(50);
		int a = detect_white(80,400,13);
    2080:	80 e5       	ldi	r24, 0x50	; 80
    2082:	90 e0       	ldi	r25, 0x00	; 0
    2084:	60 e9       	ldi	r22, 0x90	; 144
    2086:	71 e0       	ldi	r23, 0x01	; 1
    2088:	4d e0       	ldi	r20, 0x0D	; 13
    208a:	0e 94 07 03 	call	0x60e	; 0x60e <detect_white>
		
		//lcd_print(2,1,a,2);
		
		if(a == 1)
    208e:	81 30       	cpi	r24, 0x01	; 1
    2090:	91 05       	cpc	r25, r1
    2092:	09 f0       	breq	.+2      	; 0x2096 <plot_scan+0x14c>
    2094:	cd c0       	rjmp	.+410    	; 0x2230 <__stack+0x31>
		{
			//buzzer(4);
			
			{
				servo_1(0);
    2096:	80 e0       	ldi	r24, 0x00	; 0
    2098:	0e 94 17 06 	call	0xc2e	; 0xc2e <servo_1>
				servo_2(180);
    209c:	84 eb       	ldi	r24, 0xB4	; 180
    209e:	0e 94 30 06 	call	0xc60	; 0xc60 <servo_2>
    20a2:	8f ef       	ldi	r24, 0xFF	; 255
    20a4:	9f ef       	ldi	r25, 0xFF	; 255
    20a6:	ac e2       	ldi	r26, 0x2C	; 44
    20a8:	81 50       	subi	r24, 0x01	; 1
    20aa:	90 40       	sbci	r25, 0x00	; 0
    20ac:	a0 40       	sbci	r26, 0x00	; 0
    20ae:	e1 f7       	brne	.-8      	; 0x20a8 <plot_scan+0x15e>
    20b0:	00 c0       	rjmp	.+0      	; 0x20b2 <plot_scan+0x168>
    20b2:	00 00       	nop
				_delay_ms(1000);
				servo_2(78);
    20b4:	8e e4       	ldi	r24, 0x4E	; 78
    20b6:	0e 94 30 06 	call	0xc60	; 0xc60 <servo_2>
    20ba:	8f ef       	ldi	r24, 0xFF	; 255
    20bc:	9f ef       	ldi	r25, 0xFF	; 255
    20be:	a9 e5       	ldi	r26, 0x59	; 89
    20c0:	81 50       	subi	r24, 0x01	; 1
    20c2:	90 40       	sbci	r25, 0x00	; 0
    20c4:	a0 40       	sbci	r26, 0x00	; 0
    20c6:	e1 f7       	brne	.-8      	; 0x20c0 <plot_scan+0x176>
    20c8:	00 c0       	rjmp	.+0      	; 0x20ca <plot_scan+0x180>
    20ca:	00 00       	nop
				_delay_ms(2000);
				servo(30);
    20cc:	8e e1       	ldi	r24, 0x1E	; 30
    20ce:	90 e0       	ldi	r25, 0x00	; 0
    20d0:	0e 94 77 06 	call	0xcee	; 0xcee <servo>
    20d4:	8f ef       	ldi	r24, 0xFF	; 255
    20d6:	9f e7       	ldi	r25, 0x7F	; 127
    20d8:	a6 e1       	ldi	r26, 0x16	; 22
    20da:	81 50       	subi	r24, 0x01	; 1
    20dc:	90 40       	sbci	r25, 0x00	; 0
    20de:	a0 40       	sbci	r26, 0x00	; 0
    20e0:	e1 f7       	brne	.-8      	; 0x20da <plot_scan+0x190>
    20e2:	00 c0       	rjmp	.+0      	; 0x20e4 <plot_scan+0x19a>
    20e4:	00 00       	nop
				_delay_ms(500);
				servo(20);
    20e6:	84 e1       	ldi	r24, 0x14	; 20
    20e8:	90 e0       	ldi	r25, 0x00	; 0
    20ea:	0e 94 77 06 	call	0xcee	; 0xcee <servo>
    20ee:	8f ef       	ldi	r24, 0xFF	; 255
    20f0:	9f e7       	ldi	r25, 0x7F	; 127
    20f2:	a4 e0       	ldi	r26, 0x04	; 4
    20f4:	81 50       	subi	r24, 0x01	; 1
    20f6:	90 40       	sbci	r25, 0x00	; 0
    20f8:	a0 40       	sbci	r26, 0x00	; 0
    20fa:	e1 f7       	brne	.-8      	; 0x20f4 <plot_scan+0x1aa>
    20fc:	00 c0       	rjmp	.+0      	; 0x20fe <plot_scan+0x1b4>
    20fe:	00 00       	nop
				_delay_ms(100);
				
				// Detect
				c= get_colour();
    2100:	0e 94 88 07 	call	0xf10	; 0xf10 <get_colour>
    2104:	6c 01       	movw	r12, r24
				servo_2(180);
    2106:	84 eb       	ldi	r24, 0xB4	; 180
    2108:	0e 94 30 06 	call	0xc60	; 0xc60 <servo_2>
			}
			
			display_colour(c);
    210c:	c6 01       	movw	r24, r12
    210e:	0e 94 6b 08 	call	0x10d6	; 0x10d6 <display_colour>
    2112:	8f ef       	ldi	r24, 0xFF	; 255
    2114:	9f ef       	ldi	r25, 0xFF	; 255
    2116:	a9 e5       	ldi	r26, 0x59	; 89
    2118:	81 50       	subi	r24, 0x01	; 1
    211a:	90 40       	sbci	r25, 0x00	; 0
    211c:	a0 40       	sbci	r26, 0x00	; 0
    211e:	e1 f7       	brne	.-8      	; 0x2118 <plot_scan+0x1ce>
    2120:	00 c0       	rjmp	.+0      	; 0x2122 <plot_scan+0x1d8>
    2122:	00 00       	nop
			_delay_ms(2000);
			display_colour(3);
    2124:	83 e0       	ldi	r24, 0x03	; 3
    2126:	90 e0       	ldi	r25, 0x00	; 0
    2128:	0e 94 6b 08 	call	0x10d6	; 0x10d6 <display_colour>
			
			ACK = 0;
    212c:	10 92 5b 07 	sts	0x075B, r1
    2130:	10 92 5a 07 	sts	0x075A, r1
			send(40,r,c);
    2134:	0f 2e       	mov	r0, r31
    2136:	f4 e0       	ldi	r31, 0x04	; 4
    2138:	8f 2e       	mov	r8, r31
    213a:	f1 e0       	ldi	r31, 0x01	; 1
    213c:	9f 2e       	mov	r9, r31
    213e:	f0 2d       	mov	r31, r0
    2140:	88 e2       	ldi	r24, 0x28	; 40
    2142:	90 e0       	ldi	r25, 0x00	; 0
    2144:	be 01       	movw	r22, r28
    2146:	a6 01       	movw	r20, r12
    2148:	f4 01       	movw	r30, r8
    214a:	19 95       	eicall
    214c:	af ef       	ldi	r26, 0xFF	; 255
    214e:	bf e8       	ldi	r27, 0x8F	; 143
    2150:	11 97       	sbiw	r26, 0x01	; 1
    2152:	f1 f7       	brne	.-4      	; 0x2150 <plot_scan+0x206>
    2154:	00 c0       	rjmp	.+0      	; 0x2156 <plot_scan+0x20c>
    2156:	00 00       	nop
			_delay_ms(10);
			if (ACK != 1)
    2158:	80 91 5a 07 	lds	r24, 0x075A
    215c:	90 91 5b 07 	lds	r25, 0x075B
    2160:	81 30       	cpi	r24, 0x01	; 1
    2162:	91 05       	cpc	r25, r1
    2164:	c9 f0       	breq	.+50     	; 0x2198 <plot_scan+0x24e>
			{
				while(ACK !=1)
    2166:	80 91 5a 07 	lds	r24, 0x075A
    216a:	90 91 5b 07 	lds	r25, 0x075B
    216e:	81 30       	cpi	r24, 0x01	; 1
    2170:	91 05       	cpc	r25, r1
    2172:	91 f0       	breq	.+36     	; 0x2198 <plot_scan+0x24e>
				{
					send(40,r,c);
    2174:	88 e2       	ldi	r24, 0x28	; 40
    2176:	90 e0       	ldi	r25, 0x00	; 0
    2178:	be 01       	movw	r22, r28
    217a:	a6 01       	movw	r20, r12
    217c:	f4 01       	movw	r30, r8
    217e:	19 95       	eicall
    2180:	86 e6       	ldi	r24, 0x66	; 102
    2182:	9e e0       	ldi	r25, 0x0E	; 14
    2184:	01 97       	sbiw	r24, 0x01	; 1
    2186:	f1 f7       	brne	.-4      	; 0x2184 <plot_scan+0x23a>
    2188:	00 00       	nop
			ACK = 0;
			send(40,r,c);
			_delay_ms(10);
			if (ACK != 1)
			{
				while(ACK !=1)
    218a:	80 91 5a 07 	lds	r24, 0x075A
    218e:	90 91 5b 07 	lds	r25, 0x075B
    2192:	81 30       	cpi	r24, 0x01	; 1
    2194:	91 05       	cpc	r25, r1
    2196:	71 f7       	brne	.-36     	; 0x2174 <plot_scan+0x22a>
				{
					send(40,r,c);
					_delay_ms(1);
				}
			}
			ACK = 0;
    2198:	10 92 5b 07 	sts	0x075B, r1
    219c:	10 92 5a 07 	sts	0x075A, r1
			
			survivor_cnt++;
    21a0:	80 91 58 07 	lds	r24, 0x0758
    21a4:	90 91 59 07 	lds	r25, 0x0759
    21a8:	01 96       	adiw	r24, 0x01	; 1
    21aa:	90 93 59 07 	sts	0x0759, r25
    21ae:	80 93 58 07 	sts	0x0758, r24
			ACK = 0;
    21b2:	10 92 5b 07 	sts	0x075B, r1
    21b6:	10 92 5a 07 	sts	0x075A, r1
			USART0_TX(50);
    21ba:	cc ef       	ldi	r28, 0xFC	; 252
    21bc:	d0 e0       	ldi	r29, 0x00	; 0
    21be:	82 e3       	ldi	r24, 0x32	; 50
    21c0:	90 e0       	ldi	r25, 0x00	; 0
    21c2:	fe 01       	movw	r30, r28
    21c4:	19 95       	eicall
			USART0_TX(survivor_cnt);
    21c6:	80 91 58 07 	lds	r24, 0x0758
    21ca:	90 91 59 07 	lds	r25, 0x0759
    21ce:	fe 01       	movw	r30, r28
    21d0:	19 95       	eicall
    21d2:	af ef       	ldi	r26, 0xFF	; 255
    21d4:	bf e8       	ldi	r27, 0x8F	; 143
    21d6:	11 97       	sbiw	r26, 0x01	; 1
    21d8:	f1 f7       	brne	.-4      	; 0x21d6 <plot_scan+0x28c>
    21da:	00 c0       	rjmp	.+0      	; 0x21dc <plot_scan+0x292>
    21dc:	00 00       	nop
			_delay_ms(10);
			if (ACK != 1)
    21de:	80 91 5a 07 	lds	r24, 0x075A
    21e2:	90 91 5b 07 	lds	r25, 0x075B
    21e6:	81 30       	cpi	r24, 0x01	; 1
    21e8:	91 05       	cpc	r25, r1
    21ea:	e9 f0       	breq	.+58     	; 0x2226 <__stack+0x27>
			{
				while(ACK !=1)
    21ec:	80 91 5a 07 	lds	r24, 0x075A
    21f0:	90 91 5b 07 	lds	r25, 0x075B
    21f4:	81 30       	cpi	r24, 0x01	; 1
    21f6:	91 05       	cpc	r25, r1
    21f8:	b1 f0       	breq	.+44     	; 0x2226 <__stack+0x27>
				{
					USART0_TX(50);
    21fa:	82 e3       	ldi	r24, 0x32	; 50
    21fc:	90 e0       	ldi	r25, 0x00	; 0
    21fe:	fe 01       	movw	r30, r28
    2200:	19 95       	eicall
					USART0_TX(survivor_cnt);
    2202:	80 91 58 07 	lds	r24, 0x0758
    2206:	90 91 59 07 	lds	r25, 0x0759
    220a:	fe 01       	movw	r30, r28
    220c:	19 95       	eicall
    220e:	86 e6       	ldi	r24, 0x66	; 102
    2210:	9e e0       	ldi	r25, 0x0E	; 14
    2212:	01 97       	sbiw	r24, 0x01	; 1
    2214:	f1 f7       	brne	.-4      	; 0x2212 <__stack+0x13>
    2216:	00 00       	nop
			USART0_TX(50);
			USART0_TX(survivor_cnt);
			_delay_ms(10);
			if (ACK != 1)
			{
				while(ACK !=1)
    2218:	80 91 5a 07 	lds	r24, 0x075A
    221c:	90 91 5b 07 	lds	r25, 0x075B
    2220:	81 30       	cpi	r24, 0x01	; 1
    2222:	91 05       	cpc	r25, r1
    2224:	51 f7       	brne	.-44     	; 0x21fa <plot_scan+0x2b0>
					USART0_TX(50);
					USART0_TX(survivor_cnt);
					_delay_ms(1);
				}
			}
			ACK = 0;
    2226:	10 92 5b 07 	sts	0x075B, r1
    222a:	10 92 5a 07 	sts	0x075A, r1
    222e:	0c c0       	rjmp	.+24     	; 0x2248 <__stack+0x49>
		}
		else
		{
			display_colour(2);
    2230:	82 e0       	ldi	r24, 0x02	; 2
    2232:	90 e0       	ldi	r25, 0x00	; 0
    2234:	0e 94 6b 08 	call	0x10d6	; 0x10d6 <display_colour>
			buzzer(2);
    2238:	82 e0       	ldi	r24, 0x02	; 2
    223a:	90 e0       	ldi	r25, 0x00	; 0
    223c:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <buzzer>
			display_colour(3);
    2240:	83 e0       	ldi	r24, 0x03	; 3
    2242:	90 e0       	ldi	r25, 0x00	; 0
    2244:	0e 94 6b 08 	call	0x10d6	; 0x10d6 <display_colour>
		}
	}
	
	if(l!=0 && b[l].pstatus!=1)
    2248:	01 15       	cp	r16, r1
    224a:	11 05       	cpc	r17, r1
    224c:	09 f4       	brne	.+2      	; 0x2250 <__stack+0x51>
    224e:	f7 c0       	rjmp	.+494    	; 0x243e <__stack+0x23f>
    2250:	f8 01       	movw	r30, r16
    2252:	ee 0f       	add	r30, r30
    2254:	ff 1f       	adc	r31, r31
    2256:	e2 95       	swap	r30
    2258:	f2 95       	swap	r31
    225a:	f0 7f       	andi	r31, 0xF0	; 240
    225c:	fe 27       	eor	r31, r30
    225e:	e0 7f       	andi	r30, 0xF0	; 240
    2260:	fe 27       	eor	r31, r30
    2262:	e6 53       	subi	r30, 0x36	; 54
    2264:	f3 4f       	sbci	r31, 0xF3	; 243
    2266:	84 89       	ldd	r24, Z+20	; 0x14
    2268:	95 89       	ldd	r25, Z+21	; 0x15
    226a:	81 30       	cpi	r24, 0x01	; 1
    226c:	91 05       	cpc	r25, r1
    226e:	09 f4       	brne	.+2      	; 0x2272 <__stack+0x73>
    2270:	e6 c0       	rjmp	.+460    	; 0x243e <__stack+0x23f>
	{
		int a = detect_white(80,400,9);
    2272:	80 e5       	ldi	r24, 0x50	; 80
    2274:	90 e0       	ldi	r25, 0x00	; 0
    2276:	60 e9       	ldi	r22, 0x90	; 144
    2278:	71 e0       	ldi	r23, 0x01	; 1
    227a:	49 e0       	ldi	r20, 0x09	; 9
    227c:	0e 94 07 03 	call	0x60e	; 0x60e <detect_white>

		if(a == 1)
    2280:	81 30       	cpi	r24, 0x01	; 1
    2282:	91 05       	cpc	r25, r1
    2284:	09 f0       	breq	.+2      	; 0x2288 <__stack+0x89>
    2286:	cf c0       	rjmp	.+414    	; 0x2426 <__stack+0x227>
		{
			{
				servo_1(150);
    2288:	86 e9       	ldi	r24, 0x96	; 150
    228a:	0e 94 17 06 	call	0xc2e	; 0xc2e <servo_1>
				c_degrees = 150;
    228e:	86 e9       	ldi	r24, 0x96	; 150
    2290:	90 e0       	ldi	r25, 0x00	; 0
    2292:	90 93 c1 0c 	sts	0x0CC1, r25
    2296:	80 93 c0 0c 	sts	0x0CC0, r24
    229a:	8f ef       	ldi	r24, 0xFF	; 255
    229c:	9f ef       	ldi	r25, 0xFF	; 255
    229e:	ac e2       	ldi	r26, 0x2C	; 44
    22a0:	81 50       	subi	r24, 0x01	; 1
    22a2:	90 40       	sbci	r25, 0x00	; 0
    22a4:	a0 40       	sbci	r26, 0x00	; 0
    22a6:	e1 f7       	brne	.-8      	; 0x22a0 <__stack+0xa1>
    22a8:	00 c0       	rjmp	.+0      	; 0x22aa <__stack+0xab>
    22aa:	00 00       	nop
				_delay_ms(1000);
				servo_2(78);
    22ac:	8e e4       	ldi	r24, 0x4E	; 78
    22ae:	0e 94 30 06 	call	0xc60	; 0xc60 <servo_2>
				servo(210);
    22b2:	82 ed       	ldi	r24, 0xD2	; 210
    22b4:	90 e0       	ldi	r25, 0x00	; 0
    22b6:	0e 94 77 06 	call	0xcee	; 0xcee <servo>
				//_delay_ms(500);
				servo(197);
    22ba:	85 ec       	ldi	r24, 0xC5	; 197
    22bc:	90 e0       	ldi	r25, 0x00	; 0
    22be:	0e 94 77 06 	call	0xcee	; 0xcee <servo>
    22c2:	a6 e6       	ldi	r26, 0x66	; 102
    22c4:	be e0       	ldi	r27, 0x0E	; 14
    22c6:	11 97       	sbiw	r26, 0x01	; 1
    22c8:	f1 f7       	brne	.-4      	; 0x22c6 <__stack+0xc7>
    22ca:	00 00       	nop
				_delay_ms(1);
				
				c = get_colour();
    22cc:	0e 94 88 07 	call	0xf10	; 0xf10 <get_colour>
    22d0:	ec 01       	movw	r28, r24
    22d2:	86 e6       	ldi	r24, 0x66	; 102
    22d4:	9e e0       	ldi	r25, 0x0E	; 14
    22d6:	01 97       	sbiw	r24, 0x01	; 1
    22d8:	f1 f7       	brne	.-4      	; 0x22d6 <__stack+0xd7>
    22da:	00 00       	nop
				_delay_ms(1);
				servo_2(180);
    22dc:	84 eb       	ldi	r24, 0xB4	; 180
    22de:	0e 94 30 06 	call	0xc60	; 0xc60 <servo_2>
    22e2:	8f ef       	ldi	r24, 0xFF	; 255
    22e4:	9f e7       	ldi	r25, 0x7F	; 127
    22e6:	ad e0       	ldi	r26, 0x0D	; 13
    22e8:	81 50       	subi	r24, 0x01	; 1
    22ea:	90 40       	sbci	r25, 0x00	; 0
    22ec:	a0 40       	sbci	r26, 0x00	; 0
    22ee:	e1 f7       	brne	.-8      	; 0x22e8 <__stack+0xe9>
    22f0:	00 c0       	rjmp	.+0      	; 0x22f2 <__stack+0xf3>
    22f2:	00 00       	nop
				_delay_ms(300);				
				servo_1(0);
    22f4:	80 e0       	ldi	r24, 0x00	; 0
    22f6:	0e 94 17 06 	call	0xc2e	; 0xc2e <servo_1>
				c_degrees = 0;
    22fa:	10 92 c1 0c 	sts	0x0CC1, r1
    22fe:	10 92 c0 0c 	sts	0x0CC0, r1
			}
			
			display_colour(c);			
    2302:	ce 01       	movw	r24, r28
    2304:	0e 94 6b 08 	call	0x10d6	; 0x10d6 <display_colour>
    2308:	8f ef       	ldi	r24, 0xFF	; 255
    230a:	9f ef       	ldi	r25, 0xFF	; 255
    230c:	a9 e5       	ldi	r26, 0x59	; 89
    230e:	81 50       	subi	r24, 0x01	; 1
    2310:	90 40       	sbci	r25, 0x00	; 0
    2312:	a0 40       	sbci	r26, 0x00	; 0
    2314:	e1 f7       	brne	.-8      	; 0x230e <__stack+0x10f>
    2316:	00 c0       	rjmp	.+0      	; 0x2318 <__stack+0x119>
    2318:	00 00       	nop
			_delay_ms(2000);
			display_colour(3);
    231a:	83 e0       	ldi	r24, 0x03	; 3
    231c:	90 e0       	ldi	r25, 0x00	; 0
    231e:	0e 94 6b 08 	call	0x10d6	; 0x10d6 <display_colour>
			
			ACK = 0;
    2322:	10 92 5b 07 	sts	0x075B, r1
    2326:	10 92 5a 07 	sts	0x075A, r1
			send(40,l,c);
    232a:	0f 2e       	mov	r0, r31
    232c:	f4 e0       	ldi	r31, 0x04	; 4
    232e:	cf 2e       	mov	r12, r31
    2330:	f1 e0       	ldi	r31, 0x01	; 1
    2332:	df 2e       	mov	r13, r31
    2334:	f0 2d       	mov	r31, r0
    2336:	88 e2       	ldi	r24, 0x28	; 40
    2338:	90 e0       	ldi	r25, 0x00	; 0
    233a:	b8 01       	movw	r22, r16
    233c:	ae 01       	movw	r20, r28
    233e:	f6 01       	movw	r30, r12
    2340:	19 95       	eicall
    2342:	af ef       	ldi	r26, 0xFF	; 255
    2344:	bf e8       	ldi	r27, 0x8F	; 143
    2346:	11 97       	sbiw	r26, 0x01	; 1
    2348:	f1 f7       	brne	.-4      	; 0x2346 <__stack+0x147>
    234a:	00 c0       	rjmp	.+0      	; 0x234c <__stack+0x14d>
    234c:	00 00       	nop
			_delay_ms(10);		
			if (ACK != 1)
    234e:	80 91 5a 07 	lds	r24, 0x075A
    2352:	90 91 5b 07 	lds	r25, 0x075B
    2356:	81 30       	cpi	r24, 0x01	; 1
    2358:	91 05       	cpc	r25, r1
    235a:	c9 f0       	breq	.+50     	; 0x238e <__stack+0x18f>
			{
				while(ACK !=1)
    235c:	80 91 5a 07 	lds	r24, 0x075A
    2360:	90 91 5b 07 	lds	r25, 0x075B
    2364:	81 30       	cpi	r24, 0x01	; 1
    2366:	91 05       	cpc	r25, r1
    2368:	91 f0       	breq	.+36     	; 0x238e <__stack+0x18f>
				{
					send(40,l,c);
    236a:	88 e2       	ldi	r24, 0x28	; 40
    236c:	90 e0       	ldi	r25, 0x00	; 0
    236e:	b8 01       	movw	r22, r16
    2370:	ae 01       	movw	r20, r28
    2372:	f6 01       	movw	r30, r12
    2374:	19 95       	eicall
    2376:	86 e6       	ldi	r24, 0x66	; 102
    2378:	9e e0       	ldi	r25, 0x0E	; 14
    237a:	01 97       	sbiw	r24, 0x01	; 1
    237c:	f1 f7       	brne	.-4      	; 0x237a <__stack+0x17b>
    237e:	00 00       	nop
			ACK = 0;
			send(40,l,c);
			_delay_ms(10);		
			if (ACK != 1)
			{
				while(ACK !=1)
    2380:	80 91 5a 07 	lds	r24, 0x075A
    2384:	90 91 5b 07 	lds	r25, 0x075B
    2388:	81 30       	cpi	r24, 0x01	; 1
    238a:	91 05       	cpc	r25, r1
    238c:	71 f7       	brne	.-36     	; 0x236a <__stack+0x16b>
				{
					send(40,l,c);
					_delay_ms(1);
				}
			}	
			ACK = 0;	
    238e:	10 92 5b 07 	sts	0x075B, r1
    2392:	10 92 5a 07 	sts	0x075A, r1
					
			survivor_cnt++;
    2396:	80 91 58 07 	lds	r24, 0x0758
    239a:	90 91 59 07 	lds	r25, 0x0759
    239e:	01 96       	adiw	r24, 0x01	; 1
    23a0:	90 93 59 07 	sts	0x0759, r25
    23a4:	80 93 58 07 	sts	0x0758, r24
			ACK = 0;
    23a8:	10 92 5b 07 	sts	0x075B, r1
    23ac:	10 92 5a 07 	sts	0x075A, r1
			USART0_TX(50);
    23b0:	cc ef       	ldi	r28, 0xFC	; 252
    23b2:	d0 e0       	ldi	r29, 0x00	; 0
    23b4:	82 e3       	ldi	r24, 0x32	; 50
    23b6:	90 e0       	ldi	r25, 0x00	; 0
    23b8:	fe 01       	movw	r30, r28
    23ba:	19 95       	eicall
			USART0_TX(survivor_cnt);
    23bc:	80 91 58 07 	lds	r24, 0x0758
    23c0:	90 91 59 07 	lds	r25, 0x0759
    23c4:	fe 01       	movw	r30, r28
    23c6:	19 95       	eicall
    23c8:	af ef       	ldi	r26, 0xFF	; 255
    23ca:	bf e8       	ldi	r27, 0x8F	; 143
    23cc:	11 97       	sbiw	r26, 0x01	; 1
    23ce:	f1 f7       	brne	.-4      	; 0x23cc <__stack+0x1cd>
    23d0:	00 c0       	rjmp	.+0      	; 0x23d2 <__stack+0x1d3>
    23d2:	00 00       	nop
			_delay_ms(10);
			if (ACK != 1)
    23d4:	80 91 5a 07 	lds	r24, 0x075A
    23d8:	90 91 5b 07 	lds	r25, 0x075B
    23dc:	81 30       	cpi	r24, 0x01	; 1
    23de:	91 05       	cpc	r25, r1
    23e0:	e9 f0       	breq	.+58     	; 0x241c <__stack+0x21d>
			{
				while(ACK !=1)
    23e2:	80 91 5a 07 	lds	r24, 0x075A
    23e6:	90 91 5b 07 	lds	r25, 0x075B
    23ea:	81 30       	cpi	r24, 0x01	; 1
    23ec:	91 05       	cpc	r25, r1
    23ee:	b1 f0       	breq	.+44     	; 0x241c <__stack+0x21d>
				{
					USART0_TX(50);
    23f0:	82 e3       	ldi	r24, 0x32	; 50
    23f2:	90 e0       	ldi	r25, 0x00	; 0
    23f4:	fe 01       	movw	r30, r28
    23f6:	19 95       	eicall
					USART0_TX(survivor_cnt);
    23f8:	80 91 58 07 	lds	r24, 0x0758
    23fc:	90 91 59 07 	lds	r25, 0x0759
    2400:	fe 01       	movw	r30, r28
    2402:	19 95       	eicall
    2404:	86 e6       	ldi	r24, 0x66	; 102
    2406:	9e e0       	ldi	r25, 0x0E	; 14
    2408:	01 97       	sbiw	r24, 0x01	; 1
    240a:	f1 f7       	brne	.-4      	; 0x2408 <__stack+0x209>
    240c:	00 00       	nop
			USART0_TX(50);
			USART0_TX(survivor_cnt);
			_delay_ms(10);
			if (ACK != 1)
			{
				while(ACK !=1)
    240e:	80 91 5a 07 	lds	r24, 0x075A
    2412:	90 91 5b 07 	lds	r25, 0x075B
    2416:	81 30       	cpi	r24, 0x01	; 1
    2418:	91 05       	cpc	r25, r1
    241a:	51 f7       	brne	.-44     	; 0x23f0 <__stack+0x1f1>
					USART0_TX(50);
					USART0_TX(survivor_cnt);
					_delay_ms(1);
				}
			}
			ACK = 0;
    241c:	10 92 5b 07 	sts	0x075B, r1
    2420:	10 92 5a 07 	sts	0x075A, r1
    2424:	0c c0       	rjmp	.+24     	; 0x243e <__stack+0x23f>
		}
		else
		{
			display_colour(2);
    2426:	82 e0       	ldi	r24, 0x02	; 2
    2428:	90 e0       	ldi	r25, 0x00	; 0
    242a:	0e 94 6b 08 	call	0x10d6	; 0x10d6 <display_colour>
			buzzer(2);
    242e:	82 e0       	ldi	r24, 0x02	; 2
    2430:	90 e0       	ldi	r25, 0x00	; 0
    2432:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <buzzer>
			display_colour(3);
    2436:	83 e0       	ldi	r24, 0x03	; 3
    2438:	90 e0       	ldi	r25, 0x00	; 0
    243a:	0e 94 6b 08 	call	0x10d6	; 0x10d6 <display_colour>
		}		
	}
	
	update(crtid,nxtid);
    243e:	c7 01       	movw	r24, r14
    2440:	b5 01       	movw	r22, r10
    2442:	0e 94 c5 0c 	call	0x198a	; 0x198a <update>
}
    2446:	df 91       	pop	r29
    2448:	cf 91       	pop	r28
    244a:	1f 91       	pop	r17
    244c:	0f 91       	pop	r16
    244e:	ff 90       	pop	r15
    2450:	ef 90       	pop	r14
    2452:	df 90       	pop	r13
    2454:	cf 90       	pop	r12
    2456:	bf 90       	pop	r11
    2458:	af 90       	pop	r10
    245a:	9f 90       	pop	r9
    245c:	8f 90       	pop	r8
    245e:	08 95       	ret

00002460 <go>:

int go(int crtnode,int nxtnode)	// To move the bot from crtnode to nxtnode
{
    2460:	ef 92       	push	r14
    2462:	ff 92       	push	r15
    2464:	0f 93       	push	r16
    2466:	1f 93       	push	r17
    2468:	cf 93       	push	r28
    246a:	df 93       	push	r29
    246c:	7c 01       	movw	r14, r24
    246e:	8b 01       	movw	r16, r22
	//lcd_print(1,5,crtnode,2);
	//lcd_print(1,8,nxtnode,2);
		
	if( nxtnode == pos[0] || crtnode == pos[1] )
    2470:	80 91 30 11 	lds	r24, 0x1130
    2474:	90 91 31 11 	lds	r25, 0x1131
    2478:	86 17       	cp	r24, r22
    247a:	97 07       	cpc	r25, r23
    247c:	39 f0       	breq	.+14     	; 0x248c <go+0x2c>
    247e:	80 91 32 11 	lds	r24, 0x1132
    2482:	90 91 33 11 	lds	r25, 0x1133
    2486:	8e 15       	cp	r24, r14
    2488:	9f 05       	cpc	r25, r15
    248a:	f1 f4       	brne	.+60     	; 0x24c8 <go+0x68>
	{	//return 2;	
		while(nxtnode == pos[0]);
    248c:	e0 e3       	ldi	r30, 0x30	; 48
    248e:	f1 e1       	ldi	r31, 0x11	; 17
    2490:	80 81       	ld	r24, Z
    2492:	91 81       	ldd	r25, Z+1	; 0x01
    2494:	80 17       	cp	r24, r16
    2496:	91 07       	cpc	r25, r17
    2498:	d9 f3       	breq	.-10     	; 0x2490 <go+0x30>
		if(nxtnode == pos[0])
    249a:	20 91 30 11 	lds	r18, 0x1130
    249e:	30 91 31 11 	lds	r19, 0x1131
    24a2:	20 17       	cp	r18, r16
    24a4:	31 07       	cpc	r19, r17
    24a6:	39 f4       	brne	.+14     	; 0x24b6 <go+0x56>
			while(nxtnode == pos[0]);
    24a8:	e0 e3       	ldi	r30, 0x30	; 48
    24aa:	f1 e1       	ldi	r31, 0x11	; 17
    24ac:	80 81       	ld	r24, Z
    24ae:	91 81       	ldd	r25, Z+1	; 0x01
    24b0:	28 17       	cp	r18, r24
    24b2:	39 07       	cpc	r19, r25
    24b4:	d9 f3       	breq	.-10     	; 0x24ac <go+0x4c>
    24b6:	8f ef       	ldi	r24, 0xFF	; 255
    24b8:	9f ef       	ldi	r25, 0xFF	; 255
    24ba:	ac e2       	ldi	r26, 0x2C	; 44
    24bc:	81 50       	subi	r24, 0x01	; 1
    24be:	90 40       	sbci	r25, 0x00	; 0
    24c0:	a0 40       	sbci	r26, 0x00	; 0
    24c2:	e1 f7       	brne	.-8      	; 0x24bc <go+0x5c>
    24c4:	00 c0       	rjmp	.+0      	; 0x24c6 <go+0x66>
    24c6:	00 00       	nop
		_delay_ms(1000);
	}
	
	//path_node(1);
	//path_mm(150);
	path_node1(1);
    24c8:	81 e0       	ldi	r24, 0x01	; 1
    24ca:	90 e0       	ldi	r25, 0x00	; 0
    24cc:	0e 94 4c 05 	call	0xa98	; 0xa98 <path_node1>
	
	if (san_flag)
    24d0:	80 91 56 07 	lds	r24, 0x0756
    24d4:	90 91 57 07 	lds	r25, 0x0757
    24d8:	00 97       	sbiw	r24, 0x00	; 0
    24da:	d9 f1       	breq	.+118    	; 0x2552 <go+0xf2>
    24dc:	af ef       	ldi	r26, 0xFF	; 255
    24de:	bf e8       	ldi	r27, 0x8F	; 143
    24e0:	11 97       	sbiw	r26, 0x01	; 1
    24e2:	f1 f7       	brne	.-4      	; 0x24e0 <go+0x80>
    24e4:	00 c0       	rjmp	.+0      	; 0x24e6 <go+0x86>
    24e6:	00 00       	nop
	{
		_delay_ms(10);
		ACK =0;
    24e8:	10 92 5b 07 	sts	0x075B, r1
    24ec:	10 92 5a 07 	sts	0x075A, r1
		USART0_TX(160);
    24f0:	cc ef       	ldi	r28, 0xFC	; 252
    24f2:	d0 e0       	ldi	r29, 0x00	; 0
    24f4:	80 ea       	ldi	r24, 0xA0	; 160
    24f6:	90 e0       	ldi	r25, 0x00	; 0
    24f8:	fe 01       	movw	r30, r28
    24fa:	19 95       	eicall
    24fc:	86 e6       	ldi	r24, 0x66	; 102
    24fe:	9e e0       	ldi	r25, 0x0E	; 14
    2500:	01 97       	sbiw	r24, 0x01	; 1
    2502:	f1 f7       	brne	.-4      	; 0x2500 <go+0xa0>
    2504:	00 00       	nop
		_delay_ms(1);
		if(ACK !=1)
    2506:	80 91 5a 07 	lds	r24, 0x075A
    250a:	90 91 5b 07 	lds	r25, 0x075B
    250e:	81 30       	cpi	r24, 0x01	; 1
    2510:	91 05       	cpc	r25, r1
    2512:	b9 f0       	breq	.+46     	; 0x2542 <go+0xe2>
		while(ACK != 1)
    2514:	80 91 5a 07 	lds	r24, 0x075A
    2518:	90 91 5b 07 	lds	r25, 0x075B
    251c:	81 30       	cpi	r24, 0x01	; 1
    251e:	91 05       	cpc	r25, r1
    2520:	81 f0       	breq	.+32     	; 0x2542 <go+0xe2>
		{
			USART0_TX(160);
    2522:	80 ea       	ldi	r24, 0xA0	; 160
    2524:	90 e0       	ldi	r25, 0x00	; 0
    2526:	fe 01       	movw	r30, r28
    2528:	19 95       	eicall
    252a:	a6 e6       	ldi	r26, 0x66	; 102
    252c:	be e0       	ldi	r27, 0x0E	; 14
    252e:	11 97       	sbiw	r26, 0x01	; 1
    2530:	f1 f7       	brne	.-4      	; 0x252e <go+0xce>
    2532:	00 00       	nop
		_delay_ms(10);
		ACK =0;
		USART0_TX(160);
		_delay_ms(1);
		if(ACK !=1)
		while(ACK != 1)
    2534:	80 91 5a 07 	lds	r24, 0x075A
    2538:	90 91 5b 07 	lds	r25, 0x075B
    253c:	81 30       	cpi	r24, 0x01	; 1
    253e:	91 05       	cpc	r25, r1
    2540:	81 f7       	brne	.-32     	; 0x2522 <go+0xc2>
		{
			USART0_TX(160);
			_delay_ms(1);
		}
		ACK = 0;
    2542:	10 92 5b 07 	sts	0x075B, r1
    2546:	10 92 5a 07 	sts	0x075A, r1
		
		san_flag = 0;
    254a:	10 92 57 07 	sts	0x0757, r1
    254e:	10 92 56 07 	sts	0x0756, r1
	}
			
	if( nxtnode == pos[0])
    2552:	c0 91 30 11 	lds	r28, 0x1130
    2556:	d0 91 31 11 	lds	r29, 0x1131
    255a:	c0 17       	cp	r28, r16
    255c:	d1 07       	cpc	r29, r17
    255e:	e1 f4       	brne	.+56     	; 0x2598 <go+0x138>
	{
		back();
    2560:	0e 94 cf 03 	call	0x79e	; 0x79e <back>
		linear_mm(210);
    2564:	62 ed       	ldi	r22, 0xD2	; 210
    2566:	70 e0       	ldi	r23, 0x00	; 0
    2568:	80 e0       	ldi	r24, 0x00	; 0
    256a:	90 e0       	ldi	r25, 0x00	; 0
    256c:	0e 94 b7 04 	call	0x96e	; 0x96e <linear_mm>
		
		while(nxtnode == pos[0]);
    2570:	e0 e3       	ldi	r30, 0x30	; 48
    2572:	f1 e1       	ldi	r31, 0x11	; 17
    2574:	80 81       	ld	r24, Z
    2576:	91 81       	ldd	r25, Z+1	; 0x01
    2578:	c8 17       	cp	r28, r24
    257a:	d9 07       	cpc	r29, r25
    257c:	d9 f3       	breq	.-10     	; 0x2574 <go+0x114>
    257e:	8f ef       	ldi	r24, 0xFF	; 255
    2580:	9f e7       	ldi	r25, 0x7F	; 127
    2582:	a3 e4       	ldi	r26, 0x43	; 67
    2584:	81 50       	subi	r24, 0x01	; 1
    2586:	90 40       	sbci	r25, 0x00	; 0
    2588:	a0 40       	sbci	r26, 0x00	; 0
    258a:	e1 f7       	brne	.-8      	; 0x2584 <go+0x124>
    258c:	00 c0       	rjmp	.+0      	; 0x258e <go+0x12e>
    258e:	00 00       	nop
		
		_delay_ms(1500);
		path_node1(1);
    2590:	81 e0       	ldi	r24, 0x01	; 1
    2592:	90 e0       	ldi	r25, 0x00	; 0
    2594:	0e 94 4c 05 	call	0xa98	; 0xa98 <path_node1>
	}
	
	if(path[crtnode][nxtnode]==0)
    2598:	2a e1       	ldi	r18, 0x1A	; 26
    259a:	30 e0       	ldi	r19, 0x00	; 0
    259c:	e2 9e       	mul	r14, r18
    259e:	c0 01       	movw	r24, r0
    25a0:	e3 9e       	mul	r14, r19
    25a2:	90 0d       	add	r25, r0
    25a4:	f2 9e       	mul	r15, r18
    25a6:	90 0d       	add	r25, r0
    25a8:	11 24       	eor	r1, r1
    25aa:	80 0f       	add	r24, r16
    25ac:	91 1f       	adc	r25, r17
    25ae:	fc 01       	movw	r30, r24
    25b0:	ee 0f       	add	r30, r30
    25b2:	ff 1f       	adc	r31, r31
    25b4:	ee 58       	subi	r30, 0x8E	; 142
    25b6:	f8 4f       	sbci	r31, 0xF8	; 248
    25b8:	80 81       	ld	r24, Z
    25ba:	91 81       	ldd	r25, Z+1	; 0x01
    25bc:	00 97       	sbiw	r24, 0x00	; 0
    25be:	21 f4       	brne	.+8      	; 0x25c8 <go+0x168>
		plot_scan(crtnode,nxtnode);	
    25c0:	c7 01       	movw	r24, r14
    25c2:	b8 01       	movw	r22, r16
    25c4:	0e 94 a5 0f 	call	0x1f4a	; 0x1f4a <plot_scan>
	
	if (san_flag)
    25c8:	80 91 56 07 	lds	r24, 0x0756
    25cc:	90 91 57 07 	lds	r25, 0x0757
    25d0:	00 97       	sbiw	r24, 0x00	; 0
    25d2:	91 f1       	breq	.+100    	; 0x2638 <go+0x1d8>
    25d4:	af ef       	ldi	r26, 0xFF	; 255
    25d6:	bf e8       	ldi	r27, 0x8F	; 143
    25d8:	11 97       	sbiw	r26, 0x01	; 1
    25da:	f1 f7       	brne	.-4      	; 0x25d8 <go+0x178>
    25dc:	00 c0       	rjmp	.+0      	; 0x25de <go+0x17e>
    25de:	00 00       	nop
	{
		_delay_ms(10);
		ACK = 0;
    25e0:	10 92 5b 07 	sts	0x075B, r1
    25e4:	10 92 5a 07 	sts	0x075A, r1
		USART0_TX(160);
    25e8:	cc ef       	ldi	r28, 0xFC	; 252
    25ea:	d0 e0       	ldi	r29, 0x00	; 0
    25ec:	80 ea       	ldi	r24, 0xA0	; 160
    25ee:	90 e0       	ldi	r25, 0x00	; 0
    25f0:	fe 01       	movw	r30, r28
    25f2:	19 95       	eicall
    25f4:	86 e6       	ldi	r24, 0x66	; 102
    25f6:	9e e0       	ldi	r25, 0x0E	; 14
    25f8:	01 97       	sbiw	r24, 0x01	; 1
    25fa:	f1 f7       	brne	.-4      	; 0x25f8 <go+0x198>
    25fc:	00 00       	nop
		_delay_ms(1);
		while(ACK == 0)
    25fe:	80 91 5a 07 	lds	r24, 0x075A
    2602:	90 91 5b 07 	lds	r25, 0x075B
    2606:	00 97       	sbiw	r24, 0x00	; 0
    2608:	79 f4       	brne	.+30     	; 0x2628 <go+0x1c8>
		{
			USART0_TX(160);
    260a:	80 ea       	ldi	r24, 0xA0	; 160
    260c:	90 e0       	ldi	r25, 0x00	; 0
    260e:	fe 01       	movw	r30, r28
    2610:	19 95       	eicall
    2612:	a6 e6       	ldi	r26, 0x66	; 102
    2614:	be e0       	ldi	r27, 0x0E	; 14
    2616:	11 97       	sbiw	r26, 0x01	; 1
    2618:	f1 f7       	brne	.-4      	; 0x2616 <go+0x1b6>
    261a:	00 00       	nop
	{
		_delay_ms(10);
		ACK = 0;
		USART0_TX(160);
		_delay_ms(1);
		while(ACK == 0)
    261c:	80 91 5a 07 	lds	r24, 0x075A
    2620:	90 91 5b 07 	lds	r25, 0x075B
    2624:	00 97       	sbiw	r24, 0x00	; 0
    2626:	89 f3       	breq	.-30     	; 0x260a <go+0x1aa>
		{
			USART0_TX(160);
			_delay_ms(1);
		}
		ACK = 0;
    2628:	10 92 5b 07 	sts	0x075B, r1
    262c:	10 92 5a 07 	sts	0x075A, r1
		san_flag = 0;
    2630:	10 92 57 07 	sts	0x0757, r1
    2634:	10 92 56 07 	sts	0x0756, r1
	}
	if( nxtnode == pos[0])
    2638:	c0 91 30 11 	lds	r28, 0x1130
    263c:	d0 91 31 11 	lds	r29, 0x1131
    2640:	c0 17       	cp	r28, r16
    2642:	d1 07       	cpc	r29, r17
    2644:	e1 f4       	brne	.+56     	; 0x267e <go+0x21e>
	{
		back();
    2646:	0e 94 cf 03 	call	0x79e	; 0x79e <back>
		linear_mm(210);
    264a:	62 ed       	ldi	r22, 0xD2	; 210
    264c:	70 e0       	ldi	r23, 0x00	; 0
    264e:	80 e0       	ldi	r24, 0x00	; 0
    2650:	90 e0       	ldi	r25, 0x00	; 0
    2652:	0e 94 b7 04 	call	0x96e	; 0x96e <linear_mm>
		
		while(nxtnode == pos[0]);
    2656:	e0 e3       	ldi	r30, 0x30	; 48
    2658:	f1 e1       	ldi	r31, 0x11	; 17
    265a:	80 81       	ld	r24, Z
    265c:	91 81       	ldd	r25, Z+1	; 0x01
    265e:	c8 17       	cp	r28, r24
    2660:	d9 07       	cpc	r29, r25
    2662:	d9 f3       	breq	.-10     	; 0x265a <go+0x1fa>
    2664:	8f ef       	ldi	r24, 0xFF	; 255
    2666:	9f e7       	ldi	r25, 0x7F	; 127
    2668:	a3 e4       	ldi	r26, 0x43	; 67
    266a:	81 50       	subi	r24, 0x01	; 1
    266c:	90 40       	sbci	r25, 0x00	; 0
    266e:	a0 40       	sbci	r26, 0x00	; 0
    2670:	e1 f7       	brne	.-8      	; 0x266a <go+0x20a>
    2672:	00 c0       	rjmp	.+0      	; 0x2674 <go+0x214>
    2674:	00 00       	nop
		
		_delay_ms(1500);
		path_node(1);
    2676:	81 e0       	ldi	r24, 0x01	; 1
    2678:	90 e0       	ldi	r25, 0x00	; 0
    267a:	0e 94 f6 04 	call	0x9ec	; 0x9ec <path_node>
	}
	
	//path_mm(150);
	path_node(1);
    267e:	81 e0       	ldi	r24, 0x01	; 1
    2680:	90 e0       	ldi	r25, 0x00	; 0
    2682:	0e 94 f6 04 	call	0x9ec	; 0x9ec <path_node>
	
	if (san_flag)
    2686:	80 91 56 07 	lds	r24, 0x0756
    268a:	90 91 57 07 	lds	r25, 0x0757
    268e:	00 97       	sbiw	r24, 0x00	; 0
    2690:	91 f1       	breq	.+100    	; 0x26f6 <go+0x296>
    2692:	af ef       	ldi	r26, 0xFF	; 255
    2694:	bf e8       	ldi	r27, 0x8F	; 143
    2696:	11 97       	sbiw	r26, 0x01	; 1
    2698:	f1 f7       	brne	.-4      	; 0x2696 <go+0x236>
    269a:	00 c0       	rjmp	.+0      	; 0x269c <go+0x23c>
    269c:	00 00       	nop
	{
		_delay_ms(10);
		ACK = 0;
    269e:	10 92 5b 07 	sts	0x075B, r1
    26a2:	10 92 5a 07 	sts	0x075A, r1
		USART0_TX(160);
    26a6:	cc ef       	ldi	r28, 0xFC	; 252
    26a8:	d0 e0       	ldi	r29, 0x00	; 0
    26aa:	80 ea       	ldi	r24, 0xA0	; 160
    26ac:	90 e0       	ldi	r25, 0x00	; 0
    26ae:	fe 01       	movw	r30, r28
    26b0:	19 95       	eicall
    26b2:	86 e6       	ldi	r24, 0x66	; 102
    26b4:	9e e0       	ldi	r25, 0x0E	; 14
    26b6:	01 97       	sbiw	r24, 0x01	; 1
    26b8:	f1 f7       	brne	.-4      	; 0x26b6 <go+0x256>
    26ba:	00 00       	nop
		_delay_ms(1);
		while(ACK == 0)
    26bc:	80 91 5a 07 	lds	r24, 0x075A
    26c0:	90 91 5b 07 	lds	r25, 0x075B
    26c4:	00 97       	sbiw	r24, 0x00	; 0
    26c6:	79 f4       	brne	.+30     	; 0x26e6 <go+0x286>
		{
			USART0_TX(160);
    26c8:	80 ea       	ldi	r24, 0xA0	; 160
    26ca:	90 e0       	ldi	r25, 0x00	; 0
    26cc:	fe 01       	movw	r30, r28
    26ce:	19 95       	eicall
    26d0:	a6 e6       	ldi	r26, 0x66	; 102
    26d2:	be e0       	ldi	r27, 0x0E	; 14
    26d4:	11 97       	sbiw	r26, 0x01	; 1
    26d6:	f1 f7       	brne	.-4      	; 0x26d4 <go+0x274>
    26d8:	00 00       	nop
	{
		_delay_ms(10);
		ACK = 0;
		USART0_TX(160);
		_delay_ms(1);
		while(ACK == 0)
    26da:	80 91 5a 07 	lds	r24, 0x075A
    26de:	90 91 5b 07 	lds	r25, 0x075B
    26e2:	00 97       	sbiw	r24, 0x00	; 0
    26e4:	89 f3       	breq	.-30     	; 0x26c8 <go+0x268>
		{
			USART0_TX(160);
			_delay_ms(1);
		}
		ACK = 0;
    26e6:	10 92 5b 07 	sts	0x075B, r1
    26ea:	10 92 5a 07 	sts	0x075A, r1
		san_flag = 0;
    26ee:	10 92 57 07 	sts	0x0757, r1
    26f2:	10 92 56 07 	sts	0x0756, r1
	}
	
	update(crtnode,nxtnode);//update(crt_node,nxtnode);
    26f6:	c7 01       	movw	r24, r14
    26f8:	b8 01       	movw	r22, r16
    26fa:	0e 94 c5 0c 	call	0x198a	; 0x198a <update>
	
	return 0;
}
    26fe:	80 e0       	ldi	r24, 0x00	; 0
    2700:	90 e0       	ldi	r25, 0x00	; 0
    2702:	df 91       	pop	r29
    2704:	cf 91       	pop	r28
    2706:	1f 91       	pop	r17
    2708:	0f 91       	pop	r16
    270a:	ff 90       	pop	r15
    270c:	ef 90       	pop	r14
    270e:	08 95       	ret

00002710 <goto_n>:

int goto_n(int c_node,int d_node)
{
    2710:	ef 92       	push	r14
    2712:	ff 92       	push	r15
    2714:	0f 93       	push	r16
    2716:	1f 93       	push	r17
    2718:	cf 93       	push	r28
    271a:	df 93       	push	r29
    271c:	ec 01       	movw	r28, r24
    271e:	8b 01       	movw	r16, r22
	ACK = 0;
    2720:	10 92 5b 07 	sts	0x075B, r1
    2724:	10 92 5a 07 	sts	0x075A, r1
	send(80,c_node,d_node);
    2728:	0f 2e       	mov	r0, r31
    272a:	f4 e0       	ldi	r31, 0x04	; 4
    272c:	ef 2e       	mov	r14, r31
    272e:	f1 e0       	ldi	r31, 0x01	; 1
    2730:	ff 2e       	mov	r15, r31
    2732:	f0 2d       	mov	r31, r0
    2734:	80 e5       	ldi	r24, 0x50	; 80
    2736:	90 e0       	ldi	r25, 0x00	; 0
    2738:	be 01       	movw	r22, r28
    273a:	a8 01       	movw	r20, r16
    273c:	f7 01       	movw	r30, r14
    273e:	19 95       	eicall
    2740:	8f ef       	ldi	r24, 0xFF	; 255
    2742:	9f e8       	ldi	r25, 0x8F	; 143
    2744:	01 97       	sbiw	r24, 0x01	; 1
    2746:	f1 f7       	brne	.-4      	; 0x2744 <goto_n+0x34>
    2748:	00 c0       	rjmp	.+0      	; 0x274a <goto_n+0x3a>
    274a:	00 00       	nop
	_delay_ms(10);
	if (ACK != 1)
    274c:	80 91 5a 07 	lds	r24, 0x075A
    2750:	90 91 5b 07 	lds	r25, 0x075B
    2754:	81 30       	cpi	r24, 0x01	; 1
    2756:	91 05       	cpc	r25, r1
    2758:	c9 f0       	breq	.+50     	; 0x278c <goto_n+0x7c>
	{
		while(ACK !=1)
    275a:	80 91 5a 07 	lds	r24, 0x075A
    275e:	90 91 5b 07 	lds	r25, 0x075B
    2762:	81 30       	cpi	r24, 0x01	; 1
    2764:	91 05       	cpc	r25, r1
    2766:	91 f0       	breq	.+36     	; 0x278c <goto_n+0x7c>
		{
			send(80,c_node,d_node);
    2768:	80 e5       	ldi	r24, 0x50	; 80
    276a:	90 e0       	ldi	r25, 0x00	; 0
    276c:	be 01       	movw	r22, r28
    276e:	a8 01       	movw	r20, r16
    2770:	f7 01       	movw	r30, r14
    2772:	19 95       	eicall
    2774:	a6 e6       	ldi	r26, 0x66	; 102
    2776:	be e0       	ldi	r27, 0x0E	; 14
    2778:	11 97       	sbiw	r26, 0x01	; 1
    277a:	f1 f7       	brne	.-4      	; 0x2778 <goto_n+0x68>
    277c:	00 00       	nop
	ACK = 0;
	send(80,c_node,d_node);
	_delay_ms(10);
	if (ACK != 1)
	{
		while(ACK !=1)
    277e:	80 91 5a 07 	lds	r24, 0x075A
    2782:	90 91 5b 07 	lds	r25, 0x075B
    2786:	81 30       	cpi	r24, 0x01	; 1
    2788:	91 05       	cpc	r25, r1
    278a:	71 f7       	brne	.-36     	; 0x2768 <goto_n+0x58>
		{
			send(80,c_node,d_node);
			_delay_ms(1);
		}
	}
	ACK = 0;
    278c:	10 92 5b 07 	sts	0x075B, r1
    2790:	10 92 5a 07 	sts	0x075A, r1
	
	turn(c_node,d_node);
    2794:	ce 01       	movw	r24, r28
    2796:	b8 01       	movw	r22, r16
    2798:	0e 94 ea 0d 	call	0x1bd4	; 0x1bd4 <turn>
	lcd_print(1,6,c_node,2);
    279c:	81 e0       	ldi	r24, 0x01	; 1
    279e:	66 e0       	ldi	r22, 0x06	; 6
    27a0:	ae 01       	movw	r20, r28
    27a2:	22 e0       	ldi	r18, 0x02	; 2
    27a4:	30 e0       	ldi	r19, 0x00	; 0
    27a6:	0e 94 00 02 	call	0x400	; 0x400 <lcd_print>
	lcd_print(1,10,d_node,2);
    27aa:	81 e0       	ldi	r24, 0x01	; 1
    27ac:	6a e0       	ldi	r22, 0x0A	; 10
    27ae:	a8 01       	movw	r20, r16
    27b0:	22 e0       	ldi	r18, 0x02	; 2
    27b2:	30 e0       	ldi	r19, 0x00	; 0
    27b4:	0e 94 00 02 	call	0x400	; 0x400 <lcd_print>
	int retval=0;

	if(cost[c_node][d_node]==IN)
    27b8:	2a e1       	ldi	r18, 0x1A	; 26
    27ba:	30 e0       	ldi	r19, 0x00	; 0
    27bc:	c2 9f       	mul	r28, r18
    27be:	c0 01       	movw	r24, r0
    27c0:	c3 9f       	mul	r28, r19
    27c2:	90 0d       	add	r25, r0
    27c4:	d2 9f       	mul	r29, r18
    27c6:	90 0d       	add	r25, r0
    27c8:	11 24       	eor	r1, r1
    27ca:	80 0f       	add	r24, r16
    27cc:	91 1f       	adc	r25, r17
    27ce:	fc 01       	movw	r30, r24
    27d0:	ee 0f       	add	r30, r30
    27d2:	ff 1f       	adc	r31, r31
    27d4:	e0 50       	subi	r30, 0x00	; 0
    27d6:	fe 4f       	sbci	r31, 0xFE	; 254
    27d8:	80 81       	ld	r24, Z
    27da:	91 81       	ldd	r25, Z+1	; 0x01
    27dc:	83 36       	cpi	r24, 0x63	; 99
    27de:	91 05       	cpc	r25, r1
    27e0:	f1 f1       	breq	.+124    	; 0x285e <goto_n+0x14e>
	{
		retval=-1;
	}
	else if(path[c_node][d_node]==1)
    27e2:	c2 9f       	mul	r28, r18
    27e4:	c0 01       	movw	r24, r0
    27e6:	c3 9f       	mul	r28, r19
    27e8:	90 0d       	add	r25, r0
    27ea:	d2 9f       	mul	r29, r18
    27ec:	90 0d       	add	r25, r0
    27ee:	11 24       	eor	r1, r1
    27f0:	80 0f       	add	r24, r16
    27f2:	91 1f       	adc	r25, r17
    27f4:	fc 01       	movw	r30, r24
    27f6:	ee 0f       	add	r30, r30
    27f8:	ff 1f       	adc	r31, r31
    27fa:	ee 58       	subi	r30, 0x8E	; 142
    27fc:	f8 4f       	sbci	r31, 0xF8	; 248
    27fe:	80 81       	ld	r24, Z
    2800:	91 81       	ldd	r25, Z+1	; 0x01
    2802:	81 30       	cpi	r24, 0x01	; 1
    2804:	91 05       	cpc	r25, r1
    2806:	71 f4       	brne	.+28     	; 0x2824 <goto_n+0x114>
	{
		count++;
    2808:	80 91 64 07 	lds	r24, 0x0764
    280c:	90 91 65 07 	lds	r25, 0x0765
    2810:	01 96       	adiw	r24, 0x01	; 1
    2812:	90 93 65 07 	sts	0x0765, r25
    2816:	80 93 64 07 	sts	0x0764, r24
		retval = go(c_node,d_node);
    281a:	ce 01       	movw	r24, r28
    281c:	b8 01       	movw	r22, r16
    281e:	0e 94 30 12 	call	0x2460	; 0x2460 <go>
    2822:	22 c0       	rjmp	.+68     	; 0x2868 <goto_n+0x158>
    2824:	8f ef       	ldi	r24, 0xFF	; 255
    2826:	9f e3       	ldi	r25, 0x3F	; 63
    2828:	a2 e0       	ldi	r26, 0x02	; 2
    282a:	81 50       	subi	r24, 0x01	; 1
    282c:	90 40       	sbci	r25, 0x00	; 0
    282e:	a0 40       	sbci	r26, 0x00	; 0
    2830:	e1 f7       	brne	.-8      	; 0x282a <goto_n+0x11a>
    2832:	00 c0       	rjmp	.+0      	; 0x2834 <goto_n+0x124>
    2834:	00 00       	nop
	}		
	else
	{
		_delay_ms(50);
		int abs = detect_block(c_node,d_node);
    2836:	ce 01       	movw	r24, r28
    2838:	b8 01       	movw	r22, r16
    283a:	0e 94 2f 0f 	call	0x1e5e	; 0x1e5e <detect_block>

		if(abs)
    283e:	00 97       	sbiw	r24, 0x00	; 0
    2840:	89 f4       	brne	.+34     	; 0x2864 <goto_n+0x154>
		{
			retval=-1;
		}
		else
		{
			count++;
    2842:	80 91 64 07 	lds	r24, 0x0764
    2846:	90 91 65 07 	lds	r25, 0x0765
    284a:	01 96       	adiw	r24, 0x01	; 1
    284c:	90 93 65 07 	sts	0x0765, r25
    2850:	80 93 64 07 	sts	0x0764, r24
			retval = go(c_node,d_node);
    2854:	ce 01       	movw	r24, r28
    2856:	b8 01       	movw	r22, r16
    2858:	0e 94 30 12 	call	0x2460	; 0x2460 <go>
    285c:	05 c0       	rjmp	.+10     	; 0x2868 <goto_n+0x158>
	lcd_print(1,10,d_node,2);
	int retval=0;

	if(cost[c_node][d_node]==IN)
	{
		retval=-1;
    285e:	8f ef       	ldi	r24, 0xFF	; 255
    2860:	9f ef       	ldi	r25, 0xFF	; 255
    2862:	02 c0       	rjmp	.+4      	; 0x2868 <goto_n+0x158>
		_delay_ms(50);
		int abs = detect_block(c_node,d_node);

		if(abs)
		{
			retval=-1;
    2864:	8f ef       	ldi	r24, 0xFF	; 255
    2866:	9f ef       	ldi	r25, 0xFF	; 255
			count++;
			retval = go(c_node,d_node);
		}
	}
	return retval;
}
    2868:	df 91       	pop	r29
    286a:	cf 91       	pop	r28
    286c:	1f 91       	pop	r17
    286e:	0f 91       	pop	r16
    2870:	ff 90       	pop	r15
    2872:	ef 90       	pop	r14
    2874:	08 95       	ret

00002876 <move>:

int move(int c_node,int d_node, int d_plot)////int dst_plot
{
    2876:	8f 92       	push	r8
    2878:	9f 92       	push	r9
    287a:	af 92       	push	r10
    287c:	bf 92       	push	r11
    287e:	cf 92       	push	r12
    2880:	df 92       	push	r13
    2882:	ef 92       	push	r14
    2884:	ff 92       	push	r15
    2886:	0f 93       	push	r16
    2888:	1f 93       	push	r17
    288a:	cf 93       	push	r28
    288c:	df 93       	push	r29
    288e:	5b 01       	movw	r10, r22
    2890:	4a 01       	movw	r8, r20
	int i,a,retval=0,j=1;
	path_length = dijsktra(c_node,d_node),flag=0;
    2892:	0e 94 82 08 	call	0x1104	; 0x1104 <dijsktra>
    2896:	90 93 87 16 	sts	0x1687, r25
    289a:	80 93 86 16 	sts	0x1686, r24
    289e:	10 92 5f 07 	sts	0x075F, r1
    28a2:	10 92 5e 07 	sts	0x075E, r1
	
	//for(i=1;i<6;i++)
	//printf("%d ",n_node[i]);
	//lcd_print(2,j,n_node[i],2),j+=2;
	
	for (i = 1; i < path_length; i++)
    28a6:	82 30       	cpi	r24, 0x02	; 2
    28a8:	91 05       	cpc	r25, r1
    28aa:	0c f4       	brge	.+2      	; 0x28ae <move+0x38>
    28ac:	50 c0       	rjmp	.+160    	; 0x294e <move+0xd8>
    28ae:	0a e8       	ldi	r16, 0x8A	; 138
    28b0:	16 e1       	ldi	r17, 0x16	; 22
    28b2:	c1 e0       	ldi	r28, 0x01	; 1
    28b4:	d0 e0       	ldi	r29, 0x00	; 0
		a = goto_n(crt_node,n_node[i]);
		
		//////////////////////////////////////////////////////////////////////////
		if (a == 2)
		{
			while(n_node[i] == pos[1])
    28b6:	0f 2e       	mov	r0, r31
    28b8:	f2 e3       	ldi	r31, 0x32	; 50
    28ba:	ef 2e       	mov	r14, r31
    28bc:	f1 e1       	ldi	r31, 0x11	; 17
    28be:	ff 2e       	mov	r15, r31
    28c0:	f0 2d       	mov	r31, r0
				;
		}
		//////////////////////////////////////////////////////////////////////////
		
		if(b[d_plot].pstatus == 1)
    28c2:	c4 01       	movw	r24, r8
    28c4:	88 0f       	add	r24, r24
    28c6:	99 1f       	adc	r25, r25
    28c8:	82 95       	swap	r24
    28ca:	92 95       	swap	r25
    28cc:	90 7f       	andi	r25, 0xF0	; 240
    28ce:	98 27       	eor	r25, r24
    28d0:	80 7f       	andi	r24, 0xF0	; 240
    28d2:	98 27       	eor	r25, r24
    28d4:	0f 2e       	mov	r0, r31
    28d6:	fe ed       	ldi	r31, 0xDE	; 222
    28d8:	cf 2e       	mov	r12, r31
    28da:	fc e0       	ldi	r31, 0x0C	; 12
    28dc:	df 2e       	mov	r13, r31
    28de:	f0 2d       	mov	r31, r0
    28e0:	c8 0e       	add	r12, r24
    28e2:	d9 1e       	adc	r13, r25
	//printf("%d ",n_node[i]);
	//lcd_print(2,j,n_node[i],2),j+=2;
	
	for (i = 1; i < path_length; i++)
	{
		path_ptr = i;
    28e4:	d0 93 bb 0c 	sts	0x0CBB, r29
    28e8:	c0 93 ba 0c 	sts	0x0CBA, r28
		
		a = goto_n(crt_node,n_node[i]);
    28ec:	f8 01       	movw	r30, r16
    28ee:	60 81       	ld	r22, Z
    28f0:	71 81       	ldd	r23, Z+1	; 0x01
    28f2:	80 91 4c 07 	lds	r24, 0x074C
    28f6:	90 91 4d 07 	lds	r25, 0x074D
    28fa:	0e 94 88 13 	call	0x2710	; 0x2710 <goto_n>
    28fe:	9c 01       	movw	r18, r24
		
		//////////////////////////////////////////////////////////////////////////
		if (a == 2)
    2900:	82 30       	cpi	r24, 0x02	; 2
    2902:	91 05       	cpc	r25, r1
    2904:	49 f4       	brne	.+18     	; 0x2918 <move+0xa2>
		{
			while(n_node[i] == pos[1])
    2906:	f8 01       	movw	r30, r16
    2908:	40 81       	ld	r20, Z
    290a:	51 81       	ldd	r21, Z+1	; 0x01
    290c:	f7 01       	movw	r30, r14
    290e:	80 81       	ld	r24, Z
    2910:	91 81       	ldd	r25, Z+1	; 0x01
    2912:	48 17       	cp	r20, r24
    2914:	59 07       	cpc	r21, r25
    2916:	d1 f3       	breq	.-12     	; 0x290c <move+0x96>
				;
		}
		//////////////////////////////////////////////////////////////////////////
		
		if(b[d_plot].pstatus == 1)
    2918:	f6 01       	movw	r30, r12
    291a:	80 81       	ld	r24, Z
    291c:	91 81       	ldd	r25, Z+1	; 0x01
    291e:	81 30       	cpi	r24, 0x01	; 1
    2920:	91 05       	cpc	r25, r1
    2922:	a9 f0       	breq	.+42     	; 0x294e <move+0xd8>
			break;
		
		if(a == -1)
    2924:	ff ef       	ldi	r31, 0xFF	; 255
    2926:	2f 3f       	cpi	r18, 0xFF	; 255
    2928:	3f 07       	cpc	r19, r31
    292a:	39 f4       	brne	.+14     	; 0x293a <move+0xc4>
		{			
			flag=1;
    292c:	81 e0       	ldi	r24, 0x01	; 1
    292e:	90 e0       	ldi	r25, 0x00	; 0
    2930:	90 93 5f 07 	sts	0x075F, r25
    2934:	80 93 5e 07 	sts	0x075E, r24
			break;
    2938:	0a c0       	rjmp	.+20     	; 0x294e <move+0xd8>
	
	//for(i=1;i<6;i++)
	//printf("%d ",n_node[i]);
	//lcd_print(2,j,n_node[i],2),j+=2;
	
	for (i = 1; i < path_length; i++)
    293a:	21 96       	adiw	r28, 0x01	; 1
    293c:	0e 5f       	subi	r16, 0xFE	; 254
    293e:	1f 4f       	sbci	r17, 0xFF	; 255
    2940:	80 91 86 16 	lds	r24, 0x1686
    2944:	90 91 87 16 	lds	r25, 0x1687
    2948:	c8 17       	cp	r28, r24
    294a:	d9 07       	cpc	r29, r25
    294c:	5c f2       	brlt	.-106    	; 0x28e4 <move+0x6e>
		{			
			flag=1;
			break;
		}			
	}
	if(flag)
    294e:	80 91 5e 07 	lds	r24, 0x075E
    2952:	90 91 5f 07 	lds	r25, 0x075F
    2956:	00 97       	sbiw	r24, 0x00	; 0
    2958:	41 f0       	breq	.+16     	; 0x296a <move+0xf4>
	{
		move(crt_node,d_node,d_plot);
    295a:	80 91 4c 07 	lds	r24, 0x074C
    295e:	90 91 4d 07 	lds	r25, 0x074D
    2962:	b5 01       	movw	r22, r10
    2964:	a4 01       	movw	r20, r8
    2966:	0e 94 3b 14 	call	0x2876	; 0x2876 <move>
	}
	
	return retval;
}
    296a:	80 e0       	ldi	r24, 0x00	; 0
    296c:	90 e0       	ldi	r25, 0x00	; 0
    296e:	df 91       	pop	r29
    2970:	cf 91       	pop	r28
    2972:	1f 91       	pop	r17
    2974:	0f 91       	pop	r16
    2976:	ff 90       	pop	r15
    2978:	ef 90       	pop	r14
    297a:	df 90       	pop	r13
    297c:	cf 90       	pop	r12
    297e:	bf 90       	pop	r11
    2980:	af 90       	pop	r10
    2982:	9f 90       	pop	r9
    2984:	8f 90       	pop	r8
    2986:	08 95       	ret

00002988 <goto_home>:

int goto_home(void)
{
    2988:	0f 93       	push	r16
    298a:	1f 93       	push	r17
    298c:	cf 93       	push	r28
    298e:	df 93       	push	r29
	int i,a,retval=0,j=1;
	int n = dijsktra(crt_node,23),flag=0;
    2990:	80 91 4c 07 	lds	r24, 0x074C
    2994:	90 91 4d 07 	lds	r25, 0x074D
    2998:	67 e1       	ldi	r22, 0x17	; 23
    299a:	70 e0       	ldi	r23, 0x00	; 0
    299c:	0e 94 82 08 	call	0x1104	; 0x1104 <dijsktra>
	
	for (i=1;i<n;i++)
    29a0:	82 30       	cpi	r24, 0x02	; 2
    29a2:	91 05       	cpc	r25, r1
    29a4:	dc f0       	brlt	.+54     	; 0x29dc <goto_home+0x54>
    29a6:	0a e8       	ldi	r16, 0x8A	; 138
    29a8:	16 e1       	ldi	r17, 0x16	; 22
	}
	
	return retval;
}

int goto_home(void)
    29aa:	ec 01       	movw	r28, r24
    29ac:	cc 0f       	add	r28, r28
    29ae:	dd 1f       	adc	r29, r29
    29b0:	c8 57       	subi	r28, 0x78	; 120
    29b2:	d9 4e       	sbci	r29, 0xE9	; 233
	int i,a,retval=0,j=1;
	int n = dijsktra(crt_node,23),flag=0;
	
	for (i=1;i<n;i++)
	{
		a = goto_n(crt_node,n_node[i]);
    29b4:	f8 01       	movw	r30, r16
    29b6:	61 91       	ld	r22, Z+
    29b8:	71 91       	ld	r23, Z+
    29ba:	8f 01       	movw	r16, r30
    29bc:	80 91 4c 07 	lds	r24, 0x074C
    29c0:	90 91 4d 07 	lds	r25, 0x074D
    29c4:	0e 94 88 13 	call	0x2710	; 0x2710 <goto_n>
				
		if(a == -1)
    29c8:	ff ef       	ldi	r31, 0xFF	; 255
    29ca:	8f 3f       	cpi	r24, 0xFF	; 255
    29cc:	9f 07       	cpc	r25, r31
    29ce:	21 f0       	breq	.+8      	; 0x29d8 <goto_home+0x50>
int goto_home(void)
{
	int i,a,retval=0,j=1;
	int n = dijsktra(crt_node,23),flag=0;
	
	for (i=1;i<n;i++)
    29d0:	0c 17       	cp	r16, r28
    29d2:	1d 07       	cpc	r17, r29
    29d4:	79 f7       	brne	.-34     	; 0x29b4 <goto_home+0x2c>
    29d6:	02 c0       	rjmp	.+4      	; 0x29dc <goto_home+0x54>
			flag=1;
			break;
		}
	}
	if(flag)
		goto_home();
    29d8:	0e 94 c4 14 	call	0x2988	; 0x2988 <goto_home>
	
	return retval;
}
    29dc:	80 e0       	ldi	r24, 0x00	; 0
    29de:	90 e0       	ldi	r25, 0x00	; 0
    29e0:	df 91       	pop	r29
    29e2:	cf 91       	pop	r28
    29e4:	1f 91       	pop	r17
    29e6:	0f 91       	pop	r16
    29e8:	08 95       	ret

000029ea <search>:

int search(void)
{
    29ea:	2f 92       	push	r2
    29ec:	3f 92       	push	r3
    29ee:	4f 92       	push	r4
    29f0:	5f 92       	push	r5
    29f2:	6f 92       	push	r6
    29f4:	7f 92       	push	r7
    29f6:	8f 92       	push	r8
    29f8:	9f 92       	push	r9
    29fa:	af 92       	push	r10
    29fc:	bf 92       	push	r11
    29fe:	cf 92       	push	r12
    2a00:	df 92       	push	r13
    2a02:	ef 92       	push	r14
    2a04:	ff 92       	push	r15
    2a06:	0f 93       	push	r16
    2a08:	1f 93       	push	r17
    2a0a:	cf 93       	push	r28
    2a0c:	df 93       	push	r29
	int retv=0,i;
	int p = get_n_u_plot();
    2a0e:	0e 94 05 0e 	call	0x1c0a	; 0x1c0a <get_n_u_plot>
    2a12:	7c 01       	movw	r14, r24
	
	if(p == -1)
    2a14:	2f ef       	ldi	r18, 0xFF	; 255
    2a16:	8f 3f       	cpi	r24, 0xFF	; 255
    2a18:	92 07       	cpc	r25, r18
    2a1a:	09 f4       	brne	.+2      	; 0x2a1e <search+0x34>
    2a1c:	f5 c0       	rjmp	.+490    	; 0x2c08 <search+0x21e>

	int flag=1,flag420=0;

	for(i=1;i<=4;i++)
	{
		if(b[p].adj[i] == crt_node)
    2a1e:	80 91 4c 07 	lds	r24, 0x074C
    2a22:	90 91 4d 07 	lds	r25, 0x074D
    2a26:	f7 01       	movw	r30, r14
    2a28:	ee 0f       	add	r30, r30
    2a2a:	ff 1f       	adc	r31, r31
    2a2c:	e2 95       	swap	r30
    2a2e:	f2 95       	swap	r31
    2a30:	f0 7f       	andi	r31, 0xF0	; 240
    2a32:	fe 27       	eor	r31, r30
    2a34:	e0 7f       	andi	r30, 0xF0	; 240
    2a36:	fe 27       	eor	r31, r30
    2a38:	e6 53       	subi	r30, 0x36	; 54
    2a3a:	f3 4f       	sbci	r31, 0xF3	; 243
    2a3c:	20 8d       	ldd	r18, Z+24	; 0x18
    2a3e:	31 8d       	ldd	r19, Z+25	; 0x19
    2a40:	28 17       	cp	r18, r24
    2a42:	39 07       	cpc	r19, r25
    2a44:	b1 f1       	breq	.+108    	; 0x2ab2 <search+0xc8>
    2a46:	f7 01       	movw	r30, r14
    2a48:	ee 0f       	add	r30, r30
    2a4a:	ff 1f       	adc	r31, r31
    2a4c:	e2 95       	swap	r30
    2a4e:	f2 95       	swap	r31
    2a50:	f0 7f       	andi	r31, 0xF0	; 240
    2a52:	fe 27       	eor	r31, r30
    2a54:	e0 7f       	andi	r30, 0xF0	; 240
    2a56:	fe 27       	eor	r31, r30
    2a58:	e6 53       	subi	r30, 0x36	; 54
    2a5a:	f3 4f       	sbci	r31, 0xF3	; 243
    2a5c:	22 8d       	ldd	r18, Z+26	; 0x1a
    2a5e:	33 8d       	ldd	r19, Z+27	; 0x1b
    2a60:	28 17       	cp	r18, r24
    2a62:	39 07       	cpc	r19, r25
    2a64:	49 f1       	breq	.+82     	; 0x2ab8 <search+0xce>
    2a66:	f7 01       	movw	r30, r14
    2a68:	ee 0f       	add	r30, r30
    2a6a:	ff 1f       	adc	r31, r31
    2a6c:	e2 95       	swap	r30
    2a6e:	f2 95       	swap	r31
    2a70:	f0 7f       	andi	r31, 0xF0	; 240
    2a72:	fe 27       	eor	r31, r30
    2a74:	e0 7f       	andi	r30, 0xF0	; 240
    2a76:	fe 27       	eor	r31, r30
    2a78:	e6 53       	subi	r30, 0x36	; 54
    2a7a:	f3 4f       	sbci	r31, 0xF3	; 243
    2a7c:	24 8d       	ldd	r18, Z+28	; 0x1c
    2a7e:	35 8d       	ldd	r19, Z+29	; 0x1d
    2a80:	28 17       	cp	r18, r24
    2a82:	39 07       	cpc	r19, r25
    2a84:	e1 f0       	breq	.+56     	; 0x2abe <search+0xd4>
    2a86:	f7 01       	movw	r30, r14
    2a88:	ee 0f       	add	r30, r30
    2a8a:	ff 1f       	adc	r31, r31
    2a8c:	e2 95       	swap	r30
    2a8e:	f2 95       	swap	r31
    2a90:	f0 7f       	andi	r31, 0xF0	; 240
    2a92:	fe 27       	eor	r31, r30
    2a94:	e0 7f       	andi	r30, 0xF0	; 240
    2a96:	fe 27       	eor	r31, r30
    2a98:	e6 53       	subi	r30, 0x36	; 54
    2a9a:	f3 4f       	sbci	r31, 0xF3	; 243
		goto_home();
	
	return retval;
}

int search(void)
    2a9c:	41 e0       	ldi	r20, 0x01	; 1
    2a9e:	50 e0       	ldi	r21, 0x00	; 0
    2aa0:	26 8d       	ldd	r18, Z+30	; 0x1e
    2aa2:	37 8d       	ldd	r19, Z+31	; 0x1f
    2aa4:	28 17       	cp	r18, r24
    2aa6:	39 07       	cpc	r19, r25
    2aa8:	11 f4       	brne	.+4      	; 0x2aae <search+0xc4>
    2aaa:	40 e0       	ldi	r20, 0x00	; 0
    2aac:	50 e0       	ldi	r21, 0x00	; 0

	for(i=1;i<=4;i++)
	{
		if(b[p].adj[i] == crt_node)
		{
			flag=0;
    2aae:	5a 01       	movw	r10, r20
    2ab0:	08 c0       	rjmp	.+16     	; 0x2ac2 <search+0xd8>
    2ab2:	aa 24       	eor	r10, r10
    2ab4:	bb 24       	eor	r11, r11
    2ab6:	05 c0       	rjmp	.+10     	; 0x2ac2 <search+0xd8>
    2ab8:	aa 24       	eor	r10, r10
    2aba:	bb 24       	eor	r11, r11
    2abc:	02 c0       	rjmp	.+4      	; 0x2ac2 <search+0xd8>
    2abe:	aa 24       	eor	r10, r10
    2ac0:	bb 24       	eor	r11, r11
		goto_home();
	
	return retval;
}

int search(void)
    2ac2:	c7 01       	movw	r24, r14
    2ac4:	88 0f       	add	r24, r24
    2ac6:	99 1f       	adc	r25, r25
    2ac8:	82 95       	swap	r24
    2aca:	92 95       	swap	r25
    2acc:	90 7f       	andi	r25, 0xF0	; 240
    2ace:	98 27       	eor	r25, r24
    2ad0:	80 7f       	andi	r24, 0xF0	; 240
    2ad2:	98 27       	eor	r25, r24
    2ad4:	8c 01       	movw	r16, r24
    2ad6:	0e 51       	subi	r16, 0x1E	; 30
    2ad8:	13 4f       	sbci	r17, 0xF3	; 243
    2ada:	0f 2e       	mov	r0, r31
    2adc:	fa ee       	ldi	r31, 0xEA	; 234
    2ade:	cf 2e       	mov	r12, r31
    2ae0:	fc e0       	ldi	r31, 0x0C	; 12
    2ae2:	df 2e       	mov	r13, r31
    2ae4:	f0 2d       	mov	r31, r0
    2ae6:	c8 0e       	add	r12, r24
    2ae8:	d9 1e       	adc	r13, r25
    2aea:	e8 01       	movw	r28, r16
    2aec:	66 24       	eor	r6, r6
    2aee:	77 24       	eor	r7, r7

				if (a==1 || a==5)
				{
					int bp = goto_n(crt_node,dst_node);
					
					if(b[p].pstatus==1)
    2af0:	c7 01       	movw	r24, r14
    2af2:	88 0f       	add	r24, r24
    2af4:	99 1f       	adc	r25, r25
    2af6:	82 95       	swap	r24
    2af8:	92 95       	swap	r25
    2afa:	90 7f       	andi	r25, 0xF0	; 240
    2afc:	98 27       	eor	r25, r24
    2afe:	80 7f       	andi	r24, 0xF0	; 240
    2b00:	98 27       	eor	r25, r24
    2b02:	0f 2e       	mov	r0, r31
    2b04:	fe ed       	ldi	r31, 0xDE	; 222
    2b06:	8f 2e       	mov	r8, r31
    2b08:	fc e0       	ldi	r31, 0x0C	; 12
    2b0a:	9f 2e       	mov	r9, r31
    2b0c:	f0 2d       	mov	r31, r0
    2b0e:	88 0e       	add	r8, r24
    2b10:	99 1e       	adc	r9, r25
					break;
					}
				}
				else
				{
					flag420=1;
    2b12:	44 24       	eor	r4, r4
    2b14:	55 24       	eor	r5, r5
    2b16:	43 94       	inc	r4
			{
				move(crt_node, dst_node,p);
				if(b[p].pstatus==1)
				//break;
					return 1;
				flag=0;
    2b18:	22 24       	eor	r2, r2
    2b1a:	33 24       	eor	r3, r3
		}
	}

	for(i=1;i<=4;i++)
	{
		if(b[p].adj[i] != 0)
    2b1c:	69 91       	ld	r22, Y+
    2b1e:	79 91       	ld	r23, Y+
    2b20:	61 15       	cp	r22, r1
    2b22:	71 05       	cpc	r23, r1
    2b24:	09 f4       	brne	.+2      	; 0x2b28 <search+0x13e>
    2b26:	40 c0       	rjmp	.+128    	; 0x2ba8 <search+0x1be>
		{
			dst_node = b[p].adj[i];
    2b28:	70 93 6d 07 	sts	0x076D, r23
    2b2c:	60 93 6c 07 	sts	0x076C, r22
	
			if (flag)
    2b30:	a1 14       	cp	r10, r1
    2b32:	b1 04       	cpc	r11, r1
    2b34:	81 f0       	breq	.+32     	; 0x2b56 <search+0x16c>
			{
				move(crt_node, dst_node,p);
    2b36:	80 91 4c 07 	lds	r24, 0x074C
    2b3a:	90 91 4d 07 	lds	r25, 0x074D
    2b3e:	a7 01       	movw	r20, r14
    2b40:	0e 94 3b 14 	call	0x2876	; 0x2876 <move>
				if(b[p].pstatus==1)
    2b44:	f4 01       	movw	r30, r8
    2b46:	80 81       	ld	r24, Z
    2b48:	91 81       	ldd	r25, Z+1	; 0x01
    2b4a:	81 30       	cpi	r24, 0x01	; 1
    2b4c:	91 05       	cpc	r25, r1
    2b4e:	09 f4       	brne	.+2      	; 0x2b52 <search+0x168>
    2b50:	5e c0       	rjmp	.+188    	; 0x2c0e <search+0x224>
				//break;
					return 1;
				flag=0;
    2b52:	51 01       	movw	r10, r2
    2b54:	29 c0       	rjmp	.+82     	; 0x2ba8 <search+0x1be>
			}
			else
			{
				int a=abs(dst_node - crt_node);
    2b56:	20 91 4c 07 	lds	r18, 0x074C
    2b5a:	30 91 4d 07 	lds	r19, 0x074D
    2b5e:	cb 01       	movw	r24, r22
    2b60:	82 1b       	sub	r24, r18
    2b62:	93 0b       	sbc	r25, r19
    2b64:	1a f4       	brpl	.+6      	; 0x2b6c <search+0x182>
    2b66:	90 95       	com	r25
    2b68:	81 95       	neg	r24
    2b6a:	9f 4f       	sbci	r25, 0xFF	; 255

				if (a==1 || a==5)
    2b6c:	81 30       	cpi	r24, 0x01	; 1
    2b6e:	91 05       	cpc	r25, r1
    2b70:	19 f0       	breq	.+6      	; 0x2b78 <search+0x18e>
    2b72:	85 30       	cpi	r24, 0x05	; 5
    2b74:	91 05       	cpc	r25, r1
    2b76:	89 f4       	brne	.+34     	; 0x2b9a <search+0x1b0>
				{
					int bp = goto_n(crt_node,dst_node);
    2b78:	c9 01       	movw	r24, r18
    2b7a:	0e 94 88 13 	call	0x2710	; 0x2710 <goto_n>
					
					if(b[p].pstatus==1)
    2b7e:	f4 01       	movw	r30, r8
    2b80:	20 81       	ld	r18, Z
    2b82:	31 81       	ldd	r19, Z+1	; 0x01
    2b84:	21 30       	cpi	r18, 0x01	; 1
    2b86:	31 05       	cpc	r19, r1
    2b88:	09 f4       	brne	.+2      	; 0x2b8c <search+0x1a2>
    2b8a:	44 c0       	rjmp	.+136    	; 0x2c14 <search+0x22a>
					//break;
					return 1;
					if(bp == -1)
    2b8c:	ff ef       	ldi	r31, 0xFF	; 255
    2b8e:	8f 3f       	cpi	r24, 0xFF	; 255
    2b90:	9f 07       	cpc	r25, r31
    2b92:	51 f0       	breq	.+20     	; 0x2ba8 <search+0x1be>
				if(b[p].pstatus==1)
					return 1;
			}
		}

	return retv;
    2b94:	80 e0       	ldi	r24, 0x00	; 0
    2b96:	90 e0       	ldi	r25, 0x00	; 0
    2b98:	48 c0       	rjmp	.+144    	; 0x2c2a <search+0x240>
					}
				}
				else
				{
					flag420=1;
					if(b[p].pstatus==1)
    2b9a:	f4 01       	movw	r30, r8
    2b9c:	80 81       	ld	r24, Z
    2b9e:	91 81       	ldd	r25, Z+1	; 0x01
    2ba0:	81 30       	cpi	r24, 0x01	; 1
    2ba2:	91 05       	cpc	r25, r1
    2ba4:	d1 f1       	breq	.+116    	; 0x2c1a <search+0x230>
					break;
					}
				}
				else
				{
					flag420=1;
    2ba6:	32 01       	movw	r6, r4
			flag=0;
			break;
		}
	}

	for(i=1;i<=4;i++)
    2ba8:	cc 15       	cp	r28, r12
    2baa:	dd 05       	cpc	r29, r13
    2bac:	09 f0       	breq	.+2      	; 0x2bb0 <search+0x1c6>
    2bae:	b6 cf       	rjmp	.-148    	; 0x2b1c <search+0x132>
						return 1;
				}
			}
		}
	}
	if(flag420)
    2bb0:	61 14       	cp	r6, r1
    2bb2:	71 04       	cpc	r7, r1
    2bb4:	a9 f1       	breq	.+106    	; 0x2c20 <search+0x236>
			if(b[p].adj[i]!=0)
			{
				dst_node = b[p].adj[i];
	
				move(crt_node, dst_node,p);
				if(b[p].pstatus==1)
    2bb6:	c7 01       	movw	r24, r14
    2bb8:	88 0f       	add	r24, r24
    2bba:	99 1f       	adc	r25, r25
    2bbc:	82 95       	swap	r24
    2bbe:	92 95       	swap	r25
    2bc0:	90 7f       	andi	r25, 0xF0	; 240
    2bc2:	98 27       	eor	r25, r24
    2bc4:	80 7f       	andi	r24, 0xF0	; 240
    2bc6:	98 27       	eor	r25, r24
    2bc8:	ec 01       	movw	r28, r24
    2bca:	c2 52       	subi	r28, 0x22	; 34
    2bcc:	d3 4f       	sbci	r29, 0xF3	; 243
		}
	}
	if(flag420)
		for(i=1;i<=4;i++)
		{
			if(b[p].adj[i]!=0)
    2bce:	f8 01       	movw	r30, r16
    2bd0:	61 91       	ld	r22, Z+
    2bd2:	71 91       	ld	r23, Z+
    2bd4:	8f 01       	movw	r16, r30
    2bd6:	61 15       	cp	r22, r1
    2bd8:	71 05       	cpc	r23, r1
    2bda:	81 f0       	breq	.+32     	; 0x2bfc <search+0x212>
			{
				dst_node = b[p].adj[i];
    2bdc:	70 93 6d 07 	sts	0x076D, r23
    2be0:	60 93 6c 07 	sts	0x076C, r22
	
				move(crt_node, dst_node,p);
    2be4:	80 91 4c 07 	lds	r24, 0x074C
    2be8:	90 91 4d 07 	lds	r25, 0x074D
    2bec:	a7 01       	movw	r20, r14
    2bee:	0e 94 3b 14 	call	0x2876	; 0x2876 <move>
				if(b[p].pstatus==1)
    2bf2:	88 81       	ld	r24, Y
    2bf4:	99 81       	ldd	r25, Y+1	; 0x01
    2bf6:	81 30       	cpi	r24, 0x01	; 1
    2bf8:	91 05       	cpc	r25, r1
    2bfa:	a9 f0       	breq	.+42     	; 0x2c26 <search+0x23c>
				}
			}
		}
	}
	if(flag420)
		for(i=1;i<=4;i++)
    2bfc:	0c 15       	cp	r16, r12
    2bfe:	1d 05       	cpc	r17, r13
    2c00:	31 f7       	brne	.-52     	; 0x2bce <search+0x1e4>
				if(b[p].pstatus==1)
					return 1;
			}
		}

	return retv;
    2c02:	80 e0       	ldi	r24, 0x00	; 0
    2c04:	90 e0       	ldi	r25, 0x00	; 0
    2c06:	11 c0       	rjmp	.+34     	; 0x2c2a <search+0x240>
	int p = get_n_u_plot();
	
	if(p == -1)
	{
		retv=-1;
		return retv;
    2c08:	8f ef       	ldi	r24, 0xFF	; 255
    2c0a:	9f ef       	ldi	r25, 0xFF	; 255
    2c0c:	0e c0       	rjmp	.+28     	; 0x2c2a <search+0x240>
			if (flag)
			{
				move(crt_node, dst_node,p);
				if(b[p].pstatus==1)
				//break;
					return 1;
    2c0e:	81 e0       	ldi	r24, 0x01	; 1
    2c10:	90 e0       	ldi	r25, 0x00	; 0
    2c12:	0b c0       	rjmp	.+22     	; 0x2c2a <search+0x240>
				{
					int bp = goto_n(crt_node,dst_node);
					
					if(b[p].pstatus==1)
					//break;
					return 1;
    2c14:	81 e0       	ldi	r24, 0x01	; 1
    2c16:	90 e0       	ldi	r25, 0x00	; 0
    2c18:	08 c0       	rjmp	.+16     	; 0x2c2a <search+0x240>
				}
				else
				{
					flag420=1;
					if(b[p].pstatus==1)
						return 1;
    2c1a:	81 e0       	ldi	r24, 0x01	; 1
    2c1c:	90 e0       	ldi	r25, 0x00	; 0
    2c1e:	05 c0       	rjmp	.+10     	; 0x2c2a <search+0x240>
				if(b[p].pstatus==1)
					return 1;
			}
		}

	return retv;
    2c20:	80 e0       	ldi	r24, 0x00	; 0
    2c22:	90 e0       	ldi	r25, 0x00	; 0
    2c24:	02 c0       	rjmp	.+4      	; 0x2c2a <search+0x240>
			{
				dst_node = b[p].adj[i];
	
				move(crt_node, dst_node,p);
				if(b[p].pstatus==1)
					return 1;
    2c26:	81 e0       	ldi	r24, 0x01	; 1
    2c28:	90 e0       	ldi	r25, 0x00	; 0
			}
		}

	return retv;
}
    2c2a:	df 91       	pop	r29
    2c2c:	cf 91       	pop	r28
    2c2e:	1f 91       	pop	r17
    2c30:	0f 91       	pop	r16
    2c32:	ff 90       	pop	r15
    2c34:	ef 90       	pop	r14
    2c36:	df 90       	pop	r13
    2c38:	cf 90       	pop	r12
    2c3a:	bf 90       	pop	r11
    2c3c:	af 90       	pop	r10
    2c3e:	9f 90       	pop	r9
    2c40:	8f 90       	pop	r8
    2c42:	7f 90       	pop	r7
    2c44:	6f 90       	pop	r6
    2c46:	5f 90       	pop	r5
    2c48:	4f 90       	pop	r4
    2c4a:	3f 90       	pop	r3
    2c4c:	2f 90       	pop	r2
    2c4e:	08 95       	ret

00002c50 <uart0_init>:
// actual baud rate:9600 (error 0.0%)
// char size: 8 bit
// parity: Disabled
void uart0_init(void)
{
	UCSR0B = 0x00; //disable while setting baud rate
    2c50:	e1 ec       	ldi	r30, 0xC1	; 193
    2c52:	f0 e0       	ldi	r31, 0x00	; 0
    2c54:	10 82       	st	Z, r1
	UCSR0A = 0x00;
    2c56:	10 92 c0 00 	sts	0x00C0, r1
	UCSR0C = 0x06;
    2c5a:	86 e0       	ldi	r24, 0x06	; 6
    2c5c:	80 93 c2 00 	sts	0x00C2, r24
	UBRR0L = 0x5F; //set baud rate lo
    2c60:	8f e5       	ldi	r24, 0x5F	; 95
    2c62:	80 93 c4 00 	sts	0x00C4, r24
	UBRR0H = 0x00; //set baud rate hi
    2c66:	10 92 c5 00 	sts	0x00C5, r1
	UCSR0B = 0x98;
    2c6a:	88 e9       	ldi	r24, 0x98	; 152
    2c6c:	80 83       	st	Z, r24
}
    2c6e:	08 95       	ret

00002c70 <__vector_25>:

volatile int clear_flag=0,clear_flag1=0;
volatile int node_flag=0,node_search,detect_flag=0;
SIGNAL(SIG_USART0_RECV) 		// ISR for receive complete interrupt
{
    2c70:	1f 92       	push	r1
    2c72:	0f 92       	push	r0
    2c74:	0f b6       	in	r0, 0x3f	; 63
    2c76:	0f 92       	push	r0
    2c78:	0b b6       	in	r0, 0x3b	; 59
    2c7a:	0f 92       	push	r0
    2c7c:	11 24       	eor	r1, r1
    2c7e:	0f 93       	push	r16
    2c80:	1f 93       	push	r17
    2c82:	2f 93       	push	r18
    2c84:	3f 93       	push	r19
    2c86:	4f 93       	push	r20
    2c88:	5f 93       	push	r21
    2c8a:	6f 93       	push	r22
    2c8c:	7f 93       	push	r23
    2c8e:	8f 93       	push	r24
    2c90:	9f 93       	push	r25
    2c92:	af 93       	push	r26
    2c94:	bf 93       	push	r27
    2c96:	cf 93       	push	r28
    2c98:	df 93       	push	r29
    2c9a:	ef 93       	push	r30
    2c9c:	ff 93       	push	r31
	data = UDR0; 				//making copy of data from UDR0 in 'data' variable
    2c9e:	80 91 c6 00 	lds	r24, 0x00C6
    2ca2:	90 e0       	ldi	r25, 0x00	; 0
    2ca4:	90 93 05 17 	sts	0x1705, r25
    2ca8:	80 93 04 17 	sts	0x1704, r24
	
	//lcd_print(1,1,data,3);
		
	if (data == 30 || data == 50 || data == 70 || data == 85 || data == 90 || data == 100)
    2cac:	80 91 04 17 	lds	r24, 0x1704
    2cb0:	90 91 05 17 	lds	r25, 0x1705
    2cb4:	8e 31       	cpi	r24, 0x1E	; 30
    2cb6:	91 05       	cpc	r25, r1
    2cb8:	21 f1       	breq	.+72     	; 0x2d02 <__vector_25+0x92>
    2cba:	80 91 04 17 	lds	r24, 0x1704
    2cbe:	90 91 05 17 	lds	r25, 0x1705
    2cc2:	82 33       	cpi	r24, 0x32	; 50
    2cc4:	91 05       	cpc	r25, r1
    2cc6:	e9 f0       	breq	.+58     	; 0x2d02 <__vector_25+0x92>
    2cc8:	80 91 04 17 	lds	r24, 0x1704
    2ccc:	90 91 05 17 	lds	r25, 0x1705
    2cd0:	86 34       	cpi	r24, 0x46	; 70
    2cd2:	91 05       	cpc	r25, r1
    2cd4:	b1 f0       	breq	.+44     	; 0x2d02 <__vector_25+0x92>
    2cd6:	80 91 04 17 	lds	r24, 0x1704
    2cda:	90 91 05 17 	lds	r25, 0x1705
    2cde:	85 35       	cpi	r24, 0x55	; 85
    2ce0:	91 05       	cpc	r25, r1
    2ce2:	79 f0       	breq	.+30     	; 0x2d02 <__vector_25+0x92>
    2ce4:	80 91 04 17 	lds	r24, 0x1704
    2ce8:	90 91 05 17 	lds	r25, 0x1705
    2cec:	8a 35       	cpi	r24, 0x5A	; 90
    2cee:	91 05       	cpc	r25, r1
    2cf0:	41 f0       	breq	.+16     	; 0x2d02 <__vector_25+0x92>
    2cf2:	80 91 04 17 	lds	r24, 0x1704
    2cf6:	90 91 05 17 	lds	r25, 0x1705
    2cfa:	84 36       	cpi	r24, 0x64	; 100
    2cfc:	91 05       	cpc	r25, r1
    2cfe:	09 f0       	breq	.+2      	; 0x2d02 <__vector_25+0x92>
    2d00:	68 c0       	rjmp	.+208    	; 0x2dd2 <__vector_25+0x162>
	{
		switch(data)
    2d02:	80 91 04 17 	lds	r24, 0x1704
    2d06:	90 91 05 17 	lds	r25, 0x1705
    2d0a:	86 34       	cpi	r24, 0x46	; 70
    2d0c:	91 05       	cpc	r25, r1
    2d0e:	69 f1       	breq	.+90     	; 0x2d6a <__vector_25+0xfa>
    2d10:	87 34       	cpi	r24, 0x47	; 71
    2d12:	91 05       	cpc	r25, r1
    2d14:	44 f4       	brge	.+16     	; 0x2d26 <__vector_25+0xb6>
    2d16:	8e 31       	cpi	r24, 0x1E	; 30
    2d18:	91 05       	cpc	r25, r1
    2d1a:	89 f0       	breq	.+34     	; 0x2d3e <__vector_25+0xce>
    2d1c:	82 33       	cpi	r24, 0x32	; 50
    2d1e:	91 05       	cpc	r25, r1
    2d20:	09 f0       	breq	.+2      	; 0x2d24 <__vector_25+0xb4>
    2d22:	58 c1       	rjmp	.+688    	; 0x2fd4 <__vector_25+0x364>
    2d24:	17 c0       	rjmp	.+46     	; 0x2d54 <__vector_25+0xe4>
    2d26:	8a 35       	cpi	r24, 0x5A	; 90
    2d28:	91 05       	cpc	r25, r1
    2d2a:	c9 f1       	breq	.+114    	; 0x2d9e <__vector_25+0x12e>
    2d2c:	84 36       	cpi	r24, 0x64	; 100
    2d2e:	91 05       	cpc	r25, r1
    2d30:	09 f4       	brne	.+2      	; 0x2d34 <__vector_25+0xc4>
    2d32:	48 c0       	rjmp	.+144    	; 0x2dc4 <__vector_25+0x154>
    2d34:	85 35       	cpi	r24, 0x55	; 85
    2d36:	91 05       	cpc	r25, r1
    2d38:	09 f0       	breq	.+2      	; 0x2d3c <__vector_25+0xcc>
    2d3a:	4c c1       	rjmp	.+664    	; 0x2fd4 <__vector_25+0x364>
    2d3c:	25 c0       	rjmp	.+74     	; 0x2d88 <__vector_25+0x118>
		{
			case 30:flag = 1;
    2d3e:	81 e0       	ldi	r24, 0x01	; 1
    2d40:	90 e0       	ldi	r25, 0x00	; 0
    2d42:	90 93 5f 07 	sts	0x075F, r25
    2d46:	80 93 5e 07 	sts	0x075E, r24
			position_flag=0;
    2d4a:	10 92 63 07 	sts	0x0763, r1
    2d4e:	10 92 62 07 	sts	0x0762, r1
			break;
    2d52:	40 c1       	rjmp	.+640    	; 0x2fd4 <__vector_25+0x364>
			case 50:position_flag=1;
    2d54:	81 e0       	ldi	r24, 0x01	; 1
    2d56:	90 e0       	ldi	r25, 0x00	; 0
    2d58:	90 93 63 07 	sts	0x0763, r25
    2d5c:	80 93 62 07 	sts	0x0762, r24
			flag = 0;
    2d60:	10 92 5f 07 	sts	0x075F, r1
    2d64:	10 92 5e 07 	sts	0x075E, r1
			break;
    2d68:	35 c1       	rjmp	.+618    	; 0x2fd4 <__vector_25+0x364>
			case 70:clear_flag=1;
    2d6a:	81 e0       	ldi	r24, 0x01	; 1
    2d6c:	90 e0       	ldi	r25, 0x00	; 0
    2d6e:	90 93 55 07 	sts	0x0755, r25
    2d72:	80 93 54 07 	sts	0x0754, r24
			flag = 0;
    2d76:	10 92 5f 07 	sts	0x075F, r1
    2d7a:	10 92 5e 07 	sts	0x075E, r1
			position_flag=0;
    2d7e:	10 92 63 07 	sts	0x0763, r1
    2d82:	10 92 62 07 	sts	0x0762, r1
			break;
    2d86:	26 c1       	rjmp	.+588    	; 0x2fd4 <__vector_25+0x364>
			case 85: san_flag = 1;
    2d88:	81 e0       	ldi	r24, 0x01	; 1
    2d8a:	90 e0       	ldi	r25, 0x00	; 0
    2d8c:	90 93 57 07 	sts	0x0757, r25
    2d90:	80 93 56 07 	sts	0x0756, r24
			USART0_TX(100);
    2d94:	84 e6       	ldi	r24, 0x64	; 100
    2d96:	90 e0       	ldi	r25, 0x00	; 0
    2d98:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <USART0_TX>
			break;
    2d9c:	1b c1       	rjmp	.+566    	; 0x2fd4 <__vector_25+0x364>
			case 90:node_flag=1;
    2d9e:	81 e0       	ldi	r24, 0x01	; 1
    2da0:	90 e0       	ldi	r25, 0x00	; 0
    2da2:	90 93 51 07 	sts	0x0751, r25
    2da6:	80 93 50 07 	sts	0x0750, r24
			clear_flag=0;
    2daa:	10 92 55 07 	sts	0x0755, r1
    2dae:	10 92 54 07 	sts	0x0754, r1
			flag = 0;
    2db2:	10 92 5f 07 	sts	0x075F, r1
    2db6:	10 92 5e 07 	sts	0x075E, r1
			position_flag=0;
    2dba:	10 92 63 07 	sts	0x0763, r1
    2dbe:	10 92 62 07 	sts	0x0762, r1
			break;
    2dc2:	08 c1       	rjmp	.+528    	; 0x2fd4 <__vector_25+0x364>
			
			case 100:	ACK=1;
    2dc4:	81 e0       	ldi	r24, 0x01	; 1
    2dc6:	90 e0       	ldi	r25, 0x00	; 0
    2dc8:	90 93 5b 07 	sts	0x075B, r25
    2dcc:	80 93 5a 07 	sts	0x075A, r24
			break;
    2dd0:	01 c1       	rjmp	.+514    	; 0x2fd4 <__vector_25+0x364>
			break;
		}
	}
	else
	{	
		if (node_flag)
    2dd2:	80 91 50 07 	lds	r24, 0x0750
    2dd6:	90 91 51 07 	lds	r25, 0x0751
    2dda:	00 97       	sbiw	r24, 0x00	; 0
    2ddc:	09 f4       	brne	.+2      	; 0x2de0 <__vector_25+0x170>
    2dde:	56 c0       	rjmp	.+172    	; 0x2e8c <__vector_25+0x21c>
		{
			node_search = data;
    2de0:	80 91 04 17 	lds	r24, 0x1704
    2de4:	90 91 05 17 	lds	r25, 0x1705
    2de8:	90 93 7d 16 	sts	0x167D, r25
    2dec:	80 93 7c 16 	sts	0x167C, r24
			for (int i=path_ptr-1; i<=path_length; i++)
    2df0:	20 91 ba 0c 	lds	r18, 0x0CBA
    2df4:	30 91 bb 0c 	lds	r19, 0x0CBB
    2df8:	a9 01       	movw	r20, r18
    2dfa:	41 50       	subi	r20, 0x01	; 1
    2dfc:	50 40       	sbci	r21, 0x00	; 0
    2dfe:	60 91 86 16 	lds	r22, 0x1686
    2e02:	70 91 87 16 	lds	r23, 0x1687
    2e06:	64 17       	cp	r22, r20
    2e08:	75 07       	cpc	r23, r21
    2e0a:	6c f1       	brlt	.+90     	; 0x2e66 <__vector_25+0x1f6>
			{
				if (node_search == n_node[i])
    2e0c:	a0 91 7c 16 	lds	r26, 0x167C
    2e10:	b0 91 7d 16 	lds	r27, 0x167D
    2e14:	fa 01       	movw	r30, r20
    2e16:	ee 0f       	add	r30, r30
    2e18:	ff 1f       	adc	r31, r31
    2e1a:	e8 57       	subi	r30, 0x78	; 120
    2e1c:	f9 4e       	sbci	r31, 0xE9	; 233
    2e1e:	80 81       	ld	r24, Z
    2e20:	91 81       	ldd	r25, Z+1	; 0x01
    2e22:	8a 17       	cp	r24, r26
    2e24:	9b 07       	cpc	r25, r27
    2e26:	89 f4       	brne	.+34     	; 0x2e4a <__vector_25+0x1da>
    2e28:	09 c0       	rjmp	.+18     	; 0x2e3c <__vector_25+0x1cc>
    2e2a:	81 91       	ld	r24, Z+
    2e2c:	91 91       	ld	r25, Z+
    2e2e:	20 91 7c 16 	lds	r18, 0x167C
    2e32:	30 91 7d 16 	lds	r19, 0x167D
    2e36:	82 17       	cp	r24, r18
    2e38:	93 07       	cpc	r25, r19
    2e3a:	61 f4       	brne	.+24     	; 0x2e54 <__vector_25+0x1e4>
				{
					detect_flag = 1;
    2e3c:	81 e0       	ldi	r24, 0x01	; 1
    2e3e:	90 e0       	ldi	r25, 0x00	; 0
    2e40:	90 93 4f 07 	sts	0x074F, r25
    2e44:	80 93 4e 07 	sts	0x074E, r24
					break;
    2e48:	0e c0       	rjmp	.+28     	; 0x2e66 <__vector_25+0x1f6>
	UCSR0B = 0x98;
}

volatile int clear_flag=0,clear_flag1=0;
volatile int node_flag=0,node_search,detect_flag=0;
SIGNAL(SIG_USART0_RECV) 		// ISR for receive complete interrupt
    2e4a:	f9 01       	movw	r30, r18
    2e4c:	ee 0f       	add	r30, r30
    2e4e:	ff 1f       	adc	r31, r31
    2e50:	e8 57       	subi	r30, 0x78	; 120
    2e52:	f9 4e       	sbci	r31, 0xE9	; 233
				{
					detect_flag = 1;
					break;
				}
				else
				detect_flag = 0;
    2e54:	10 92 4f 07 	sts	0x074F, r1
    2e58:	10 92 4e 07 	sts	0x074E, r1
	else
	{	
		if (node_flag)
		{
			node_search = data;
			for (int i=path_ptr-1; i<=path_length; i++)
    2e5c:	4f 5f       	subi	r20, 0xFF	; 255
    2e5e:	5f 4f       	sbci	r21, 0xFF	; 255
    2e60:	64 17       	cp	r22, r20
    2e62:	75 07       	cpc	r23, r21
    2e64:	14 f7       	brge	.-60     	; 0x2e2a <__vector_25+0x1ba>
					break;
				}
				else
				detect_flag = 0;
			}
			if (detect_flag)
    2e66:	80 91 4e 07 	lds	r24, 0x074E
    2e6a:	90 91 4f 07 	lds	r25, 0x074F
    2e6e:	00 97       	sbiw	r24, 0x00	; 0
    2e70:	29 f0       	breq	.+10     	; 0x2e7c <__vector_25+0x20c>
			{
				USART0_TX(140);
    2e72:	8c e8       	ldi	r24, 0x8C	; 140
    2e74:	90 e0       	ldi	r25, 0x00	; 0
    2e76:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <USART0_TX>
    2e7a:	04 c0       	rjmp	.+8      	; 0x2e84 <__vector_25+0x214>
			}
			else
			{
				USART0_TX(150);
    2e7c:	86 e9       	ldi	r24, 0x96	; 150
    2e7e:	90 e0       	ldi	r25, 0x00	; 0
    2e80:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <USART0_TX>
			}
			
			node_flag = 0;
    2e84:	10 92 51 07 	sts	0x0751, r1
    2e88:	10 92 50 07 	sts	0x0750, r1
		}
		
		if(flag)
    2e8c:	80 91 5e 07 	lds	r24, 0x075E
    2e90:	90 91 5f 07 	lds	r25, 0x075F
    2e94:	00 97       	sbiw	r24, 0x00	; 0
    2e96:	99 f0       	breq	.+38     	; 0x2ebe <__vector_25+0x24e>
		{
			block_node[0]=data;
    2e98:	80 91 04 17 	lds	r24, 0x1704
    2e9c:	90 91 05 17 	lds	r25, 0x1705
    2ea0:	90 93 07 17 	sts	0x1707, r25
    2ea4:	80 93 06 17 	sts	0x1706, r24
			flag1=1;
    2ea8:	81 e0       	ldi	r24, 0x01	; 1
    2eaa:	90 e0       	ldi	r25, 0x00	; 0
    2eac:	90 93 5d 07 	sts	0x075D, r25
    2eb0:	80 93 5c 07 	sts	0x075C, r24
			flag=0;
    2eb4:	10 92 5f 07 	sts	0x075F, r1
    2eb8:	10 92 5e 07 	sts	0x075E, r1
    2ebc:	48 c0       	rjmp	.+144    	; 0x2f4e <__vector_25+0x2de>
		}
		else if(flag1)
    2ebe:	80 91 5c 07 	lds	r24, 0x075C
    2ec2:	90 91 5d 07 	lds	r25, 0x075D
    2ec6:	00 97       	sbiw	r24, 0x00	; 0
    2ec8:	09 f4       	brne	.+2      	; 0x2ecc <__vector_25+0x25c>
    2eca:	41 c0       	rjmp	.+130    	; 0x2f4e <__vector_25+0x2de>
		{
			block_node[1]=data;
    2ecc:	80 91 04 17 	lds	r24, 0x1704
    2ed0:	90 91 05 17 	lds	r25, 0x1705
    2ed4:	90 93 09 17 	sts	0x1709, r25
    2ed8:	80 93 08 17 	sts	0x1708, r24
			cost[block_node[0]][block_node[1]]=IN;
    2edc:	a8 e0       	ldi	r26, 0x08	; 8
    2ede:	b7 e1       	ldi	r27, 0x17	; 23
    2ee0:	12 97       	sbiw	r26, 0x02	; 2
    2ee2:	8d 91       	ld	r24, X+
    2ee4:	9c 91       	ld	r25, X
    2ee6:	11 97       	sbiw	r26, 0x01	; 1
    2ee8:	e0 91 08 17 	lds	r30, 0x1708
    2eec:	f0 91 09 17 	lds	r31, 0x1709
    2ef0:	0a e1       	ldi	r16, 0x1A	; 26
    2ef2:	10 e0       	ldi	r17, 0x00	; 0
    2ef4:	80 9f       	mul	r24, r16
    2ef6:	90 01       	movw	r18, r0
    2ef8:	81 9f       	mul	r24, r17
    2efa:	30 0d       	add	r19, r0
    2efc:	90 9f       	mul	r25, r16
    2efe:	30 0d       	add	r19, r0
    2f00:	11 24       	eor	r1, r1
    2f02:	e2 0f       	add	r30, r18
    2f04:	f3 1f       	adc	r31, r19
    2f06:	c0 e0       	ldi	r28, 0x00	; 0
    2f08:	d2 e0       	ldi	r29, 0x02	; 2
    2f0a:	ee 0f       	add	r30, r30
    2f0c:	ff 1f       	adc	r31, r31
    2f0e:	ec 0f       	add	r30, r28
    2f10:	fd 1f       	adc	r31, r29
    2f12:	43 e6       	ldi	r20, 0x63	; 99
    2f14:	50 e0       	ldi	r21, 0x00	; 0
    2f16:	51 83       	std	Z+1, r21	; 0x01
    2f18:	40 83       	st	Z, r20
			cost[block_node[1]][block_node[0]]=IN;
    2f1a:	60 91 08 17 	lds	r22, 0x1708
    2f1e:	70 91 09 17 	lds	r23, 0x1709
    2f22:	2d 91       	ld	r18, X+
    2f24:	3c 91       	ld	r19, X
    2f26:	11 97       	sbiw	r26, 0x01	; 1
    2f28:	60 9f       	mul	r22, r16
    2f2a:	c0 01       	movw	r24, r0
    2f2c:	61 9f       	mul	r22, r17
    2f2e:	90 0d       	add	r25, r0
    2f30:	70 9f       	mul	r23, r16
    2f32:	90 0d       	add	r25, r0
    2f34:	11 24       	eor	r1, r1
    2f36:	82 0f       	add	r24, r18
    2f38:	93 1f       	adc	r25, r19
    2f3a:	88 0f       	add	r24, r24
    2f3c:	99 1f       	adc	r25, r25
    2f3e:	c8 0f       	add	r28, r24
    2f40:	d9 1f       	adc	r29, r25
    2f42:	59 83       	std	Y+1, r21	; 0x01
    2f44:	48 83       	st	Y, r20
			flag1=0;
    2f46:	10 92 5d 07 	sts	0x075D, r1
    2f4a:	10 92 5c 07 	sts	0x075C, r1
		}
		
		if(position_flag)
    2f4e:	80 91 62 07 	lds	r24, 0x0762
    2f52:	90 91 63 07 	lds	r25, 0x0763
    2f56:	00 97       	sbiw	r24, 0x00	; 0
    2f58:	e9 f0       	breq	.+58     	; 0x2f94 <__vector_25+0x324>
		{
			pos[0] = data;
    2f5a:	80 91 04 17 	lds	r24, 0x1704
    2f5e:	90 91 05 17 	lds	r25, 0x1705
    2f62:	90 93 31 11 	sts	0x1131, r25
    2f66:	80 93 30 11 	sts	0x1130, r24
			position_flag = 0;
    2f6a:	10 92 63 07 	sts	0x0763, r1
    2f6e:	10 92 62 07 	sts	0x0762, r1
			position_flag1 = 1;
    2f72:	81 e0       	ldi	r24, 0x01	; 1
    2f74:	90 e0       	ldi	r25, 0x00	; 0
    2f76:	90 93 61 07 	sts	0x0761, r25
    2f7a:	80 93 60 07 	sts	0x0760, r24
			lcd_print(2,7,pos[0],2);
    2f7e:	40 91 30 11 	lds	r20, 0x1130
    2f82:	50 91 31 11 	lds	r21, 0x1131
    2f86:	82 e0       	ldi	r24, 0x02	; 2
    2f88:	67 e0       	ldi	r22, 0x07	; 7
    2f8a:	22 e0       	ldi	r18, 0x02	; 2
    2f8c:	30 e0       	ldi	r19, 0x00	; 0
    2f8e:	0e 94 00 02 	call	0x400	; 0x400 <lcd_print>
    2f92:	20 c0       	rjmp	.+64     	; 0x2fd4 <__vector_25+0x364>
		}
		else if(position_flag1)
    2f94:	80 91 60 07 	lds	r24, 0x0760
    2f98:	90 91 61 07 	lds	r25, 0x0761
    2f9c:	00 97       	sbiw	r24, 0x00	; 0
    2f9e:	d1 f0       	breq	.+52     	; 0x2fd4 <__vector_25+0x364>
		{
			pos[1] = data;
    2fa0:	80 91 04 17 	lds	r24, 0x1704
    2fa4:	90 91 05 17 	lds	r25, 0x1705
    2fa8:	90 93 33 11 	sts	0x1133, r25
    2fac:	80 93 32 11 	sts	0x1132, r24
			position_flag1 = 0;
    2fb0:	10 92 61 07 	sts	0x0761, r1
    2fb4:	10 92 60 07 	sts	0x0760, r1
			lcd_print(2,10,pos[1],2);
    2fb8:	40 91 32 11 	lds	r20, 0x1132
    2fbc:	50 91 33 11 	lds	r21, 0x1133
    2fc0:	82 e0       	ldi	r24, 0x02	; 2
    2fc2:	6a e0       	ldi	r22, 0x0A	; 10
    2fc4:	22 e0       	ldi	r18, 0x02	; 2
    2fc6:	30 e0       	ldi	r19, 0x00	; 0
    2fc8:	0e 94 00 02 	call	0x400	; 0x400 <lcd_print>
			USART0_TX(100);
    2fcc:	84 e6       	ldi	r24, 0x64	; 100
    2fce:	90 e0       	ldi	r25, 0x00	; 0
    2fd0:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <USART0_TX>
		}	
	}	
}
    2fd4:	ff 91       	pop	r31
    2fd6:	ef 91       	pop	r30
    2fd8:	df 91       	pop	r29
    2fda:	cf 91       	pop	r28
    2fdc:	bf 91       	pop	r27
    2fde:	af 91       	pop	r26
    2fe0:	9f 91       	pop	r25
    2fe2:	8f 91       	pop	r24
    2fe4:	7f 91       	pop	r23
    2fe6:	6f 91       	pop	r22
    2fe8:	5f 91       	pop	r21
    2fea:	4f 91       	pop	r20
    2fec:	3f 91       	pop	r19
    2fee:	2f 91       	pop	r18
    2ff0:	1f 91       	pop	r17
    2ff2:	0f 91       	pop	r16
    2ff4:	0f 90       	pop	r0
    2ff6:	0b be       	out	0x3b, r0	; 59
    2ff8:	0f 90       	pop	r0
    2ffa:	0f be       	out	0x3f, r0	; 63
    2ffc:	0f 90       	pop	r0
    2ffe:	1f 90       	pop	r1
    3000:	18 95       	reti

00003002 <init_arena>:
	_delay_us(100);
}

void init_arena(void)
{
	setPlot();
    3002:	0e 94 88 0a 	call	0x1510	; 0x1510 <setPlot>
	set_adj_node();
    3006:	0e 94 b7 0b 	call	0x176e	; 0x176e <set_adj_node>
	set_adj_Plots();
    300a:	0e 94 b5 0a 	call	0x156a	; 0x156a <set_adj_Plots>
}
    300e:	08 95       	ret

00003010 <port_config>:

void port_config(void)			// To configure various device interfaced to FireBird V robot
{
	lcd_port_config();
    3010:	0e 94 22 01 	call	0x244	; 0x244 <lcd_port_config>
	buzzer_pin_config();
    3014:	0e 94 de 05 	call	0xbbc	; 0xbbc <buzzer_pin_config>
	adc_pin_config();
    3018:	0e 94 6d 02 	call	0x4da	; 0x4da <adc_pin_config>
	motion_pin_config();
    301c:	0e 94 32 03 	call	0x664	; 0x664 <motion_pin_config>
	left_encoder_pin_config();
    3020:	0e 94 43 03 	call	0x686	; 0x686 <left_encoder_pin_config>
	right_encoder_pin_config();
    3024:	0e 94 46 03 	call	0x68c	; 0x68c <right_encoder_pin_config>
}
    3028:	08 95       	ret

0000302a <init_devices>:

// To initialise the devices
void init_devices(void)
{
	cli();			//Clears the global interrupt
    302a:	f8 94       	cli
	port_config();
    302c:	0e 94 08 18 	call	0x3010	; 0x3010 <port_config>
	lcd_init();
    3030:	0e 94 91 01 	call	0x322	; 0x322 <lcd_init>
	adc_init();
    3034:	0e 94 74 02 	call	0x4e8	; 0x4e8 <adc_init>
	timer5_init();
    3038:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <timer5_init>
	left_position_encoder_interrupt_init();
    303c:	0e 94 49 03 	call	0x692	; 0x692 <left_position_encoder_interrupt_init>
	right_position_encoder_interrupt_init();
    3040:	0e 94 52 03 	call	0x6a4	; 0x6a4 <right_position_encoder_interrupt_init>
	uart0_init();
    3044:	0e 94 28 16 	call	0x2c50	; 0x2c50 <uart0_init>
	servo_init();
    3048:	0e 94 0e 06 	call	0xc1c	; 0xc1c <servo_init>
	colour_init();
    304c:	0e 94 ec 06 	call	0xdd8	; 0xdd8 <colour_init>
	sei();			//Enable the global interrupt
    3050:	78 94       	sei
}
    3052:	08 95       	ret

00003054 <main>:

int main()
{
	crt_node=23;
    3054:	87 e1       	ldi	r24, 0x17	; 23
    3056:	90 e0       	ldi	r25, 0x00	; 0
    3058:	90 93 4d 07 	sts	0x074D, r25
    305c:	80 93 4c 07 	sts	0x074C, r24
	init_arena();
    3060:	0e 94 01 18 	call	0x3002	; 0x3002 <init_arena>
	init_devices();
    3064:	0e 94 15 18 	call	0x302a	; 0x302a <init_devices>
	
	servo_1(0);
    3068:	80 e0       	ldi	r24, 0x00	; 0
    306a:	0e 94 17 06 	call	0xc2e	; 0xc2e <servo_1>
	servo_2(180);
    306e:	84 eb       	ldi	r24, 0xB4	; 180
    3070:	0e 94 30 06 	call	0xc60	; 0xc60 <servo_2>
	
	path_mm(70);	
    3074:	66 e4       	ldi	r22, 0x46	; 70
    3076:	70 e0       	ldi	r23, 0x00	; 0
    3078:	80 e0       	ldi	r24, 0x00	; 0
    307a:	90 e0       	ldi	r25, 0x00	; 0
    307c:	0e 94 4b 04 	call	0x896	; 0x896 <path_mm>
	path_node(1);
    3080:	81 e0       	ldi	r24, 0x01	; 1
    3082:	90 e0       	ldi	r25, 0x00	; 0
    3084:	0e 94 f6 04 	call	0x9ec	; 0x9ec <path_node>
	
	while (1)
	{
		int n = search();
    3088:	0e 94 f5 14 	call	0x29ea	; 0x29ea <search>
		if(n == -1)
    308c:	2f ef       	ldi	r18, 0xFF	; 255
    308e:	8f 3f       	cpi	r24, 0xFF	; 255
    3090:	92 07       	cpc	r25, r18
    3092:	d1 f7       	brne	.-12     	; 0x3088 <main+0x34>
			break;		
	}

	ACK =0;
    3094:	10 92 5b 07 	sts	0x075B, r1
    3098:	10 92 5a 07 	sts	0x075A, r1
	USART0_TX(60);		//Send Search Complete Flag
    309c:	8c e3       	ldi	r24, 0x3C	; 60
    309e:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <USART0_TX>
	while(ACK == 0)
    30a2:	80 91 5a 07 	lds	r24, 0x075A
    30a6:	90 91 5b 07 	lds	r25, 0x075B
    30aa:	00 97       	sbiw	r24, 0x00	; 0
    30ac:	71 f4       	brne	.+28     	; 0x30ca <main+0x76>
	{
		USART0_TX(60);
    30ae:	8c e3       	ldi	r24, 0x3C	; 60
    30b0:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <USART0_TX>
    30b4:	86 e6       	ldi	r24, 0x66	; 102
    30b6:	9e e0       	ldi	r25, 0x0E	; 14
    30b8:	01 97       	sbiw	r24, 0x01	; 1
    30ba:	f1 f7       	brne	.-4      	; 0x30b8 <main+0x64>
    30bc:	00 00       	nop
			break;		
	}

	ACK =0;
	USART0_TX(60);		//Send Search Complete Flag
	while(ACK == 0)
    30be:	80 91 5a 07 	lds	r24, 0x075A
    30c2:	90 91 5b 07 	lds	r25, 0x075B
    30c6:	00 97       	sbiw	r24, 0x00	; 0
    30c8:	91 f3       	breq	.-28     	; 0x30ae <main+0x5a>
	{
		USART0_TX(60);
		_delay_ms(1);
	}

	goto_home();	
    30ca:	0e 94 c4 14 	call	0x2988	; 0x2988 <goto_home>
	turn(23,24);
    30ce:	87 e1       	ldi	r24, 0x17	; 23
    30d0:	90 e0       	ldi	r25, 0x00	; 0
    30d2:	68 e1       	ldi	r22, 0x18	; 24
    30d4:	70 e0       	ldi	r23, 0x00	; 0
    30d6:	0e 94 ea 0d 	call	0x1bd4	; 0x1bd4 <turn>
	rotate_right(85);
    30da:	85 e5       	ldi	r24, 0x55	; 85
    30dc:	90 e0       	ldi	r25, 0x00	; 0
    30de:	0e 94 a2 05 	call	0xb44	; 0xb44 <rotate_right>
	path_node(1);
    30e2:	81 e0       	ldi	r24, 0x01	; 1
    30e4:	90 e0       	ldi	r25, 0x00	; 0
    30e6:	0e 94 f6 04 	call	0x9ec	; 0x9ec <path_node>
	path_mm(40);
    30ea:	68 e2       	ldi	r22, 0x28	; 40
    30ec:	70 e0       	ldi	r23, 0x00	; 0
    30ee:	80 e0       	ldi	r24, 0x00	; 0
    30f0:	90 e0       	ldi	r25, 0x00	; 0
    30f2:	0e 94 4b 04 	call	0x896	; 0x896 <path_mm>
	rotate_right(175);	
    30f6:	8f ea       	ldi	r24, 0xAF	; 175
    30f8:	90 e0       	ldi	r25, 0x00	; 0
    30fa:	0e 94 a2 05 	call	0xb44	; 0xb44 <rotate_right>
    30fe:	e8 e8       	ldi	r30, 0x88	; 136
    3100:	f6 e1       	ldi	r31, 0x16	; 22
	servo_init();
	colour_init();
	sei();			//Enable the global interrupt
}

int main()
    3102:	cf 01       	movw	r24, r30
    3104:	44 96       	adiw	r24, 0x14	; 20
	path_mm(40);
	rotate_right(175);	
		
	for (int i=0; i<10; i++)
	{
		n_node[i] = 0;
    3106:	11 92       	st	Z+, r1
    3108:	11 92       	st	Z+, r1
	rotate_right(85);
	path_node(1);
	path_mm(40);
	rotate_right(175);	
		
	for (int i=0; i<10; i++)
    310a:	e8 17       	cp	r30, r24
    310c:	f9 07       	cpc	r31, r25
    310e:	d9 f7       	brne	.-10     	; 0x3106 <main+0xb2>
	{
		n_node[i] = 0;
	}
	
	ACK=0;
    3110:	10 92 5b 07 	sts	0x075B, r1
    3114:	10 92 5a 07 	sts	0x075A, r1
	send(80,0,0);
    3118:	80 e5       	ldi	r24, 0x50	; 80
    311a:	90 e0       	ldi	r25, 0x00	; 0
    311c:	60 e0       	ldi	r22, 0x00	; 0
    311e:	70 e0       	ldi	r23, 0x00	; 0
    3120:	40 e0       	ldi	r20, 0x00	; 0
    3122:	50 e0       	ldi	r21, 0x00	; 0
    3124:	0e 94 04 01 	call	0x208	; 0x208 <send>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3128:	80 e7       	ldi	r24, 0x70	; 112
    312a:	91 e0       	ldi	r25, 0x01	; 1
    312c:	01 97       	sbiw	r24, 0x01	; 1
    312e:	f1 f7       	brne	.-4      	; 0x312c <main+0xd8>
    3130:	00 c0       	rjmp	.+0      	; 0x3132 <main+0xde>
	_delay_us(100);
	while(ACK == 0)
    3132:	80 91 5a 07 	lds	r24, 0x075A
    3136:	90 91 5b 07 	lds	r25, 0x075B
    313a:	00 97       	sbiw	r24, 0x00	; 0
    313c:	99 f4       	brne	.+38     	; 0x3164 <main+0x110>
	{
		send(80,0,0);
    313e:	80 e5       	ldi	r24, 0x50	; 80
    3140:	90 e0       	ldi	r25, 0x00	; 0
    3142:	60 e0       	ldi	r22, 0x00	; 0
    3144:	70 e0       	ldi	r23, 0x00	; 0
    3146:	40 e0       	ldi	r20, 0x00	; 0
    3148:	50 e0       	ldi	r21, 0x00	; 0
    314a:	0e 94 04 01 	call	0x208	; 0x208 <send>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    314e:	86 e6       	ldi	r24, 0x66	; 102
    3150:	9e e0       	ldi	r25, 0x0E	; 14
    3152:	01 97       	sbiw	r24, 0x01	; 1
    3154:	f1 f7       	brne	.-4      	; 0x3152 <main+0xfe>
    3156:	00 00       	nop
	}
	
	ACK=0;
	send(80,0,0);
	_delay_us(100);
	while(ACK == 0)
    3158:	80 91 5a 07 	lds	r24, 0x075A
    315c:	90 91 5b 07 	lds	r25, 0x075B
    3160:	00 97       	sbiw	r24, 0x00	; 0
    3162:	69 f3       	breq	.-38     	; 0x313e <main+0xea>
    3164:	ff cf       	rjmp	.-2      	; 0x3164 <main+0x110>

00003166 <__subsf3>:
    3166:	50 58       	subi	r21, 0x80	; 128

00003168 <__addsf3>:
    3168:	bb 27       	eor	r27, r27
    316a:	aa 27       	eor	r26, r26
    316c:	0e d0       	rcall	.+28     	; 0x318a <__addsf3x>
    316e:	75 c1       	rjmp	.+746    	; 0x345a <__fp_round>
    3170:	66 d1       	rcall	.+716    	; 0x343e <__fp_pscA>
    3172:	30 f0       	brcs	.+12     	; 0x3180 <__addsf3+0x18>
    3174:	6b d1       	rcall	.+726    	; 0x344c <__fp_pscB>
    3176:	20 f0       	brcs	.+8      	; 0x3180 <__addsf3+0x18>
    3178:	31 f4       	brne	.+12     	; 0x3186 <__addsf3+0x1e>
    317a:	9f 3f       	cpi	r25, 0xFF	; 255
    317c:	11 f4       	brne	.+4      	; 0x3182 <__addsf3+0x1a>
    317e:	1e f4       	brtc	.+6      	; 0x3186 <__addsf3+0x1e>
    3180:	5b c1       	rjmp	.+694    	; 0x3438 <__fp_nan>
    3182:	0e f4       	brtc	.+2      	; 0x3186 <__addsf3+0x1e>
    3184:	e0 95       	com	r30
    3186:	e7 fb       	bst	r30, 7
    3188:	51 c1       	rjmp	.+674    	; 0x342c <__fp_inf>

0000318a <__addsf3x>:
    318a:	e9 2f       	mov	r30, r25
    318c:	77 d1       	rcall	.+750    	; 0x347c <__fp_split3>
    318e:	80 f3       	brcs	.-32     	; 0x3170 <__addsf3+0x8>
    3190:	ba 17       	cp	r27, r26
    3192:	62 07       	cpc	r22, r18
    3194:	73 07       	cpc	r23, r19
    3196:	84 07       	cpc	r24, r20
    3198:	95 07       	cpc	r25, r21
    319a:	18 f0       	brcs	.+6      	; 0x31a2 <__addsf3x+0x18>
    319c:	71 f4       	brne	.+28     	; 0x31ba <__addsf3x+0x30>
    319e:	9e f5       	brtc	.+102    	; 0x3206 <__addsf3x+0x7c>
    31a0:	8f c1       	rjmp	.+798    	; 0x34c0 <__fp_zero>
    31a2:	0e f4       	brtc	.+2      	; 0x31a6 <__addsf3x+0x1c>
    31a4:	e0 95       	com	r30
    31a6:	0b 2e       	mov	r0, r27
    31a8:	ba 2f       	mov	r27, r26
    31aa:	a0 2d       	mov	r26, r0
    31ac:	0b 01       	movw	r0, r22
    31ae:	b9 01       	movw	r22, r18
    31b0:	90 01       	movw	r18, r0
    31b2:	0c 01       	movw	r0, r24
    31b4:	ca 01       	movw	r24, r20
    31b6:	a0 01       	movw	r20, r0
    31b8:	11 24       	eor	r1, r1
    31ba:	ff 27       	eor	r31, r31
    31bc:	59 1b       	sub	r21, r25
    31be:	99 f0       	breq	.+38     	; 0x31e6 <__addsf3x+0x5c>
    31c0:	59 3f       	cpi	r21, 0xF9	; 249
    31c2:	50 f4       	brcc	.+20     	; 0x31d8 <__addsf3x+0x4e>
    31c4:	50 3e       	cpi	r21, 0xE0	; 224
    31c6:	68 f1       	brcs	.+90     	; 0x3222 <__addsf3x+0x98>
    31c8:	1a 16       	cp	r1, r26
    31ca:	f0 40       	sbci	r31, 0x00	; 0
    31cc:	a2 2f       	mov	r26, r18
    31ce:	23 2f       	mov	r18, r19
    31d0:	34 2f       	mov	r19, r20
    31d2:	44 27       	eor	r20, r20
    31d4:	58 5f       	subi	r21, 0xF8	; 248
    31d6:	f3 cf       	rjmp	.-26     	; 0x31be <__addsf3x+0x34>
    31d8:	46 95       	lsr	r20
    31da:	37 95       	ror	r19
    31dc:	27 95       	ror	r18
    31de:	a7 95       	ror	r26
    31e0:	f0 40       	sbci	r31, 0x00	; 0
    31e2:	53 95       	inc	r21
    31e4:	c9 f7       	brne	.-14     	; 0x31d8 <__addsf3x+0x4e>
    31e6:	7e f4       	brtc	.+30     	; 0x3206 <__addsf3x+0x7c>
    31e8:	1f 16       	cp	r1, r31
    31ea:	ba 0b       	sbc	r27, r26
    31ec:	62 0b       	sbc	r22, r18
    31ee:	73 0b       	sbc	r23, r19
    31f0:	84 0b       	sbc	r24, r20
    31f2:	ba f0       	brmi	.+46     	; 0x3222 <__addsf3x+0x98>
    31f4:	91 50       	subi	r25, 0x01	; 1
    31f6:	a1 f0       	breq	.+40     	; 0x3220 <__addsf3x+0x96>
    31f8:	ff 0f       	add	r31, r31
    31fa:	bb 1f       	adc	r27, r27
    31fc:	66 1f       	adc	r22, r22
    31fe:	77 1f       	adc	r23, r23
    3200:	88 1f       	adc	r24, r24
    3202:	c2 f7       	brpl	.-16     	; 0x31f4 <__addsf3x+0x6a>
    3204:	0e c0       	rjmp	.+28     	; 0x3222 <__addsf3x+0x98>
    3206:	ba 0f       	add	r27, r26
    3208:	62 1f       	adc	r22, r18
    320a:	73 1f       	adc	r23, r19
    320c:	84 1f       	adc	r24, r20
    320e:	48 f4       	brcc	.+18     	; 0x3222 <__addsf3x+0x98>
    3210:	87 95       	ror	r24
    3212:	77 95       	ror	r23
    3214:	67 95       	ror	r22
    3216:	b7 95       	ror	r27
    3218:	f7 95       	ror	r31
    321a:	9e 3f       	cpi	r25, 0xFE	; 254
    321c:	08 f0       	brcs	.+2      	; 0x3220 <__addsf3x+0x96>
    321e:	b3 cf       	rjmp	.-154    	; 0x3186 <__addsf3+0x1e>
    3220:	93 95       	inc	r25
    3222:	88 0f       	add	r24, r24
    3224:	08 f0       	brcs	.+2      	; 0x3228 <__addsf3x+0x9e>
    3226:	99 27       	eor	r25, r25
    3228:	ee 0f       	add	r30, r30
    322a:	97 95       	ror	r25
    322c:	87 95       	ror	r24
    322e:	08 95       	ret

00003230 <__cmpsf2>:
    3230:	d9 d0       	rcall	.+434    	; 0x33e4 <__fp_cmp>
    3232:	08 f4       	brcc	.+2      	; 0x3236 <__cmpsf2+0x6>
    3234:	81 e0       	ldi	r24, 0x01	; 1
    3236:	08 95       	ret

00003238 <__divsf3>:
    3238:	0c d0       	rcall	.+24     	; 0x3252 <__divsf3x>
    323a:	0f c1       	rjmp	.+542    	; 0x345a <__fp_round>
    323c:	07 d1       	rcall	.+526    	; 0x344c <__fp_pscB>
    323e:	40 f0       	brcs	.+16     	; 0x3250 <__divsf3+0x18>
    3240:	fe d0       	rcall	.+508    	; 0x343e <__fp_pscA>
    3242:	30 f0       	brcs	.+12     	; 0x3250 <__divsf3+0x18>
    3244:	21 f4       	brne	.+8      	; 0x324e <__divsf3+0x16>
    3246:	5f 3f       	cpi	r21, 0xFF	; 255
    3248:	19 f0       	breq	.+6      	; 0x3250 <__divsf3+0x18>
    324a:	f0 c0       	rjmp	.+480    	; 0x342c <__fp_inf>
    324c:	51 11       	cpse	r21, r1
    324e:	39 c1       	rjmp	.+626    	; 0x34c2 <__fp_szero>
    3250:	f3 c0       	rjmp	.+486    	; 0x3438 <__fp_nan>

00003252 <__divsf3x>:
    3252:	14 d1       	rcall	.+552    	; 0x347c <__fp_split3>
    3254:	98 f3       	brcs	.-26     	; 0x323c <__divsf3+0x4>

00003256 <__divsf3_pse>:
    3256:	99 23       	and	r25, r25
    3258:	c9 f3       	breq	.-14     	; 0x324c <__divsf3+0x14>
    325a:	55 23       	and	r21, r21
    325c:	b1 f3       	breq	.-20     	; 0x324a <__divsf3+0x12>
    325e:	95 1b       	sub	r25, r21
    3260:	55 0b       	sbc	r21, r21
    3262:	bb 27       	eor	r27, r27
    3264:	aa 27       	eor	r26, r26
    3266:	62 17       	cp	r22, r18
    3268:	73 07       	cpc	r23, r19
    326a:	84 07       	cpc	r24, r20
    326c:	38 f0       	brcs	.+14     	; 0x327c <__divsf3_pse+0x26>
    326e:	9f 5f       	subi	r25, 0xFF	; 255
    3270:	5f 4f       	sbci	r21, 0xFF	; 255
    3272:	22 0f       	add	r18, r18
    3274:	33 1f       	adc	r19, r19
    3276:	44 1f       	adc	r20, r20
    3278:	aa 1f       	adc	r26, r26
    327a:	a9 f3       	breq	.-22     	; 0x3266 <__divsf3_pse+0x10>
    327c:	33 d0       	rcall	.+102    	; 0x32e4 <__divsf3_pse+0x8e>
    327e:	0e 2e       	mov	r0, r30
    3280:	3a f0       	brmi	.+14     	; 0x3290 <__divsf3_pse+0x3a>
    3282:	e0 e8       	ldi	r30, 0x80	; 128
    3284:	30 d0       	rcall	.+96     	; 0x32e6 <__divsf3_pse+0x90>
    3286:	91 50       	subi	r25, 0x01	; 1
    3288:	50 40       	sbci	r21, 0x00	; 0
    328a:	e6 95       	lsr	r30
    328c:	00 1c       	adc	r0, r0
    328e:	ca f7       	brpl	.-14     	; 0x3282 <__divsf3_pse+0x2c>
    3290:	29 d0       	rcall	.+82     	; 0x32e4 <__divsf3_pse+0x8e>
    3292:	fe 2f       	mov	r31, r30
    3294:	27 d0       	rcall	.+78     	; 0x32e4 <__divsf3_pse+0x8e>
    3296:	66 0f       	add	r22, r22
    3298:	77 1f       	adc	r23, r23
    329a:	88 1f       	adc	r24, r24
    329c:	bb 1f       	adc	r27, r27
    329e:	26 17       	cp	r18, r22
    32a0:	37 07       	cpc	r19, r23
    32a2:	48 07       	cpc	r20, r24
    32a4:	ab 07       	cpc	r26, r27
    32a6:	b0 e8       	ldi	r27, 0x80	; 128
    32a8:	09 f0       	breq	.+2      	; 0x32ac <__divsf3_pse+0x56>
    32aa:	bb 0b       	sbc	r27, r27
    32ac:	80 2d       	mov	r24, r0
    32ae:	bf 01       	movw	r22, r30
    32b0:	ff 27       	eor	r31, r31
    32b2:	93 58       	subi	r25, 0x83	; 131
    32b4:	5f 4f       	sbci	r21, 0xFF	; 255
    32b6:	2a f0       	brmi	.+10     	; 0x32c2 <__divsf3_pse+0x6c>
    32b8:	9e 3f       	cpi	r25, 0xFE	; 254
    32ba:	51 05       	cpc	r21, r1
    32bc:	68 f0       	brcs	.+26     	; 0x32d8 <__divsf3_pse+0x82>
    32be:	b6 c0       	rjmp	.+364    	; 0x342c <__fp_inf>
    32c0:	00 c1       	rjmp	.+512    	; 0x34c2 <__fp_szero>
    32c2:	5f 3f       	cpi	r21, 0xFF	; 255
    32c4:	ec f3       	brlt	.-6      	; 0x32c0 <__divsf3_pse+0x6a>
    32c6:	98 3e       	cpi	r25, 0xE8	; 232
    32c8:	dc f3       	brlt	.-10     	; 0x32c0 <__divsf3_pse+0x6a>
    32ca:	86 95       	lsr	r24
    32cc:	77 95       	ror	r23
    32ce:	67 95       	ror	r22
    32d0:	b7 95       	ror	r27
    32d2:	f7 95       	ror	r31
    32d4:	9f 5f       	subi	r25, 0xFF	; 255
    32d6:	c9 f7       	brne	.-14     	; 0x32ca <__divsf3_pse+0x74>
    32d8:	88 0f       	add	r24, r24
    32da:	91 1d       	adc	r25, r1
    32dc:	96 95       	lsr	r25
    32de:	87 95       	ror	r24
    32e0:	97 f9       	bld	r25, 7
    32e2:	08 95       	ret
    32e4:	e1 e0       	ldi	r30, 0x01	; 1
    32e6:	66 0f       	add	r22, r22
    32e8:	77 1f       	adc	r23, r23
    32ea:	88 1f       	adc	r24, r24
    32ec:	bb 1f       	adc	r27, r27
    32ee:	62 17       	cp	r22, r18
    32f0:	73 07       	cpc	r23, r19
    32f2:	84 07       	cpc	r24, r20
    32f4:	ba 07       	cpc	r27, r26
    32f6:	20 f0       	brcs	.+8      	; 0x3300 <__divsf3_pse+0xaa>
    32f8:	62 1b       	sub	r22, r18
    32fa:	73 0b       	sbc	r23, r19
    32fc:	84 0b       	sbc	r24, r20
    32fe:	ba 0b       	sbc	r27, r26
    3300:	ee 1f       	adc	r30, r30
    3302:	88 f7       	brcc	.-30     	; 0x32e6 <__divsf3_pse+0x90>
    3304:	e0 95       	com	r30
    3306:	08 95       	ret

00003308 <__fixsfsi>:
    3308:	04 d0       	rcall	.+8      	; 0x3312 <__fixunssfsi>
    330a:	68 94       	set
    330c:	b1 11       	cpse	r27, r1
    330e:	d9 c0       	rjmp	.+434    	; 0x34c2 <__fp_szero>
    3310:	08 95       	ret

00003312 <__fixunssfsi>:
    3312:	bc d0       	rcall	.+376    	; 0x348c <__fp_splitA>
    3314:	88 f0       	brcs	.+34     	; 0x3338 <__fixunssfsi+0x26>
    3316:	9f 57       	subi	r25, 0x7F	; 127
    3318:	90 f0       	brcs	.+36     	; 0x333e <__fixunssfsi+0x2c>
    331a:	b9 2f       	mov	r27, r25
    331c:	99 27       	eor	r25, r25
    331e:	b7 51       	subi	r27, 0x17	; 23
    3320:	a0 f0       	brcs	.+40     	; 0x334a <__fixunssfsi+0x38>
    3322:	d1 f0       	breq	.+52     	; 0x3358 <__fixunssfsi+0x46>
    3324:	66 0f       	add	r22, r22
    3326:	77 1f       	adc	r23, r23
    3328:	88 1f       	adc	r24, r24
    332a:	99 1f       	adc	r25, r25
    332c:	1a f0       	brmi	.+6      	; 0x3334 <__fixunssfsi+0x22>
    332e:	ba 95       	dec	r27
    3330:	c9 f7       	brne	.-14     	; 0x3324 <__fixunssfsi+0x12>
    3332:	12 c0       	rjmp	.+36     	; 0x3358 <__fixunssfsi+0x46>
    3334:	b1 30       	cpi	r27, 0x01	; 1
    3336:	81 f0       	breq	.+32     	; 0x3358 <__fixunssfsi+0x46>
    3338:	c3 d0       	rcall	.+390    	; 0x34c0 <__fp_zero>
    333a:	b1 e0       	ldi	r27, 0x01	; 1
    333c:	08 95       	ret
    333e:	c0 c0       	rjmp	.+384    	; 0x34c0 <__fp_zero>
    3340:	67 2f       	mov	r22, r23
    3342:	78 2f       	mov	r23, r24
    3344:	88 27       	eor	r24, r24
    3346:	b8 5f       	subi	r27, 0xF8	; 248
    3348:	39 f0       	breq	.+14     	; 0x3358 <__fixunssfsi+0x46>
    334a:	b9 3f       	cpi	r27, 0xF9	; 249
    334c:	cc f3       	brlt	.-14     	; 0x3340 <__fixunssfsi+0x2e>
    334e:	86 95       	lsr	r24
    3350:	77 95       	ror	r23
    3352:	67 95       	ror	r22
    3354:	b3 95       	inc	r27
    3356:	d9 f7       	brne	.-10     	; 0x334e <__fixunssfsi+0x3c>
    3358:	3e f4       	brtc	.+14     	; 0x3368 <__fixunssfsi+0x56>
    335a:	90 95       	com	r25
    335c:	80 95       	com	r24
    335e:	70 95       	com	r23
    3360:	61 95       	neg	r22
    3362:	7f 4f       	sbci	r23, 0xFF	; 255
    3364:	8f 4f       	sbci	r24, 0xFF	; 255
    3366:	9f 4f       	sbci	r25, 0xFF	; 255
    3368:	08 95       	ret

0000336a <__floatunsisf>:
    336a:	e8 94       	clt
    336c:	09 c0       	rjmp	.+18     	; 0x3380 <__floatsisf+0x12>

0000336e <__floatsisf>:
    336e:	97 fb       	bst	r25, 7
    3370:	3e f4       	brtc	.+14     	; 0x3380 <__floatsisf+0x12>
    3372:	90 95       	com	r25
    3374:	80 95       	com	r24
    3376:	70 95       	com	r23
    3378:	61 95       	neg	r22
    337a:	7f 4f       	sbci	r23, 0xFF	; 255
    337c:	8f 4f       	sbci	r24, 0xFF	; 255
    337e:	9f 4f       	sbci	r25, 0xFF	; 255
    3380:	99 23       	and	r25, r25
    3382:	a9 f0       	breq	.+42     	; 0x33ae <__floatsisf+0x40>
    3384:	f9 2f       	mov	r31, r25
    3386:	96 e9       	ldi	r25, 0x96	; 150
    3388:	bb 27       	eor	r27, r27
    338a:	93 95       	inc	r25
    338c:	f6 95       	lsr	r31
    338e:	87 95       	ror	r24
    3390:	77 95       	ror	r23
    3392:	67 95       	ror	r22
    3394:	b7 95       	ror	r27
    3396:	f1 11       	cpse	r31, r1
    3398:	f8 cf       	rjmp	.-16     	; 0x338a <__floatsisf+0x1c>
    339a:	fa f4       	brpl	.+62     	; 0x33da <__floatsisf+0x6c>
    339c:	bb 0f       	add	r27, r27
    339e:	11 f4       	brne	.+4      	; 0x33a4 <__floatsisf+0x36>
    33a0:	60 ff       	sbrs	r22, 0
    33a2:	1b c0       	rjmp	.+54     	; 0x33da <__floatsisf+0x6c>
    33a4:	6f 5f       	subi	r22, 0xFF	; 255
    33a6:	7f 4f       	sbci	r23, 0xFF	; 255
    33a8:	8f 4f       	sbci	r24, 0xFF	; 255
    33aa:	9f 4f       	sbci	r25, 0xFF	; 255
    33ac:	16 c0       	rjmp	.+44     	; 0x33da <__floatsisf+0x6c>
    33ae:	88 23       	and	r24, r24
    33b0:	11 f0       	breq	.+4      	; 0x33b6 <__floatsisf+0x48>
    33b2:	96 e9       	ldi	r25, 0x96	; 150
    33b4:	11 c0       	rjmp	.+34     	; 0x33d8 <__floatsisf+0x6a>
    33b6:	77 23       	and	r23, r23
    33b8:	21 f0       	breq	.+8      	; 0x33c2 <__floatsisf+0x54>
    33ba:	9e e8       	ldi	r25, 0x8E	; 142
    33bc:	87 2f       	mov	r24, r23
    33be:	76 2f       	mov	r23, r22
    33c0:	05 c0       	rjmp	.+10     	; 0x33cc <__floatsisf+0x5e>
    33c2:	66 23       	and	r22, r22
    33c4:	71 f0       	breq	.+28     	; 0x33e2 <__floatsisf+0x74>
    33c6:	96 e8       	ldi	r25, 0x86	; 134
    33c8:	86 2f       	mov	r24, r22
    33ca:	70 e0       	ldi	r23, 0x00	; 0
    33cc:	60 e0       	ldi	r22, 0x00	; 0
    33ce:	2a f0       	brmi	.+10     	; 0x33da <__floatsisf+0x6c>
    33d0:	9a 95       	dec	r25
    33d2:	66 0f       	add	r22, r22
    33d4:	77 1f       	adc	r23, r23
    33d6:	88 1f       	adc	r24, r24
    33d8:	da f7       	brpl	.-10     	; 0x33d0 <__floatsisf+0x62>
    33da:	88 0f       	add	r24, r24
    33dc:	96 95       	lsr	r25
    33de:	87 95       	ror	r24
    33e0:	97 f9       	bld	r25, 7
    33e2:	08 95       	ret

000033e4 <__fp_cmp>:
    33e4:	99 0f       	add	r25, r25
    33e6:	00 08       	sbc	r0, r0
    33e8:	55 0f       	add	r21, r21
    33ea:	aa 0b       	sbc	r26, r26
    33ec:	e0 e8       	ldi	r30, 0x80	; 128
    33ee:	fe ef       	ldi	r31, 0xFE	; 254
    33f0:	16 16       	cp	r1, r22
    33f2:	17 06       	cpc	r1, r23
    33f4:	e8 07       	cpc	r30, r24
    33f6:	f9 07       	cpc	r31, r25
    33f8:	c0 f0       	brcs	.+48     	; 0x342a <__fp_cmp+0x46>
    33fa:	12 16       	cp	r1, r18
    33fc:	13 06       	cpc	r1, r19
    33fe:	e4 07       	cpc	r30, r20
    3400:	f5 07       	cpc	r31, r21
    3402:	98 f0       	brcs	.+38     	; 0x342a <__fp_cmp+0x46>
    3404:	62 1b       	sub	r22, r18
    3406:	73 0b       	sbc	r23, r19
    3408:	84 0b       	sbc	r24, r20
    340a:	95 0b       	sbc	r25, r21
    340c:	39 f4       	brne	.+14     	; 0x341c <__fp_cmp+0x38>
    340e:	0a 26       	eor	r0, r26
    3410:	61 f0       	breq	.+24     	; 0x342a <__fp_cmp+0x46>
    3412:	23 2b       	or	r18, r19
    3414:	24 2b       	or	r18, r20
    3416:	25 2b       	or	r18, r21
    3418:	21 f4       	brne	.+8      	; 0x3422 <__fp_cmp+0x3e>
    341a:	08 95       	ret
    341c:	0a 26       	eor	r0, r26
    341e:	09 f4       	brne	.+2      	; 0x3422 <__fp_cmp+0x3e>
    3420:	a1 40       	sbci	r26, 0x01	; 1
    3422:	a6 95       	lsr	r26
    3424:	8f ef       	ldi	r24, 0xFF	; 255
    3426:	81 1d       	adc	r24, r1
    3428:	81 1d       	adc	r24, r1
    342a:	08 95       	ret

0000342c <__fp_inf>:
    342c:	97 f9       	bld	r25, 7
    342e:	9f 67       	ori	r25, 0x7F	; 127
    3430:	80 e8       	ldi	r24, 0x80	; 128
    3432:	70 e0       	ldi	r23, 0x00	; 0
    3434:	60 e0       	ldi	r22, 0x00	; 0
    3436:	08 95       	ret

00003438 <__fp_nan>:
    3438:	9f ef       	ldi	r25, 0xFF	; 255
    343a:	80 ec       	ldi	r24, 0xC0	; 192
    343c:	08 95       	ret

0000343e <__fp_pscA>:
    343e:	00 24       	eor	r0, r0
    3440:	0a 94       	dec	r0
    3442:	16 16       	cp	r1, r22
    3444:	17 06       	cpc	r1, r23
    3446:	18 06       	cpc	r1, r24
    3448:	09 06       	cpc	r0, r25
    344a:	08 95       	ret

0000344c <__fp_pscB>:
    344c:	00 24       	eor	r0, r0
    344e:	0a 94       	dec	r0
    3450:	12 16       	cp	r1, r18
    3452:	13 06       	cpc	r1, r19
    3454:	14 06       	cpc	r1, r20
    3456:	05 06       	cpc	r0, r21
    3458:	08 95       	ret

0000345a <__fp_round>:
    345a:	09 2e       	mov	r0, r25
    345c:	03 94       	inc	r0
    345e:	00 0c       	add	r0, r0
    3460:	11 f4       	brne	.+4      	; 0x3466 <__fp_round+0xc>
    3462:	88 23       	and	r24, r24
    3464:	52 f0       	brmi	.+20     	; 0x347a <__fp_round+0x20>
    3466:	bb 0f       	add	r27, r27
    3468:	40 f4       	brcc	.+16     	; 0x347a <__fp_round+0x20>
    346a:	bf 2b       	or	r27, r31
    346c:	11 f4       	brne	.+4      	; 0x3472 <__fp_round+0x18>
    346e:	60 ff       	sbrs	r22, 0
    3470:	04 c0       	rjmp	.+8      	; 0x347a <__fp_round+0x20>
    3472:	6f 5f       	subi	r22, 0xFF	; 255
    3474:	7f 4f       	sbci	r23, 0xFF	; 255
    3476:	8f 4f       	sbci	r24, 0xFF	; 255
    3478:	9f 4f       	sbci	r25, 0xFF	; 255
    347a:	08 95       	ret

0000347c <__fp_split3>:
    347c:	57 fd       	sbrc	r21, 7
    347e:	90 58       	subi	r25, 0x80	; 128
    3480:	44 0f       	add	r20, r20
    3482:	55 1f       	adc	r21, r21
    3484:	59 f0       	breq	.+22     	; 0x349c <__fp_splitA+0x10>
    3486:	5f 3f       	cpi	r21, 0xFF	; 255
    3488:	71 f0       	breq	.+28     	; 0x34a6 <__fp_splitA+0x1a>
    348a:	47 95       	ror	r20

0000348c <__fp_splitA>:
    348c:	88 0f       	add	r24, r24
    348e:	97 fb       	bst	r25, 7
    3490:	99 1f       	adc	r25, r25
    3492:	61 f0       	breq	.+24     	; 0x34ac <__fp_splitA+0x20>
    3494:	9f 3f       	cpi	r25, 0xFF	; 255
    3496:	79 f0       	breq	.+30     	; 0x34b6 <__fp_splitA+0x2a>
    3498:	87 95       	ror	r24
    349a:	08 95       	ret
    349c:	12 16       	cp	r1, r18
    349e:	13 06       	cpc	r1, r19
    34a0:	14 06       	cpc	r1, r20
    34a2:	55 1f       	adc	r21, r21
    34a4:	f2 cf       	rjmp	.-28     	; 0x348a <__fp_split3+0xe>
    34a6:	46 95       	lsr	r20
    34a8:	f1 df       	rcall	.-30     	; 0x348c <__fp_splitA>
    34aa:	08 c0       	rjmp	.+16     	; 0x34bc <__fp_splitA+0x30>
    34ac:	16 16       	cp	r1, r22
    34ae:	17 06       	cpc	r1, r23
    34b0:	18 06       	cpc	r1, r24
    34b2:	99 1f       	adc	r25, r25
    34b4:	f1 cf       	rjmp	.-30     	; 0x3498 <__fp_splitA+0xc>
    34b6:	86 95       	lsr	r24
    34b8:	71 05       	cpc	r23, r1
    34ba:	61 05       	cpc	r22, r1
    34bc:	08 94       	sec
    34be:	08 95       	ret

000034c0 <__fp_zero>:
    34c0:	e8 94       	clt

000034c2 <__fp_szero>:
    34c2:	bb 27       	eor	r27, r27
    34c4:	66 27       	eor	r22, r22
    34c6:	77 27       	eor	r23, r23
    34c8:	cb 01       	movw	r24, r22
    34ca:	97 f9       	bld	r25, 7
    34cc:	08 95       	ret

000034ce <__mulsf3>:
    34ce:	0b d0       	rcall	.+22     	; 0x34e6 <__mulsf3x>
    34d0:	c4 cf       	rjmp	.-120    	; 0x345a <__fp_round>
    34d2:	b5 df       	rcall	.-150    	; 0x343e <__fp_pscA>
    34d4:	28 f0       	brcs	.+10     	; 0x34e0 <__mulsf3+0x12>
    34d6:	ba df       	rcall	.-140    	; 0x344c <__fp_pscB>
    34d8:	18 f0       	brcs	.+6      	; 0x34e0 <__mulsf3+0x12>
    34da:	95 23       	and	r25, r21
    34dc:	09 f0       	breq	.+2      	; 0x34e0 <__mulsf3+0x12>
    34de:	a6 cf       	rjmp	.-180    	; 0x342c <__fp_inf>
    34e0:	ab cf       	rjmp	.-170    	; 0x3438 <__fp_nan>
    34e2:	11 24       	eor	r1, r1
    34e4:	ee cf       	rjmp	.-36     	; 0x34c2 <__fp_szero>

000034e6 <__mulsf3x>:
    34e6:	ca df       	rcall	.-108    	; 0x347c <__fp_split3>
    34e8:	a0 f3       	brcs	.-24     	; 0x34d2 <__mulsf3+0x4>

000034ea <__mulsf3_pse>:
    34ea:	95 9f       	mul	r25, r21
    34ec:	d1 f3       	breq	.-12     	; 0x34e2 <__mulsf3+0x14>
    34ee:	95 0f       	add	r25, r21
    34f0:	50 e0       	ldi	r21, 0x00	; 0
    34f2:	55 1f       	adc	r21, r21
    34f4:	62 9f       	mul	r22, r18
    34f6:	f0 01       	movw	r30, r0
    34f8:	72 9f       	mul	r23, r18
    34fa:	bb 27       	eor	r27, r27
    34fc:	f0 0d       	add	r31, r0
    34fe:	b1 1d       	adc	r27, r1
    3500:	63 9f       	mul	r22, r19
    3502:	aa 27       	eor	r26, r26
    3504:	f0 0d       	add	r31, r0
    3506:	b1 1d       	adc	r27, r1
    3508:	aa 1f       	adc	r26, r26
    350a:	64 9f       	mul	r22, r20
    350c:	66 27       	eor	r22, r22
    350e:	b0 0d       	add	r27, r0
    3510:	a1 1d       	adc	r26, r1
    3512:	66 1f       	adc	r22, r22
    3514:	82 9f       	mul	r24, r18
    3516:	22 27       	eor	r18, r18
    3518:	b0 0d       	add	r27, r0
    351a:	a1 1d       	adc	r26, r1
    351c:	62 1f       	adc	r22, r18
    351e:	73 9f       	mul	r23, r19
    3520:	b0 0d       	add	r27, r0
    3522:	a1 1d       	adc	r26, r1
    3524:	62 1f       	adc	r22, r18
    3526:	83 9f       	mul	r24, r19
    3528:	a0 0d       	add	r26, r0
    352a:	61 1d       	adc	r22, r1
    352c:	22 1f       	adc	r18, r18
    352e:	74 9f       	mul	r23, r20
    3530:	33 27       	eor	r19, r19
    3532:	a0 0d       	add	r26, r0
    3534:	61 1d       	adc	r22, r1
    3536:	23 1f       	adc	r18, r19
    3538:	84 9f       	mul	r24, r20
    353a:	60 0d       	add	r22, r0
    353c:	21 1d       	adc	r18, r1
    353e:	82 2f       	mov	r24, r18
    3540:	76 2f       	mov	r23, r22
    3542:	6a 2f       	mov	r22, r26
    3544:	11 24       	eor	r1, r1
    3546:	9f 57       	subi	r25, 0x7F	; 127
    3548:	50 40       	sbci	r21, 0x00	; 0
    354a:	8a f0       	brmi	.+34     	; 0x356e <__mulsf3_pse+0x84>
    354c:	e1 f0       	breq	.+56     	; 0x3586 <__mulsf3_pse+0x9c>
    354e:	88 23       	and	r24, r24
    3550:	4a f0       	brmi	.+18     	; 0x3564 <__mulsf3_pse+0x7a>
    3552:	ee 0f       	add	r30, r30
    3554:	ff 1f       	adc	r31, r31
    3556:	bb 1f       	adc	r27, r27
    3558:	66 1f       	adc	r22, r22
    355a:	77 1f       	adc	r23, r23
    355c:	88 1f       	adc	r24, r24
    355e:	91 50       	subi	r25, 0x01	; 1
    3560:	50 40       	sbci	r21, 0x00	; 0
    3562:	a9 f7       	brne	.-22     	; 0x354e <__mulsf3_pse+0x64>
    3564:	9e 3f       	cpi	r25, 0xFE	; 254
    3566:	51 05       	cpc	r21, r1
    3568:	70 f0       	brcs	.+28     	; 0x3586 <__mulsf3_pse+0x9c>
    356a:	60 cf       	rjmp	.-320    	; 0x342c <__fp_inf>
    356c:	aa cf       	rjmp	.-172    	; 0x34c2 <__fp_szero>
    356e:	5f 3f       	cpi	r21, 0xFF	; 255
    3570:	ec f3       	brlt	.-6      	; 0x356c <__mulsf3_pse+0x82>
    3572:	98 3e       	cpi	r25, 0xE8	; 232
    3574:	dc f3       	brlt	.-10     	; 0x356c <__mulsf3_pse+0x82>
    3576:	86 95       	lsr	r24
    3578:	77 95       	ror	r23
    357a:	67 95       	ror	r22
    357c:	b7 95       	ror	r27
    357e:	f7 95       	ror	r31
    3580:	e7 95       	ror	r30
    3582:	9f 5f       	subi	r25, 0xFF	; 255
    3584:	c1 f7       	brne	.-16     	; 0x3576 <__mulsf3_pse+0x8c>
    3586:	fe 2b       	or	r31, r30
    3588:	88 0f       	add	r24, r24
    358a:	91 1d       	adc	r25, r1
    358c:	96 95       	lsr	r25
    358e:	87 95       	ror	r24
    3590:	97 f9       	bld	r25, 7
    3592:	08 95       	ret

00003594 <pow>:
    3594:	fa 01       	movw	r30, r20
    3596:	ee 0f       	add	r30, r30
    3598:	ff 1f       	adc	r31, r31
    359a:	30 96       	adiw	r30, 0x00	; 0
    359c:	21 05       	cpc	r18, r1
    359e:	31 05       	cpc	r19, r1
    35a0:	99 f1       	breq	.+102    	; 0x3608 <pow+0x74>
    35a2:	61 15       	cp	r22, r1
    35a4:	71 05       	cpc	r23, r1
    35a6:	61 f4       	brne	.+24     	; 0x35c0 <pow+0x2c>
    35a8:	80 38       	cpi	r24, 0x80	; 128
    35aa:	bf e3       	ldi	r27, 0x3F	; 63
    35ac:	9b 07       	cpc	r25, r27
    35ae:	49 f1       	breq	.+82     	; 0x3602 <pow+0x6e>
    35b0:	68 94       	set
    35b2:	90 38       	cpi	r25, 0x80	; 128
    35b4:	81 05       	cpc	r24, r1
    35b6:	61 f0       	breq	.+24     	; 0x35d0 <pow+0x3c>
    35b8:	80 38       	cpi	r24, 0x80	; 128
    35ba:	bf ef       	ldi	r27, 0xFF	; 255
    35bc:	9b 07       	cpc	r25, r27
    35be:	41 f0       	breq	.+16     	; 0x35d0 <pow+0x3c>
    35c0:	99 23       	and	r25, r25
    35c2:	42 f5       	brpl	.+80     	; 0x3614 <pow+0x80>
    35c4:	ff 3f       	cpi	r31, 0xFF	; 255
    35c6:	e1 05       	cpc	r30, r1
    35c8:	31 05       	cpc	r19, r1
    35ca:	21 05       	cpc	r18, r1
    35cc:	11 f1       	breq	.+68     	; 0x3612 <pow+0x7e>
    35ce:	e8 94       	clt
    35d0:	08 94       	sec
    35d2:	e7 95       	ror	r30
    35d4:	d9 01       	movw	r26, r18
    35d6:	aa 23       	and	r26, r26
    35d8:	29 f4       	brne	.+10     	; 0x35e4 <pow+0x50>
    35da:	ab 2f       	mov	r26, r27
    35dc:	be 2f       	mov	r27, r30
    35de:	f8 5f       	subi	r31, 0xF8	; 248
    35e0:	d0 f3       	brcs	.-12     	; 0x35d6 <pow+0x42>
    35e2:	10 c0       	rjmp	.+32     	; 0x3604 <pow+0x70>
    35e4:	ff 5f       	subi	r31, 0xFF	; 255
    35e6:	70 f4       	brcc	.+28     	; 0x3604 <pow+0x70>
    35e8:	a6 95       	lsr	r26
    35ea:	e0 f7       	brcc	.-8      	; 0x35e4 <pow+0x50>
    35ec:	f7 39       	cpi	r31, 0x97	; 151
    35ee:	50 f0       	brcs	.+20     	; 0x3604 <pow+0x70>
    35f0:	19 f0       	breq	.+6      	; 0x35f8 <pow+0x64>
    35f2:	ff 3a       	cpi	r31, 0xAF	; 175
    35f4:	38 f4       	brcc	.+14     	; 0x3604 <pow+0x70>
    35f6:	9f 77       	andi	r25, 0x7F	; 127
    35f8:	9f 93       	push	r25
    35fa:	0c d0       	rcall	.+24     	; 0x3614 <pow+0x80>
    35fc:	0f 90       	pop	r0
    35fe:	07 fc       	sbrc	r0, 7
    3600:	90 58       	subi	r25, 0x80	; 128
    3602:	08 95       	ret
    3604:	3e f0       	brts	.+14     	; 0x3614 <pow+0x80>
    3606:	18 cf       	rjmp	.-464    	; 0x3438 <__fp_nan>
    3608:	60 e0       	ldi	r22, 0x00	; 0
    360a:	70 e0       	ldi	r23, 0x00	; 0
    360c:	80 e8       	ldi	r24, 0x80	; 128
    360e:	9f e3       	ldi	r25, 0x3F	; 63
    3610:	08 95       	ret
    3612:	4f e7       	ldi	r20, 0x7F	; 127
    3614:	9f 77       	andi	r25, 0x7F	; 127
    3616:	5f 93       	push	r21
    3618:	4f 93       	push	r20
    361a:	3f 93       	push	r19
    361c:	2f 93       	push	r18
    361e:	9e d0       	rcall	.+316    	; 0x375c <log>
    3620:	2f 91       	pop	r18
    3622:	3f 91       	pop	r19
    3624:	4f 91       	pop	r20
    3626:	5f 91       	pop	r21
    3628:	52 df       	rcall	.-348    	; 0x34ce <__mulsf3>
    362a:	05 c0       	rjmp	.+10     	; 0x3636 <exp>
    362c:	19 f4       	brne	.+6      	; 0x3634 <pow+0xa0>
    362e:	0e f0       	brts	.+2      	; 0x3632 <pow+0x9e>
    3630:	fd ce       	rjmp	.-518    	; 0x342c <__fp_inf>
    3632:	46 cf       	rjmp	.-372    	; 0x34c0 <__fp_zero>
    3634:	01 cf       	rjmp	.-510    	; 0x3438 <__fp_nan>

00003636 <exp>:
    3636:	2a df       	rcall	.-428    	; 0x348c <__fp_splitA>
    3638:	c8 f3       	brcs	.-14     	; 0x362c <pow+0x98>
    363a:	96 38       	cpi	r25, 0x86	; 134
    363c:	c0 f7       	brcc	.-16     	; 0x362e <pow+0x9a>
    363e:	07 f8       	bld	r0, 7
    3640:	0f 92       	push	r0
    3642:	e8 94       	clt
    3644:	2b e3       	ldi	r18, 0x3B	; 59
    3646:	3a ea       	ldi	r19, 0xAA	; 170
    3648:	48 eb       	ldi	r20, 0xB8	; 184
    364a:	5f e7       	ldi	r21, 0x7F	; 127
    364c:	4e df       	rcall	.-356    	; 0x34ea <__mulsf3_pse>
    364e:	0f 92       	push	r0
    3650:	0f 92       	push	r0
    3652:	0f 92       	push	r0
    3654:	4d b7       	in	r20, 0x3d	; 61
    3656:	5e b7       	in	r21, 0x3e	; 62
    3658:	0f 92       	push	r0
    365a:	c0 d0       	rcall	.+384    	; 0x37dc <modf>
    365c:	e4 ee       	ldi	r30, 0xE4	; 228
    365e:	f0 e0       	ldi	r31, 0x00	; 0
    3660:	16 d0       	rcall	.+44     	; 0x368e <__fp_powser>
    3662:	4f 91       	pop	r20
    3664:	5f 91       	pop	r21
    3666:	ef 91       	pop	r30
    3668:	ff 91       	pop	r31
    366a:	e5 95       	asr	r30
    366c:	ee 1f       	adc	r30, r30
    366e:	ff 1f       	adc	r31, r31
    3670:	49 f0       	breq	.+18     	; 0x3684 <exp+0x4e>
    3672:	fe 57       	subi	r31, 0x7E	; 126
    3674:	e0 68       	ori	r30, 0x80	; 128
    3676:	44 27       	eor	r20, r20
    3678:	ee 0f       	add	r30, r30
    367a:	44 1f       	adc	r20, r20
    367c:	fa 95       	dec	r31
    367e:	e1 f7       	brne	.-8      	; 0x3678 <exp+0x42>
    3680:	41 95       	neg	r20
    3682:	55 0b       	sbc	r21, r21
    3684:	32 d0       	rcall	.+100    	; 0x36ea <ldexp>
    3686:	0f 90       	pop	r0
    3688:	07 fe       	sbrs	r0, 7
    368a:	26 c0       	rjmp	.+76     	; 0x36d8 <inverse>
    368c:	08 95       	ret

0000368e <__fp_powser>:
    368e:	df 93       	push	r29
    3690:	cf 93       	push	r28
    3692:	1f 93       	push	r17
    3694:	0f 93       	push	r16
    3696:	ff 92       	push	r15
    3698:	ef 92       	push	r14
    369a:	df 92       	push	r13
    369c:	7b 01       	movw	r14, r22
    369e:	8c 01       	movw	r16, r24
    36a0:	68 94       	set
    36a2:	05 c0       	rjmp	.+10     	; 0x36ae <__fp_powser+0x20>
    36a4:	da 2e       	mov	r13, r26
    36a6:	ef 01       	movw	r28, r30
    36a8:	1e df       	rcall	.-452    	; 0x34e6 <__mulsf3x>
    36aa:	fe 01       	movw	r30, r28
    36ac:	e8 94       	clt
    36ae:	a5 91       	lpm	r26, Z+
    36b0:	25 91       	lpm	r18, Z+
    36b2:	35 91       	lpm	r19, Z+
    36b4:	45 91       	lpm	r20, Z+
    36b6:	55 91       	lpm	r21, Z+
    36b8:	ae f3       	brts	.-22     	; 0x36a4 <__fp_powser+0x16>
    36ba:	ef 01       	movw	r28, r30
    36bc:	66 dd       	rcall	.-1332   	; 0x318a <__addsf3x>
    36be:	fe 01       	movw	r30, r28
    36c0:	97 01       	movw	r18, r14
    36c2:	a8 01       	movw	r20, r16
    36c4:	da 94       	dec	r13
    36c6:	79 f7       	brne	.-34     	; 0x36a6 <__fp_powser+0x18>
    36c8:	df 90       	pop	r13
    36ca:	ef 90       	pop	r14
    36cc:	ff 90       	pop	r15
    36ce:	0f 91       	pop	r16
    36d0:	1f 91       	pop	r17
    36d2:	cf 91       	pop	r28
    36d4:	df 91       	pop	r29
    36d6:	08 95       	ret

000036d8 <inverse>:
    36d8:	9b 01       	movw	r18, r22
    36da:	ac 01       	movw	r20, r24
    36dc:	60 e0       	ldi	r22, 0x00	; 0
    36de:	70 e0       	ldi	r23, 0x00	; 0
    36e0:	80 e8       	ldi	r24, 0x80	; 128
    36e2:	9f e3       	ldi	r25, 0x3F	; 63
    36e4:	a9 cd       	rjmp	.-1198   	; 0x3238 <__divsf3>
    36e6:	a2 ce       	rjmp	.-700    	; 0x342c <__fp_inf>
    36e8:	ac c0       	rjmp	.+344    	; 0x3842 <__fp_mpack>

000036ea <ldexp>:
    36ea:	d0 de       	rcall	.-608    	; 0x348c <__fp_splitA>
    36ec:	e8 f3       	brcs	.-6      	; 0x36e8 <inverse+0x10>
    36ee:	99 23       	and	r25, r25
    36f0:	d9 f3       	breq	.-10     	; 0x36e8 <inverse+0x10>
    36f2:	94 0f       	add	r25, r20
    36f4:	51 1d       	adc	r21, r1
    36f6:	bb f3       	brvs	.-18     	; 0x36e6 <inverse+0xe>
    36f8:	91 50       	subi	r25, 0x01	; 1
    36fa:	50 40       	sbci	r21, 0x00	; 0
    36fc:	94 f0       	brlt	.+36     	; 0x3722 <ldexp+0x38>
    36fe:	59 f0       	breq	.+22     	; 0x3716 <ldexp+0x2c>
    3700:	88 23       	and	r24, r24
    3702:	32 f0       	brmi	.+12     	; 0x3710 <ldexp+0x26>
    3704:	66 0f       	add	r22, r22
    3706:	77 1f       	adc	r23, r23
    3708:	88 1f       	adc	r24, r24
    370a:	91 50       	subi	r25, 0x01	; 1
    370c:	50 40       	sbci	r21, 0x00	; 0
    370e:	c1 f7       	brne	.-16     	; 0x3700 <ldexp+0x16>
    3710:	9e 3f       	cpi	r25, 0xFE	; 254
    3712:	51 05       	cpc	r21, r1
    3714:	44 f7       	brge	.-48     	; 0x36e6 <inverse+0xe>
    3716:	88 0f       	add	r24, r24
    3718:	91 1d       	adc	r25, r1
    371a:	96 95       	lsr	r25
    371c:	87 95       	ror	r24
    371e:	97 f9       	bld	r25, 7
    3720:	08 95       	ret
    3722:	5f 3f       	cpi	r21, 0xFF	; 255
    3724:	ac f0       	brlt	.+42     	; 0x3750 <ldexp+0x66>
    3726:	98 3e       	cpi	r25, 0xE8	; 232
    3728:	9c f0       	brlt	.+38     	; 0x3750 <ldexp+0x66>
    372a:	bb 27       	eor	r27, r27
    372c:	86 95       	lsr	r24
    372e:	77 95       	ror	r23
    3730:	67 95       	ror	r22
    3732:	b7 95       	ror	r27
    3734:	08 f4       	brcc	.+2      	; 0x3738 <ldexp+0x4e>
    3736:	b1 60       	ori	r27, 0x01	; 1
    3738:	93 95       	inc	r25
    373a:	c1 f7       	brne	.-16     	; 0x372c <ldexp+0x42>
    373c:	bb 0f       	add	r27, r27
    373e:	58 f7       	brcc	.-42     	; 0x3716 <ldexp+0x2c>
    3740:	11 f4       	brne	.+4      	; 0x3746 <ldexp+0x5c>
    3742:	60 ff       	sbrs	r22, 0
    3744:	e8 cf       	rjmp	.-48     	; 0x3716 <ldexp+0x2c>
    3746:	6f 5f       	subi	r22, 0xFF	; 255
    3748:	7f 4f       	sbci	r23, 0xFF	; 255
    374a:	8f 4f       	sbci	r24, 0xFF	; 255
    374c:	9f 4f       	sbci	r25, 0xFF	; 255
    374e:	e3 cf       	rjmp	.-58     	; 0x3716 <ldexp+0x2c>
    3750:	b8 ce       	rjmp	.-656    	; 0x34c2 <__fp_szero>
    3752:	0e f0       	brts	.+2      	; 0x3756 <ldexp+0x6c>
    3754:	76 c0       	rjmp	.+236    	; 0x3842 <__fp_mpack>
    3756:	70 ce       	rjmp	.-800    	; 0x3438 <__fp_nan>
    3758:	68 94       	set
    375a:	68 ce       	rjmp	.-816    	; 0x342c <__fp_inf>

0000375c <log>:
    375c:	97 de       	rcall	.-722    	; 0x348c <__fp_splitA>
    375e:	c8 f3       	brcs	.-14     	; 0x3752 <ldexp+0x68>
    3760:	99 23       	and	r25, r25
    3762:	d1 f3       	breq	.-12     	; 0x3758 <ldexp+0x6e>
    3764:	c6 f3       	brts	.-16     	; 0x3756 <ldexp+0x6c>
    3766:	df 93       	push	r29
    3768:	cf 93       	push	r28
    376a:	1f 93       	push	r17
    376c:	0f 93       	push	r16
    376e:	ff 92       	push	r15
    3770:	c9 2f       	mov	r28, r25
    3772:	dd 27       	eor	r29, r29
    3774:	88 23       	and	r24, r24
    3776:	2a f0       	brmi	.+10     	; 0x3782 <log+0x26>
    3778:	21 97       	sbiw	r28, 0x01	; 1
    377a:	66 0f       	add	r22, r22
    377c:	77 1f       	adc	r23, r23
    377e:	88 1f       	adc	r24, r24
    3780:	da f7       	brpl	.-10     	; 0x3778 <log+0x1c>
    3782:	20 e0       	ldi	r18, 0x00	; 0
    3784:	30 e0       	ldi	r19, 0x00	; 0
    3786:	40 e8       	ldi	r20, 0x80	; 128
    3788:	5f eb       	ldi	r21, 0xBF	; 191
    378a:	9f e3       	ldi	r25, 0x3F	; 63
    378c:	88 39       	cpi	r24, 0x98	; 152
    378e:	20 f0       	brcs	.+8      	; 0x3798 <log+0x3c>
    3790:	80 3e       	cpi	r24, 0xE0	; 224
    3792:	30 f0       	brcs	.+12     	; 0x37a0 <log+0x44>
    3794:	21 96       	adiw	r28, 0x01	; 1
    3796:	8f 77       	andi	r24, 0x7F	; 127
    3798:	e7 dc       	rcall	.-1586   	; 0x3168 <__addsf3>
    379a:	ec e0       	ldi	r30, 0x0C	; 12
    379c:	f1 e0       	ldi	r31, 0x01	; 1
    379e:	03 c0       	rjmp	.+6      	; 0x37a6 <log+0x4a>
    37a0:	e3 dc       	rcall	.-1594   	; 0x3168 <__addsf3>
    37a2:	e9 e3       	ldi	r30, 0x39	; 57
    37a4:	f1 e0       	ldi	r31, 0x01	; 1
    37a6:	73 df       	rcall	.-282    	; 0x368e <__fp_powser>
    37a8:	8b 01       	movw	r16, r22
    37aa:	be 01       	movw	r22, r28
    37ac:	ec 01       	movw	r28, r24
    37ae:	fb 2e       	mov	r15, r27
    37b0:	6f 57       	subi	r22, 0x7F	; 127
    37b2:	71 09       	sbc	r23, r1
    37b4:	75 95       	asr	r23
    37b6:	77 1f       	adc	r23, r23
    37b8:	88 0b       	sbc	r24, r24
    37ba:	99 0b       	sbc	r25, r25
    37bc:	d8 dd       	rcall	.-1104   	; 0x336e <__floatsisf>
    37be:	28 e1       	ldi	r18, 0x18	; 24
    37c0:	32 e7       	ldi	r19, 0x72	; 114
    37c2:	41 e3       	ldi	r20, 0x31	; 49
    37c4:	5f e3       	ldi	r21, 0x3F	; 63
    37c6:	8f de       	rcall	.-738    	; 0x34e6 <__mulsf3x>
    37c8:	af 2d       	mov	r26, r15
    37ca:	98 01       	movw	r18, r16
    37cc:	ae 01       	movw	r20, r28
    37ce:	ff 90       	pop	r15
    37d0:	0f 91       	pop	r16
    37d2:	1f 91       	pop	r17
    37d4:	cf 91       	pop	r28
    37d6:	df 91       	pop	r29
    37d8:	d8 dc       	rcall	.-1616   	; 0x318a <__addsf3x>
    37da:	3f ce       	rjmp	.-898    	; 0x345a <__fp_round>

000037dc <modf>:
    37dc:	fa 01       	movw	r30, r20
    37de:	dc 01       	movw	r26, r24
    37e0:	aa 0f       	add	r26, r26
    37e2:	bb 1f       	adc	r27, r27
    37e4:	9b 01       	movw	r18, r22
    37e6:	ac 01       	movw	r20, r24
    37e8:	bf 57       	subi	r27, 0x7F	; 127
    37ea:	28 f4       	brcc	.+10     	; 0x37f6 <modf+0x1a>
    37ec:	22 27       	eor	r18, r18
    37ee:	33 27       	eor	r19, r19
    37f0:	44 27       	eor	r20, r20
    37f2:	50 78       	andi	r21, 0x80	; 128
    37f4:	1f c0       	rjmp	.+62     	; 0x3834 <modf+0x58>
    37f6:	b7 51       	subi	r27, 0x17	; 23
    37f8:	88 f4       	brcc	.+34     	; 0x381c <modf+0x40>
    37fa:	ab 2f       	mov	r26, r27
    37fc:	00 24       	eor	r0, r0
    37fe:	46 95       	lsr	r20
    3800:	37 95       	ror	r19
    3802:	27 95       	ror	r18
    3804:	01 1c       	adc	r0, r1
    3806:	a3 95       	inc	r26
    3808:	d2 f3       	brmi	.-12     	; 0x37fe <modf+0x22>
    380a:	00 20       	and	r0, r0
    380c:	69 f0       	breq	.+26     	; 0x3828 <modf+0x4c>
    380e:	22 0f       	add	r18, r18
    3810:	33 1f       	adc	r19, r19
    3812:	44 1f       	adc	r20, r20
    3814:	b3 95       	inc	r27
    3816:	da f3       	brmi	.-10     	; 0x380e <modf+0x32>
    3818:	0d d0       	rcall	.+26     	; 0x3834 <modf+0x58>
    381a:	a5 cc       	rjmp	.-1718   	; 0x3166 <__subsf3>
    381c:	61 30       	cpi	r22, 0x01	; 1
    381e:	71 05       	cpc	r23, r1
    3820:	a0 e8       	ldi	r26, 0x80	; 128
    3822:	8a 07       	cpc	r24, r26
    3824:	b9 46       	sbci	r27, 0x69	; 105
    3826:	30 f4       	brcc	.+12     	; 0x3834 <modf+0x58>
    3828:	9b 01       	movw	r18, r22
    382a:	ac 01       	movw	r20, r24
    382c:	66 27       	eor	r22, r22
    382e:	77 27       	eor	r23, r23
    3830:	88 27       	eor	r24, r24
    3832:	90 78       	andi	r25, 0x80	; 128
    3834:	30 96       	adiw	r30, 0x00	; 0
    3836:	21 f0       	breq	.+8      	; 0x3840 <modf+0x64>
    3838:	20 83       	st	Z, r18
    383a:	31 83       	std	Z+1, r19	; 0x01
    383c:	42 83       	std	Z+2, r20	; 0x02
    383e:	53 83       	std	Z+3, r21	; 0x03
    3840:	08 95       	ret

00003842 <__fp_mpack>:
    3842:	9f 3f       	cpi	r25, 0xFF	; 255
    3844:	31 f0       	breq	.+12     	; 0x3852 <__fp_mpack_finite+0xc>

00003846 <__fp_mpack_finite>:
    3846:	91 50       	subi	r25, 0x01	; 1
    3848:	20 f4       	brcc	.+8      	; 0x3852 <__fp_mpack_finite+0xc>
    384a:	87 95       	ror	r24
    384c:	77 95       	ror	r23
    384e:	67 95       	ror	r22
    3850:	b7 95       	ror	r27
    3852:	88 0f       	add	r24, r24
    3854:	91 1d       	adc	r25, r1
    3856:	96 95       	lsr	r25
    3858:	87 95       	ror	r24
    385a:	97 f9       	bld	r25, 7
    385c:	08 95       	ret

0000385e <__udivmodhi4>:
    385e:	aa 1b       	sub	r26, r26
    3860:	bb 1b       	sub	r27, r27
    3862:	51 e1       	ldi	r21, 0x11	; 17
    3864:	07 c0       	rjmp	.+14     	; 0x3874 <__udivmodhi4_ep>

00003866 <__udivmodhi4_loop>:
    3866:	aa 1f       	adc	r26, r26
    3868:	bb 1f       	adc	r27, r27
    386a:	a6 17       	cp	r26, r22
    386c:	b7 07       	cpc	r27, r23
    386e:	10 f0       	brcs	.+4      	; 0x3874 <__udivmodhi4_ep>
    3870:	a6 1b       	sub	r26, r22
    3872:	b7 0b       	sbc	r27, r23

00003874 <__udivmodhi4_ep>:
    3874:	88 1f       	adc	r24, r24
    3876:	99 1f       	adc	r25, r25
    3878:	5a 95       	dec	r21
    387a:	a9 f7       	brne	.-22     	; 0x3866 <__udivmodhi4_loop>
    387c:	80 95       	com	r24
    387e:	90 95       	com	r25
    3880:	bc 01       	movw	r22, r24
    3882:	cd 01       	movw	r24, r26
    3884:	08 95       	ret

00003886 <__divmodhi4>:
    3886:	97 fb       	bst	r25, 7
    3888:	09 2e       	mov	r0, r25
    388a:	07 26       	eor	r0, r23
    388c:	0a d0       	rcall	.+20     	; 0x38a2 <__divmodhi4_neg1>
    388e:	77 fd       	sbrc	r23, 7
    3890:	04 d0       	rcall	.+8      	; 0x389a <__divmodhi4_neg2>
    3892:	e5 df       	rcall	.-54     	; 0x385e <__udivmodhi4>
    3894:	06 d0       	rcall	.+12     	; 0x38a2 <__divmodhi4_neg1>
    3896:	00 20       	and	r0, r0
    3898:	1a f4       	brpl	.+6      	; 0x38a0 <__divmodhi4_exit>

0000389a <__divmodhi4_neg2>:
    389a:	70 95       	com	r23
    389c:	61 95       	neg	r22
    389e:	7f 4f       	sbci	r23, 0xFF	; 255

000038a0 <__divmodhi4_exit>:
    38a0:	08 95       	ret

000038a2 <__divmodhi4_neg1>:
    38a2:	f6 f7       	brtc	.-4      	; 0x38a0 <__divmodhi4_exit>
    38a4:	90 95       	com	r25
    38a6:	81 95       	neg	r24
    38a8:	9f 4f       	sbci	r25, 0xFF	; 255
    38aa:	08 95       	ret

000038ac <__udivmodsi4>:
    38ac:	a1 e2       	ldi	r26, 0x21	; 33
    38ae:	1a 2e       	mov	r1, r26
    38b0:	aa 1b       	sub	r26, r26
    38b2:	bb 1b       	sub	r27, r27
    38b4:	fd 01       	movw	r30, r26
    38b6:	0d c0       	rjmp	.+26     	; 0x38d2 <__udivmodsi4_ep>

000038b8 <__udivmodsi4_loop>:
    38b8:	aa 1f       	adc	r26, r26
    38ba:	bb 1f       	adc	r27, r27
    38bc:	ee 1f       	adc	r30, r30
    38be:	ff 1f       	adc	r31, r31
    38c0:	a2 17       	cp	r26, r18
    38c2:	b3 07       	cpc	r27, r19
    38c4:	e4 07       	cpc	r30, r20
    38c6:	f5 07       	cpc	r31, r21
    38c8:	20 f0       	brcs	.+8      	; 0x38d2 <__udivmodsi4_ep>
    38ca:	a2 1b       	sub	r26, r18
    38cc:	b3 0b       	sbc	r27, r19
    38ce:	e4 0b       	sbc	r30, r20
    38d0:	f5 0b       	sbc	r31, r21

000038d2 <__udivmodsi4_ep>:
    38d2:	66 1f       	adc	r22, r22
    38d4:	77 1f       	adc	r23, r23
    38d6:	88 1f       	adc	r24, r24
    38d8:	99 1f       	adc	r25, r25
    38da:	1a 94       	dec	r1
    38dc:	69 f7       	brne	.-38     	; 0x38b8 <__udivmodsi4_loop>
    38de:	60 95       	com	r22
    38e0:	70 95       	com	r23
    38e2:	80 95       	com	r24
    38e4:	90 95       	com	r25
    38e6:	9b 01       	movw	r18, r22
    38e8:	ac 01       	movw	r20, r24
    38ea:	bd 01       	movw	r22, r26
    38ec:	cf 01       	movw	r24, r30
    38ee:	08 95       	ret

000038f0 <_exit>:
    38f0:	f8 94       	cli

000038f2 <__stop_program>:
    38f2:	ff cf       	rjmp	.-2      	; 0x38f2 <__stop_program>
